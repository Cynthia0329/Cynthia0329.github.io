<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第三方css插件（持续更新）]]></title>
    <url>%2F2019%2F12%2F19%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E7%AC%AC%E4%B8%89%E6%96%B9css%E6%8F%92%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰…]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三方vue插件（持续更新）]]></title>
    <url>%2F2019%2F12%2F19%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E7%AC%AC%E4%B8%89%E6%96%B9vue%E6%8F%92%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰…]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三方js插件（持续更新）]]></title>
    <url>%2F2019%2F12%2F19%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E7%AC%AC%E4%B8%89%E6%96%B9js%E6%8F%92%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 待分类 js-cookie （一个轻量的JavaScript库来处理cookie） clipboard.js （点击复制） NProgress.js （轻量的全局进度条控制） FastClick （移动端点击事件消除300ms延迟 - 目前最佳方案） 具体使用Moment.js Moment.js （时间处理工具库） 格式化date类型和字符串类型 123moment(new Date()).format('YYYYMMDD')moment(new Date()).format('YYYY-MM-DD')moment('20191025').format('YYYY-MM-DD') // 2019-10-25 lodash.js 官网 一个一致性、模块化、高性能的 JavaScript 实用工具库 使用时注意：很多工具方法在新的ES中已经集成，优先考虑原生函数，再使用工具库 已使用汇总 _.round 根据精度，进行四舍五入 数组Array 文档：https://www.lodashjs.com/docs/latest _.chunk(array, [size=1]) 返回一个包含拆分区块的新数组（相当于一个二维数组） _.compact(array) 去除false, null, 0, “”, undefined, 和 NaN 等假值，返回一个新数组 clone相关 文档：https://www.lodashjs.com/docs/latest _.clone(value) 创建一个 value 的浅拷贝 _.cloneWith(value, [customizer]) 类似 _.clone，除了它接受一个 customizer 定制返回的克隆值。 _.cloneDeep(value) 创建一个 value 的深拷贝 _.cloneDeepWith(value, [customizer]) 类似 _.cloneWith，深拷贝]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理平台：日事清使用总结（持续更新）]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%EF%BC%9A%E6%97%A5%E4%BA%8B%E6%B8%85%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 计划计划设置 计划设置包括计划信息、偏好设置、权限设置、高级设置四个部分，可以对当前计划进行多种设置。 计划信息]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview使用总结（持续更新）]]></title>
    <url>%2F2019%2F10%2F23%2Fiview%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 主题通过iview-theme定制iView主题 注意： 需要安装less和less-loader （less的版本不要超过3.0，如2.7.3就可以） 树形控件Tree 官方文档：https://www.iviewui.com/components/tree 问题汇总 vue项目导入iview个别组件无效的原因]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端浏览器兼容问题汇总（持续更新）]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… vue-cli3兼容ie 如果以下配置都不行：请检查是否是第三方插件的原因 详解Vue-cli3 项目在安卓低版本系统和IE上白屏问题解决 五步究极配置（能解决一般vue项目，element待议） 配置.browserslist browserslist 配置自动检测需要转译的语言特性，为构建代码转译JavaScript 并为 CSS 添加浏览器前缀 通常只需要修改 browserslist 即可兼容目标浏览器 配置这一项，有两个途径： 一是 在 package.json文件中，添加 browserslist 字段； 二是 在项目根目录，创建一个 .browserslistrc 文件 这两种方法不能同时配置，不然运行serve命令会报错。 例如兼容IE10可以做如下配置： 123&gt; 1%last 4 versionsie 10 配置babel-polyfil安装babel-polyfil模块1npm install babel-polyfill -s vue.config.js文件 如果确切知道有兼容性问题的依赖包名，可以将依赖包名添加到 transpileDependencies 键中 这会为该依赖同时开启语法语法转换和根据使用情况检测 polyfill。 例如： 123module.exports = &#123; transpileDependencies: ["vue-plugin-load-script"] // 需要编译的依赖包名&#125; 在 vue.config.js 中的 configureWebpack 字段中 12345configureWebpack: config =&gt; &#123; config.entry.app = ["babel-polyfill", "./src/main.js"]; // config.entry.app = ["babel-polyfill", resolve('src/main.js')] // config.entry('main').add('babel-polyfill') // main是入口js文件&#125; babel.config.js文件如果确切的知道需要转译的语言特性，可以配置根目录下的babel.config.js，为presets的值添加所需要的 polyfill 123456789module.exports = &#123; presets: [ ['@vue/app', &#123; polyfills: [ 'es6.symbol' ] &#125;] ]&#125; 然而更多的情况是，我们并不确切的知道项目中引发兼容问题的具体原因，这时还可以配置为根据兼容目标导入所有 polyfill，需要设置babel.config.js为： 1234567module.exports = &#123; presets: [ ['@vue/app', &#123; useBuiltIns: 'entry' &#125;] ]&#125; 同时在入口文件（main.js）第一行添加 1import '@babel/polyfill' 注意：这种方式可能导入代码中不需要的polyfill，从而使打包体积更大。 第三方插件兼容ie vue-echarts在ie不兼容的解决办法]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的博客汇总（持续更新）]]></title>
    <url>%2F2019%2F10%2F21%2F%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… hexo博客前端 https://refined-x.com/]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用css样式的mixins归纳（持续更新）]]></title>
    <url>%2F2019%2F10%2F18%2F%E5%B8%B8%E7%94%A8css%E6%A0%B7%E5%BC%8F%E7%9A%84mixins%E5%BD%92%E7%BA%B3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 布局flex布局 水平 123456789101112131415161718192021222324// 使flex布局的子元素 水平顺序排列 垂直居中显示@mixin center &#123; display: flex; justify-content: center; align-items: center;&#125;// 使flex布局的子元素 水平从左排列 垂直居中显示@mixin left &#123; display: flex; justify-content: flex-start; align-items: center;&#125;// 使flex布局的子元素 水平从右排列 垂直居中显示@mixin right &#123; display: flex; justify-content: flex-end; align-items: center;&#125;// 使flex布局的子元素 水平顺序排列 垂直顶端对齐显示@mixin top &#123; display: flex; justify-content: center; align-items: flex-start;&#125; 垂直 123456789101112131415161718192021// 使flex布局的子元素 整体垂直从上到下排列 水平居中显示@mixin columnTop &#123; display: flex; flex-direction: column; justify-content: flex-start; align-items: center;&#125;// 使flex布局的子元素 整体垂直居中 水平居左显示@mixin columnLeft &#123; display: flex; flex-direction: column; justify-content: center; align-items: flex-start;&#125;// 使flex布局的子元素 整体垂直居中 水平居中显示@mixin columnCenter &#123; display: flex; flex-direction: column; justify-content: center; align-items: center;&#125; 文字省略1234567891011121314151617// 文字超过一行省略显示@mixin ellipsis &#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125;// 文字超过xx行省略显示@mixin ellipsis2($line) &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: $line; white-space: normal; overflow: hidden; text-overflow: ellipsis; word-break: keep-all;&#125; 计算转换rem12345$ratio: 375 / 10;@function px2rem($px) &#123; @return $px / $ratio + rem;&#125;]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[色彩相关知识总结（持续更新）]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%89%B2%E5%BD%A9%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 颜色代码16进制颜色代码以0、1、2、3、4、5、6、7、8、9、A、B、 C、D、E、F共16位组成。 16进制颜色代码指定颜色的组成方式： 前两位：红色 中间两位：绿色 最后两位：蓝色 把三个数值依次并列起来 ，以#开头。 举例： 纯红：#FF0000 FF：即十进制的R（红）=255 00和00即G（绿）=0和B（蓝）=0。 纯绿：#00FF00 即R=0，G=255，B=0。]]></content>
      <categories>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B端UI设计总结（持续更新）]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%AE%BE%E8%AE%A1%2FB%E7%AB%AFUI%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 布局参考1：[点我查看图片] 配色参考：【大分类说明】⭐较优方案 参考：【单个说明】 字体参考1：[点我查看图片] 图标参考1：[点我查看图片] 表单输入框 按钮 选框 表格基础表格导航和Tab标签其它控件标签进度条分页标记Notice消息通知/提示[点我查看图片] 消息弹窗/加载[点我查看图片]]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号编辑器排版的几种方法（分代码和无代码）]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%AE%BE%E8%AE%A1%2F%E6%8E%92%E7%89%88%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%92%E7%89%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E5%88%86%E4%BB%A3%E7%A0%81%E5%92%8C%E6%97%A0%E4%BB%A3%E7%A0%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰…]]></content>
      <categories>
        <category>设计</category>
        <category>排版</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术简介（持续更新）]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[老是看到这个技术名词的出现，稍微了解了一下大体是什么，此处只做一个简单的简介汇总 区块链是什么百度百科 本质 核心技术]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AE表达式使用教程（持续更新）]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%2FAE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 官方指南： After Effects 用户指南 表达式和自动化 表达式基础知识 表达式语言引用 表达式示例 表达式基础知识 表达式基础知识 表达式语言索引和标签 在 After Effects 中从 1 开始为 Layer、Effect 和 Mask 元素建立索引。例如，“时间轴”面板中的第一个图层是 layer(1)。 通常，如果移动了图层、效果或蒙版，或者在产品更新和升级期间更改了参数，则最好使用图层、效果或蒙版的名称而不是编号，以避免混淆和错误。当您使用名称时，请始终将其括在直引号中。 1234// 例如，这些表达式中的第一个比第二个更易于理解，即使您更改效果的顺序，第一个表达式也会继续运行effect("Colorama").param("Get Phase From") effect(1).param(2) 表达式时间 表达式中的时间始终采用合成时间（而不是图层时间）并且以秒计算。任何表达式的默认时间是将计算表达式的当前合成时间。 下列表达式均使用默认合成时间并返回相同值： 12thisComp.layer(1).position thisComp.layer(1).position.valueAtTime(time) 要使用相对时间，请向 time 参数添加增量时间值。例如，要在当前时间之前 5 秒获取位置值，请使用以下表达式： 1thisComp.layer(1).position.valueAtTime(time-5) 对嵌套合成中属性的默认时间引用使用原始默认合成时间，而不是重新映射的时间。但是，如果您使用 source 函数检索属性，则将使用重新映射的时间。 例如，如果包含的合成中的图层源是嵌套合成，且包含的合成中有重新映射的时间，则当您使用以下表达式获取嵌套合成中图层的位置值时，位置值将使用合成的默认时间： 1comp("nested composition").layer(1).position 但是，如果您使用 source 函数访问图层 1，则位置值将使用重新映射的时间： 注意:如果您在表达式中使用特定时间，After Effects 会忽略重新映射的时间。]]></content>
      <categories>
        <category>设计</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AE表达式大全中英文对照手册(整理中)]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%2FAE%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7%2F</url>
    <content type="text"><![CDATA[🐰… 优秀教程汇总 超赞！一份实用简单好上手的AE表达式江湖文档 AE常用表达式详解 12345// 练习r=thisComp.layer("数值").effect("编号")("数值/位移/随机最大")linear(r,0,100,-180,45) 全局对象（global） 对象 说明 Comp comp(name) 用另一个名字给合成命名。 Footage footage(name) 用另一个名字给脚本标志命名。 Comp thisComp 描述合成内容的表达式。例如：thisComp.layer(2) Layer, Light, or Camera thisLayer 是对层本身的描述，thisLayer是一个默认的对象，对它的应用是可选的。例如, 用表达式 thisLayer.width 或 width 可获得同样的结果。 Property thisProperty 描述属性的表达式。例如，如果写一个旋转属性的表达式就能获取旋转属性的值。 Number time 描述合成的时间, 单位是秒。 Number colorDepth 返回8或16表示的彩色深度位数值。例如, 当项目的每通道的彩色深度为16位时colorDepth 返回16 。 Number posterizeTime (framesPerSecond) {framesPerSecond 是一个数}返回或改变帧率。允许用这个表达式设置比合成低的帧率。 向量数学方法（Vector Math）Array add(vec1, vec2) {vec1 和 vec2 是数组} 两个向量相加。Array sub(vec1, vec2) {vec1 和 vec2 是数组}两个向量相减。Array mul(vec1, amount) {vec1 是数组, amount 是数} 向量的每个元素被 amount相乘。Array div(vec1, amount) {vec1 是数组, amount 是数}向量的每个元素被 amount相除。Number or Array Clamp(value, limit1, limit2) 限制value中每个元素的值在 limit1 到 limit2之间。Number dot(vec1, vec2) {vec1 和 vec2 是数组} 返回点积, 结果为两个向量相乘。Array [2 or 3] cross(vec1, vec2) {vec1 和 vec2 是数组 [2 or 3]} 返回向量的交积。Array normalize(vec) {vec 是数组} 格式化一个向量,如某长度表示为1.0.Number length(vec) {vec是数组}返回向量的长度。Number length(point1, point2) {point1 and point2 是数组} 随机数方法(Random Numbers)Nothing seedRandom(seed, timeless=false) {seed 是一个数, 默认 timeless 为 false} 取现有的seed 增量一个随机值,这个随机值依赖于层的 index (number) 和 stream (property),但不总是这样. 例如, seedRandom (n, true)通过给第二个参数赋值 true ,seedRandom()获取一个0到1间的随机数.Number random()返回0和1间的随机数.Number or Array random(maxValOrArray) {maxValOrArray 是一个数或数组}返回0到maxVal间的数,维度 与 maxVal相同; 或返回与maxArray相同维度的数组, 数组的每个元素在 0 到 maxArray之间Number or Array random(minValOrArray, maxValOrArray) {minValOrArray 和 maxValOrArray 是一个数或数组} 返回一个minVal 到 maxVal间的数, 或返回一个与 minArray和maxArray有相同维度的数组,其每个元素的范围在 minArray 与 maxArray之间.例如, random([100, 200], [300, 400]) 返回数组的第一个值在 100 到300间, 第二个值在 200 到400间.如果两个数组的维度不同，较短的一个后面自动用0补齐.Number gaussRandom()返回一个0到1之间的随机数. 结果为钟形分布,大约90%的结果在 0 到1之间, 剩余10%在边沿.Number or Array gaussRandom(maxValOrArray){maxValOrArray是一个数或数组}当用maxVal,它返回一个0到maxVal之间的随机数. 结果为钟形分布,大约90%的结果在0到maxVal之间,剩余10%在边缘.当用maxArray,它返回一个与maxArray相同维度的数组, 结果为钟形分布,大约90%的结果在 0到maxArray之间, 剩余10%在边缘.Number gaussRandom(minValOrArray, maxValOrArray){minValOrArray和maxValOrArray是一个数或数组} 当用minVal和 maxVal, 它返回一个minVal到maxVal之间的随机数. 结果为钟形分布,大约90%的结果在minVal到maxVal之间, 剩余10%在边缘.当用minArray和maxArray, 它返回一个与 minArray和maxArray相同维度的数组, 结果为钟形分布,大约90%的结果在 minArray到maxArray之间, 剩余10%在边缘. 剩余10%在边缘.Number noise(valOrArray) {valOrArray是一个数或数组 [2 or 3]}返回一个0到1间的数.噪声不是事实上的随机,但它是在样本附近相关的随机数.它基于花边噪声 . 例如, add(position, noise(position)*50). 插值方法（interpolation）Linear（线性运动）表达式一linear(t, value1, value2) {t 是一个数, value1 和 value2 是一个数或数组} t：指定图层 或者 合成tmin最小值/tmax最大值 0&lt;t&lt;1：返回一个从value1到value2的线性插值 t &lt;= 0：返回value1 t &gt;= 1：返回 value2 value1：当最小值时返回的作用数值 value2：当最大值时返回的作用数值 表达式二linear(t, tMin, tMax, value1, value2) {t, tMin和 tMax are 数, value1和value2 是数或数组} t &lt;= tmin：返回value1 t &gt;= tMax：返回value2 tMin &lt; t &lt; tMax ：返回 value1和value2 的线性联合 举例123456t=thisComp.layer("圆形").transform.position[1];linear(t,-299,299,90,-90)// 该图层Y轴与另外的图层Y值相同（比如码表的码数t和指针的旋转度数value）// 当最小值是-299时，该图层旋转90度// 当最大值是299时，旋转-90度 EaseNumber or Array ease(t, value1, value2) {t 是一个数, value1 和 value2 是数或数组} 返回值与linear相似, 但在开始和结束点的速率都为0。这种方法的结果是动画非常平滑。Number or Array ease(t, tMin, tMax, value1, value2) {t, tMin, 和 tMax 是数, value1 和 value2 是数或数组} 返回 值与 linear相似, 但在开始和结束点的速率都为0。这种方法的结果是动画非常平滑。Number or Array easeIn(t, value1, value2) {t 是一个数, and value1 and value2 是数或数组} 返回 值与ease相似, 但只在切入点value1 的速率为0，靠近value2 一边是线性的。Number or Array easeIn(t, tMin, tMax, value1, value2) {t, tMin和tMax 是一个数, value1和value2 是数或数组}返回 值与ease相似, 但只在切入点tMin 的速率为0，靠近tMax 一边是线性的。Number or Array easeOut(t, value1, value2) {t 是一个数, value1和value2 是数或数组}.返回 值与ease相似, 但只在切入点value2 的速率为0，靠近value1 一边是线性的。Number or Array easeOut(t, tMin, tMax, value1, value2) {t, tMin和tMax 是数, value1 value2 是数或数组} 返回 值与ease相似, 但只在切入点tMax的速率为0，靠近tMin 一边是线性的。 彩色转换方法 ( Color Conversion )Array [4] rgbToHsl(rgbaArray) {rgbaArray 是数组 [4]} 转换 RGBA 彩色空间到 HSLA彩色空间。输入数组指定红、绿、蓝、透明， 它们的范围都在 0.0 到 1.0之间。结果值是一个指定色调、饱和度、亮度和透明的数组，它们的范围都在 0.0 到 1.0之间。例如, rgbToHsl.effect(“Change Color”)(“Color To Change”)。Array [4] hslToRgb(hslaArray) {hslaArray 是数组[4]}. 转换 HSLA彩色空间到RGBA 彩色空间。其操作与rgbToHsl相反。 其它数学方法 ( Other Math )Number degreesToRadians(degrees)转换度到弧度。Number radiansToDegrees(radians) 转换弧度到度。 Comp-——————————————————————————-Layer, Light, or Camera layer(index) {index 是一个数} 得到层的序数(在时间线窗口中的顺序). 例如, thisComp.layer(3).Layer, Light, or Camera layer(“name”) {name是一个字串} 得到层名。指定的名字与层名匹配，或者在没有层名时与源名匹配。如果存在重名，After Effects 使用时间线窗口中的第一个. 例如, thisComp.layer(“Solid 1”).Layer, Light, or Camera layer(otherLayer, relIndex) {otherLayer 一 个层对象， relIndex 是一个数} 得到otherLayer (层名)上面或下面relIndex (数) 的一个层。 例如, layer(thisLayer, -2) 返回 在时间线窗口中比写这个表达式的层高两层的一个层。Number marker(markerNum) {markerNum 是一个数}得到合成中一个标记点的时间。你可以用它减淡标记点的透明，实现淡出。例如, markTime = thisComp.marker(1); linear(time, markTime - .5, markTime, 100, 0).Number numLayers 返回 合成中层的数量。Camera activeCamera 从在当前帧中着色合成所经过的摄象机获取值。这不一定是你在合成窗口所看到的。Number width 返回合成的宽度，单位为像素（pixels.）Number height 返回合成的高度，单位为像素（pixels.）Number duration 返回合成的持续时间值,单位为秒。Number frameDuration 返回画面的持续时间.Number shutterAngle 返回合成中快门角度的度数.Number shutterPhase 返回合成中快门相位的度数Array [4] bgColor 返回合成背景的颜色。Number pixelAspect 返回合成中用width/heigh表示的像素（pixel ）宽高比。String name 返回合成的名字。 脚本属性和方法（Footage）Number width 返回脚本的宽度，单位为像素。Number height返回脚本的高度，单位为像素。Number duration 返回脚本的持续长度，单位为秒。Number frameDuration 返回画面的持续长度，单位为秒。Number pixelAspect 返回脚本的像素比, 表示为 width/height.String name 返回脚本的名字。 层子对象属性和方法（Layer）Comp or Footage source 返回层的源 Comp 或源Footage 对象。默认时间是在这个源中调节的时间。例如, source.layer(1).position.Effect effect(name) {name是一个字串} 返回 Effect 对象。 After Effects 在效果控制窗口中用这个名字查找对应的效果。这个名字可以是默认名，也可以是用户自定义名。如果这里有一些相同的效果名则选择效果控制窗口中同名字的最上面的一个效果。Effect effect(index) {index 是一个数} 返回 Effect 对象。After Effects 在效果控制窗口中用这个序号查找对应的效果。起始于1 且从顶部开始。Mask mask(name) {name是一个字串} 返回层 Mask 对象。 这个名字可以是默认名，也可以是用户自定义名。Mask mask(index) {index 是一个数} 返回层 Mask 对象。After Effects 在时间线窗口中用这个序号查找对应的遮罩。起始于1 且从顶部开始。 层的一般属性和方法 属性 解释 Number width 返回以像素为单位的层宽度。 它与 source.width相同。 Number height 返回以像素为单位的层高度。 它与 source.height相同。 Number index 返回合成中层数。 Layer, Light, or Camera parent 返回层的父层对象, 例如, position[0] + parent.width. Boolean hasParent 如果有父层返回 true ,如果没有父层返回 false . Number inPoint 返回层的入点,单位为秒. Number outPoint 返回层的出点,单位为秒. Number startTime 返回层的开始时间,单位为秒. Boolean hasVideo 如果有视频(video)返回 true ,如果没有(video)返回 false. Boolean hasAudio 如果有音频(audio)返回 true ,如果没有音频(audio)返回 false. Boolean active 如果层的视频开关(眼睛 )打开返回 true ,如果层的视频开关(眼睛 )关闭返回 false. Boolean audioActive 如果层的音频开关(喇叭 )打开返回 true ,如果层的音频开关(喇叭 )关闭返回 false. Layer 特征属性和方法-——————————————————————————-Property [2 or 3] anchorPoint 返回层空间内层的锚点值.Property [2 or 3] position 如果该层没有父层,返回本层在世界空间的位置值;如果有父层,返回本层在父层空间的位置值 .Property [2 or 3] scale 返回层的缩放值,表示为百分数.Property rotation 返回层的旋转度数, 对于3D 层, 它 返回 z旋转度数.Property [1] opacity 返回层的透明值,表示为百分数.Property [2] audioLevels 返回层的音量属性值,单位为分贝.这是一个2维值;第一个值表示左声道的音量,第二个值表示右声道的音量.这个值不是源声音的幅度,而是音量属性关键帧的值.Property timeRemap 当时间重测图被激活时,返回重测图属性时间值,单位是秒.Marker Number marker.key(index) {index 是一个数} 返回层的标记数属性值. 可能用到的方法和属性只有key(), nearestKey和numKeys.Marker Number marker.key(“name”) {name是一个字串} 返回层中与指定名对应的标记号.这个名字是标记名, 它在标记对话框的注释区,例如, marker.key(“ch1”). 这个值对于 marker keys是一个字串, 不是数字.例如, m1 = marker.key(“Start”).time; m2 = marker.key(“End”).time; linear(time, m1, m2, 0, 100);Marker Number marker.nearestKey 返回最接近当前时间的标记.Number marker.numKeys 返回层中标记的总数.String name 返回层名. Layer 3D属性和方法-——————————————————————————-Property [3] orientation对3D层 ，返回3D 方向的度数。Property [1] rotationX 对3D层，返回 x旋转值的度数。Property [1] rotationY 对3D层，返回 Y 旋转值的度数。Property [1] rotationZ 对3D层，返回 Z 旋转值的度数。Property [1] lightTransmission 对3D层，返回光的传导属性值。Property castsShadows 如果层投射阴影返回 1.0 。Property acceptsShadows 如果层接受阴影返回 1.0 。Property acceptsLights 如果层接受灯光返回 1.0 。Property ambient 返回环境因素的百分数值。Property diffuse 返回慢射因素的百分数值。Property specular 返回镜面因素的百分数值。Property shininess 返回发光因素的百分数值。Property metal 返回才质因素的百分数值。 层空间转换方法-——————————————————————————-Array [2 or 3] toComp(point, t = time) {point 是一个数组[2 or 3], t 是一个数} 从层空间转换一个点到合成空间，例如, toComp(anchorPoint)。Array [2 or 3] fromComp(point, t=time) {point 是一个数组[2 or 3], t 是一个数}从合成空间转换一个点到层空间。得到的结果在 3D 层可能是一个非0值。例如 (2D layer), fromComp(thisComp.layer(2).position).Array [2 or 3] toWorld(point, t=time) {point 是一个数组[2 or 3], t 是一个数} 从层空间转换一个点到视点独立的世界空间。例如, toWorld.effect(“Bulge”)(“Bulge Center”).Array [2 or 3] fromWorld(point, t=time) {point 是一个数组[2 or 3], t 是一个数}从世界空间转换一个点到层空间。例如, fromWorld(thisComp.layer(2).position).Array [2 or 3] toCompVec(vec, t=time) {vec 是一个数组[2 or 3], t 是一个数} 从层空间转换一个向量到合成空间。例如, toCompVec([1, 0]).Array [2 or 3] fromCompVec(vec, t=time) {vec 是一个数组[2 or 3], and t 是一个数} 从合成空间转换一个向量到层空间例如 (2D layer), dir=sub(position, thisComp.layer(2).position); fromCompVec(dir).Array [2 or 3] toWorldVec(vec, t=time) {vec 是一个数组[2 or 3], t 是一个数} 从层空间转换一个向量到世界空间。例如, p1 = effect(“Eye Bulge 1”)(“Bulge Center”); p2 = effect(“Eye Bulge 2”)(“Bulge Center”); toWorld(sub(p1, p2)).Array [2 or 3] fromWorldVec(vec, t=time) {vec 是一个数组[2 or 3], t 是一个数}从世界空间转换一个向量到层空间。例如, fromWorld(thisComp.layer(2).position).Array [2] fromCompToSurface(point, t=time) {point 是一个数组[2 or 3], t 是一个数} 在合成空间中从激活的摄象机观察到的位置的层表面（Z值为0）定位一个点。这对于设置效果控制点有用。仅用于3D层。 摄象机属性和方法（Camera）-——————————————————————————-Property [3] pointOfInterest 返回在世界空间中摄象机兴趣的的值。Property zoom 返回摄象机的缩放值，单位为像素。Property depthOfField 如果摄象机景深打开返回 1，否则返回0。Property focusDistance 返回摄象机焦距值，单位为像素。Property aperture返回摄象机光圈值，单位为像素。Property blurLevel 返回摄象机的模糊水平的百分数。Boolean active (a) 如果摄象机的视频开关 打开， 返回 true ； (b) 当前时间在摄象机的出入点之间，（c）且它是时间线窗口中列出的第一个摄象机，若以上条件之一不满足，返回 false 。 灯光属性和方法（Light）-——————————————————————————-Property [3] pointOfInterest 在工作区 返回灯光兴趣点。Property intensity 返回灯光亮度的百分数。Property [4] color 返回灯光彩色值。Property coneAngle 返回灯光光锥角度的度数。Property coneFeather 返回灯光光锥的羽化百分数。Property shadowDarkness 返回灯光阴影暗值的百分数。Property shadowDiffusion 返回灯光阴影扩散的像素。Note: 灯光对象的大部分属性和方法与层对象相同, 除 source, effect, mask, width, height, anchorPoint, scale, opacity, audioLevels, timeRemap, 和所有的material 属性。 效果的属性和方法（Effect）-——————————————————————————-Boolean active 返回 a true value if the effect is turned on in both the 如果效果在时间线窗口和效果控制窗口都打开返回 true , 如果在以上任意一个窗口关闭，返回false。Property param(name) {name是一个字串} 返回 效果里面的属性。例如, .effect(“Bulge”)(“Bulge Height”)。效果点控制总是在层空间。Property param(index) {index 是一个数} 返回 效果里面的属性。例如, .effect(“Bulge”)(4) 返回 Bulge Height 属性。 效果点控制总是在层空间。 遮罩属性和方法（Mask）Property MaskOpacity 返回遮罩透明值的百分数。Property MaskFeather 返回遮罩羽化的像素值。Boolean invert 如果遮罩是反向的，返回 true ；否则返回 false。Property MaskExpansion 返回 遮罩的像素。String name 返回遮罩名。String name 返回效果名。 特征属性和方法（property）总集（待分类） Number or Array value 返回当前时间的属性值。 Number or Array valueAtTime(t) {t 是一个数} 返回指定时间（单位为秒）的属性值。 Number or Array velocity 返回当前时间的即时速率。对于空间属性，例如位置，它返回切向量值。结果与属性有相同的维度。 Number or Array velocityAtTime(t) {t 是一个数} 返回指定时间的即时速率。 Number speed 返回 1D量,正的速度值，等于 在默认时间属性的改变量。 这个元素仅用于空间属性。 Number speedAtTime(t) {t 是一个数} 返回在指定时间的空间速度。 Number or Array temporalWiggle(freq, amp, octaves=1, ampMult=.5, t=time) {freq, amp, octaves, ampMult, 和 t 是数} 取样摆动时的属性值。 Freq 计算每秒摆动的次数，用于计算属性的基本幅度单位，octaves 是加到一起的噪声的倍频数，ampMult 与 amp 相乘的倍数。 t 基于开始时间。 对于这个函数意味着取样的属性必须被激活，因为这个函数仅在取样期间改变属性值，而不是改变了对应的属性值。. 例如, scale.temporalWiggle(5, .2). Number or Array smooth(width=.2, samples=5, t=time) {width, samples, 和 t 是数} 应用一个箱形滤波器到指定时间的属性值，并且随着时间的变化使结果变得平滑。Width (秒) 是经过滤波器平均时间的范围。Samples 等于离散样本的平均间隔数 。通常, 你需要的采样（ samples）数是奇数。例如, position.smooth(.1, 5). Number or Array loopIn(type = &quot;cycle&quot;, numKeyframe = 0) 在层中从入点到第一个关键帧之间循环一个指定时间段的内容。被指定为循环内容的基本段，是从层的第一个关键帧向后到层的出点方向的某个关键帧间的内容。 numKeyframe是指定以第一个关键帧为起点设定循环基本内容的关键帧数目（计数不包括第一个关键帧）。例如, loopIn(“cycle”, 1)从层的入点开始到第一个关键帧结束循环第一个关键帧到第二个关键帧间的内容。循环的次数由入点到第一个关键帧间的时间和循环内容长度决定 。 Number or Array loopOut(type = &quot;cycle&quot;, num关键帧 = 0) 在层中从最后一个关键帧到层的出点之间循环一个指定时间段的内容。被指定为循环内容的基本段，是从层的最后关键帧向前到层的入点方向的某个关键帧间的内容。 numKeyframe是指定以最后一个关键帧为倒数起点设定循环基本内容的关键帧数目（计数不包括最后一个关键帧）。例如, loopOut(“cycle”, 1)从层的最后关键帧开始到出点结束循环最后一个关键帧到倒数第二个关键帧间的内容。循环的次数由最后关键帧到出点间的时间和循环内容长度决定 。 Number or Array loopInDuration(type = &quot;cycle&quot;, duration = 0) 在层中从入点到第一个关键帧之间循环一个指定时间段的内容。被指定为循环内容的基本段，是从层的第一个关键帧向后到层的出点方向duration秒的内容。 duration是指定以第一个关键帧为起点设定循环基本内容的时间秒数。例如, loopInDuration(“cycle”, 1) 从层的入点开始到第一个关键帧结束循环第一个关键帧以后1秒的内容。循环的次数由入点到第一个关键帧间的时间和循环内容长度决定 。 Number or Array loopOutDuration(type = &quot;cycle&quot;, duration = 0) 在层中从最后一个关键帧到层的出点之间循环一个指定时间段的内容。被指定为循环内容的基本段，是从层的最后关键帧向前到层的入点方向duration秒的内容。 duration是指定以最后一个关键帧为倒数起点设定循环基本内容的的时间秒数。如,loopOutDuration(“cycle”, 1) 从层的最后关键帧开始到出点结束循环最后一个关键帧到倒数倒数1秒时间的内容。循环的次数由最后关键帧到出点间的时间和循环内容长度决定 。 Key key(index) 用数字 返回 key对象。 例如, key(1) 返回第一个关键帧对象。 当访问 key 对象时能获得Time, Index, 和属性值。 例如, 下面的表达式给出了第3个位置关键帧处的位置值：position.key(3).value。下面的表达式，当将它写到设置透明属性动画的层时，将忽略在透明属性中设置的关键帧的值而仅用关键帧定位在什么时间层闪现。d = Math.abs(time - nearestKey(time).time); easeOut(d, 0, .1, 100, 0). Key key(markerName) 用这个名字 返回标记的 key 对象。仅用于标记属性。 Key nearestKey(time) 返回指定时间最近的关键帧对象。 Number numKeys 返回 在一个属性中 关键帧 的数目。 wiggle 抖动表达式{freq, amp, octaves, ampMult, 和 t 是数} 属性值随机摆动(wiggles) Number or Array wiggle(freq, amp, octaves=1, ampMult=.5, t=time) Freq：频率（num），计算每秒摆动的次数，用于计算属性的基本幅度单位 amp：振幅（num） octaves：原有振幅上再增加抖动（num） ampMult：频率倍频（ampMult=.5 .5 表示0.5） t：持续时间 （频率和振幅必填，其他选填） 例如wiggle(50,100)position.wiggle(7, 30, 3) 对图层进行的S（缩放属性）填写wiggle表达式时，想让X，Y同时进行放大和缩小，用以下语句 12s=wiggle(20,50);[s[0],s[0]] // 两个0值定义为X和Y的数值相等 关键帧属性和方法（Key）Number or Array value 返回关键帧的值。Number time 返回关键帧的时间。Number index 返回 关键帧的序号File菜单 新建 ← New ┗New Project → 新建项目 New Folder →新建文件夹 打开项目 ← Open Project打开最近项目 ← Open Recent Projects关闭 ← Close保存 ← Save另存为 ← Save As…保存副本 ← Save a Copy…恢复 ← Revert导入 ← Import ┗File… → 文件 Multiple Files… →多个文件 Placeholder… →输入占位符 Solid… →实色导入最近镜头 ← Import Recent Footage输出 ← Export查找 ← Find…再次查找 ← Find Next添加镜头到合成 ← Add Footage to Comp选定脚本建立合成 ← New Comp From Selection…整理镜头 ← Consolidate All Footage删除未用镜头 ← Remove Unused Footage简化项目 ← Reduce Project文件打包 ← Collect Files…浏览文件夹 ← Watch Folder…运行脚本 ← Run Script建立代理 ← Create Proxy┗Still… → 静态图片Movie… → 影片设置代理 ← Set Proxy┗File… → 文件None →无解释镜头 ← Interpret Footage┗Main… → 常规Proxy… → 代理Remember Interpretation →保存解释Apply Interpretation →应用解释替换镜头 ← Replace Footage┗File… → 文件Placeholder… → 占位符Solid.. → 实色重载镜头 ← Reload Footage显示所在文件夹 ← Reveal in Explorer项目设置 ← Project Settings…打印 ← Print…退出 ← ExitEdit菜单撤消 ← Undo Copy重复 ← Redo Copy历史记录 ← History剪切 ← Cut复制 ← Copy粘贴 ← Paste清楚 ← Clear副本 ← Duplicate分层图层 ← Split Layer抽出工作区域 ← Lift Work Area挤压工作区域 ← Extrace Work Area选择全部 ← Select All全部取消 ← Deselect All标签 ← Label清空 ← Pruge┗All → 全部Undo → 撤消Image Caches → 图象缓存Snapshot → 快照Video Memory → 视频内存编辑原稿 ← Edit Original模版 ← Templates┗Render Settings… → 渲染设置Output Module… → 输出模式预置 ← Preferences┗General… → 常规Previews… → 预演Display → 显示Import… → 输入Output → 输出Grids &amp; Guides… → 辅助线及网络Label Colors… → 标签颜色Label Defaults… → 标签设置Cache… → 缓存Video Preview… → 视频预演 Animation菜单添加关键帧 ← Add Keyframe冻结关键帧 ← Toggle Hold Keyframe关键帧插值 ← Keyframe Interpolation…关键帧速率 ← Keyframe Velcity…辅助关键帧 ← Keyframe Assistant┗Convert Audio to Keyframes → 转换音频为关键帧Convert Expression to Keyframes → 转换表达式为关键帧Easy Ease → 缓和曲线Easy Ease In → 缓和曲线进入Easy Ease Out → 缓和曲线离开Exponential Scale → 指数缩放RPF Camera Import → RPF摄象机导入Sequence Layers… → 图层排序Time-Reverse Keyframes → 反转关键帧文字动画 ← Animate Text┗Anchor Point → 轴心点Position → 位置Scale → 缩放Skew → 倾斜Rotation → 旋转Opacity → 不透明度All Transform → 所有变换Fill Color → 填充色Stroke Color → 描边色Stroke Width → 描边宽度Tracking → 追踪Line Anchor → 线形频谱Line Spacing → 线形间距Character Offset → 字符位移Character Value → 字符值率添加文字选择器 ← Add Text Selector┗Range → 平行Wiggly → 抖动移除所有文字动画 ← Remove All Text Animators添加表达式 ← Add Expression追踪运动 ← Track Motion稳定运动 ← Stabilize Motion追踪当前属性 ← Track this property显示关键帧 ← Reveal Animating Properties显示被修改属性 ← Reveal Modified Properties LOFTER：阿卡 http://chenfangka.lofter.com/post/1d6c55be_834d984]]></content>
      <categories>
        <category>设计</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化echarts的学习使用归纳总结（持续更新）]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96echarts%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 配置手册：https://www.echartsjs.com/option.html#title 官方实例demo：https://www.echartsjs.com/examples/ 在线定制：https://echarts.baidu.com/builder.html 引入echarts 在Vue中使用echarts的两种方式 ​ 使用vue-echarts 引入方式：https://github.com/ecomfe/vue-echarts/blob/HEAD/README.zh_CN.md 起步安装 1npm install echarts vue-echarts 在 main.js 中引入并注册 12import ECharts from 'vue-echarts/components/ECharts.vue'Vue.component('v-chart', ECharts) 在组件中调用注册和引入1234567891011121314&lt;template&gt; &lt;v-chart :options="echartsOption"/&gt;&lt;/template&gt;&lt;script&gt;// ⭐必须引入相关的所有组件！包括legend,dataZoom这类，否则不生效import 'echarts/lib/chart/line'import 'echarts/lib/component/polar'export default &#123; data () &#123; echartsOption: &#123;&#125;&#125;&lt;/script&gt; 设置option建议将具体的option写在方法里 比如： 12345678910111213141516setoption() &#123; let option = &#123; xAxis: &#123; type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] &#125;, yAxis: &#123; type: 'value' &#125;, series: [&#123; data: [820, 932, 901, 934, 1290, 1330, 1320], type: 'line' &#125;] &#125;; this.echartsOption = option&#125;, 然后在异步数据获取了之后，再调用该方法 1234async getData() &#123; // .... await this.setOption()&#125; 样式修改12345678910&lt;style&gt;/** * 默认尺寸为 600px×400px，如果想让图表响应尺寸变化，可以像下面这样 * 把尺寸设为百分比值（同时请记得为容器设置尺寸）。 */.echarts &#123; width: 100%; height: 100%;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目构建技巧（持续更新）]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%89%8D%E7%AB%AF%2F%E6%80%A7%E8%83%BD%E5%92%8C%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%2FVue%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… vue-cli2.0vue:不同环境配置不同打包命令]]></content>
      <categories>
        <category>前端</category>
        <category>性能和构建部署</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F09%2F%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%2FAI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… AI简介应用范围1、标志设计及VI设计 2、绘制ICON图标及图标外形 3、做印刷时，印刷品中含有大量文字需要排版时，要在ai中进行文字编排并最终进行输出 4、广告画面中具有艺术性的文字字体设计 设置工具栏填色和描边 内部的颜色为填色 边框的颜色为描边 D键 ：恢复到黑白色 X键 ：填色与描边位置的切换 SHIFT+X ：填色与描边颜色的切换 文字工具 T ctrl+T：字符面板 CTRL+SHIFT+O：锁定字体，将字体转化为路径 图形工具组多边形工具绘制时可以通过按方向键的上下键来调整边数。 当边数为3时，是三角形，当边数为100时，是圆形。 星形工具绘制时可以通过按方向键的上下键来调整角点数。 当角点数为3时，是三角形，角点数为5时，是五角星。 在空白处单击，可以选择更改半径，来调整星形的形状 圆角矩形工具 画的时候按 ↑ ↓ 键可以调节圆角的大小年 画的时候按← → 键可以直接调节圆角的最小值和最大值 旋转和镜像旋转工具R如何进行精确旋转？ 双击旋转工具可调出旋转对话框，可以精确旋转 选择旋转工具，按下ALT键单击空白处定义中心，并弹出旋转对话框 旋转的时候按住alt键可以进行复制 镜像工具O双击镜像工具可调出镜像对话框，可以精确镜像 选择镜像工具，按下ALT键单击空白处定义中心，并弹出镜像对话框 垂直轴镜像相当于水平翻转 水平轴镜像相当于垂直翻转 临时]]></content>
      <categories>
        <category>设计</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ID学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F05%2F%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%2FID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 快捷键 CTRL+SHIF+P：新建页面 CTRL+ALT+P：文档设置（可以取消跨页和设置页面长宽） 左侧工具右侧工具在 顶栏工具栏-窗口 选项中可以自定义添加右侧工具 页面 F12按住 shift 键可以多选 移动页面点选要移动的页面（高亮页面），保持按下鼠标状态拖动高亮页面，这时鼠标变成手拿页面的图标，拖动鼠标到要插入页面的后面，这时会出现一个竖线，此刻放开鼠标，页面就顺利移动过来了。 复制页面学会上一步很重要，复制页面就是在移动页面的基础上，同时按着 alt键 即可，将页面插入到你想要的页面后，松开鼠标就好。 图层 F7样式为什么要设置段落样式 (字符样式） 我们在排一本书或杂志的时候，因为文字内容有主次，有各种层次，比如有标题、内文、有页眉、页码等等，这些文字一定都有各自的特点，有各自所使用的字体、大小、行间距等等。 当我们在最初设定好了这些数值，那么在整本书的排版过程中，我们就可以直接点击（字符样式）段落样式中已经设定好的模式，而不需要每次都重新设定各种值，其实也类似于word当中的“格式”功能。 而且在正式排版之前设定好段落样式还有这样的好处： 如果你在设计的过程中，想要统一改变某一种文字的属性 例如，一开始设定内文字体是9号字，但是后来觉得应该再大一点，想改成10号，那么你只需要到“段落样式”中去改变你设定好的内文样式，整本书的内文就全部自动做了更改，而不需要你一段一段去更改。这样就省事很多 事先设定好“段落样式”，最终你就可以轻易的自动生成目录了，目录就是根据段落样式来生成的，如果你只设定了‘字符样式’就不能实现这个功能。 具体操作： 选定一段文字，在“字符”中设定好字体、大小、行距等等选项，同时也要设定好文字的色彩。 设置“段落”窗口中的各种属性。 当你的光标停留在这段文字中的时候，点击右边“段落样式”，然后点击下面垃圾筒左边的“创建新样式”按钮，它会自动出现一个“段落样式1”，双击它可以改变它的名字，设定一个你自己容易识别的名字，如“英文正文”。 那么以后所有英文正文的文字，你只需要点一下这个段落样式就完成了所有属性的设定了。 字符样式 Shift+F11段落样式 F11对象和版面对齐 Shift+F7实际操作插入图片在InDesign中置入图片的方式跟PS大致相同，但因为InDesign中有“框架系统”的存在，所以初次置入图片时，你也许也会像我一样觉得有些奇怪，“我的图片为啥不听话呢”，下面就让我们来熟悉一下图片的“框架”。 直接置入图片 直接从文件夹中将图片拖入打开的InDesign窗口，如果你发现拖入后图片没有马上出现，则回到InDesign里，发现鼠标有个放置图片的指示，你再点击画布任意位置即可。 编辑图片：置入图片后，发现图片很大，但因为有“框架”的存在，我们并不能直接拖动来缩放图片，而需要用缩放工具（S），然后点左上角点为缩放点，然后拖动右下角，进行缩放。 置入图片到框架在InDesign左侧的工具栏中，铅笔工具下方就是框架工具，你可以选择用它建立框架，或者选择下方的矩形工具，也可以实现一样的作用，下面我们来看详细步骤。 用框架工具或矩形工具在画布上你想让图片置入的位置画一个框架。（有时候暂时不用放图，只需要占位时，我会选择用矩形工具画，因为用框架工具画出来的是透明的框框） 从文件夹拖入图片到框架内。这时候图片在框架内还是很大，你可以用缩放工具，或者使用这个最最便捷的方法——右键-适合-按比例填充框架。快捷键是三个常用热键 Ctrl+Shift+Alt+C，我发现这个功能真的好酷！ 如果想要拖动框架中的图片，点击中心原点变成黄色 如果想要拖动整体框架，点击外侧变成蓝色 对齐图片顶栏工具栏-窗口-对象和版面-对齐（Shift+F7）调出对齐工具。 InDesign里的对齐方式跟AI是一样的，特别方便 选中一张图片=&gt;按住Shift加选一张图片（我觉得可以直接鼠标框选中两张图） 再用鼠标左键单击两张图片中的一张，此时该图片边框会加粗，表示该图片已被锁定，执行对齐时它不会动。 主页功能InDesign的“主页”相当于PPT里面的“母版”，我们设计的书、杂志、画册等，大多数情况，版式上总是有共同的部分，比如杂志里面一个栏目有共同的栏头、装饰等。在InDesign中，我们不需要在每个页面都制作或者复制之前的版式版头等共同部分，这些可以直接在主页里完成。 在一个文档中，我们可以做多个主页，可以将这些主页应用在不同的页面上。 “页面”面板的上方是主页，下方是跨页（页面），在主页区域单击右键可以进行新建主页等相关操作。 新建主页 在主页窗口右击鼠标 点击“新建主页”，在弹出窗口中可以更改主页名字（默认的前缀是A/B/C/D…这个前缀会在页面的缩小视图的左右上角显示。我们就可以清楚的看到哪些页面应用的是哪个主页）及设置主页页数。 将主页应用于页面因为我们只做了一个主页，所以所有页面就默认为A主页的形式了，如果我们设置了多个主页，也可以在页面视图上对指定的页面套用不同的主页样式。 我们只要在页面视图的小缩略图上选定所需要的页面(按shift可以加选)，之后右击鼠标，出现下拉菜单，我们执行“将主页应用于页面”就可以了，下拉菜单如下图 点击了“将主页应用于页面”后，在弹出框中可以选择要应用的主页，以及应用在哪些页面上。 删除主页当我们不需求某个主页的时候，可以点击选择该主页（按shift可加选），右键-点击“删除主页跨页”，用来删除当前主页。 如果没有这个选项，可以将第二个应用没有样式的主页 [无] 如何在页面中更改主页主页类似于母版，在页面中应用后是不能随便编辑的，但我们可以放大招，把我们想编辑的元素从母版中解放出来——在页面上，按住Shift+Ctrl键不松开，同时鼠标按下左键点击你要编辑的元素，你会发现，这部分元素就可以点选了。对！就是这么神奇 具体用例：（显示页码） 注：如果主页已经设定好页码，在页面中排图的时候可能会用到整张大图，页码就被压住看不到。在放入大图后，在图层面板里先隐藏它，然后就用上面的大招，点选页码，然后直接Ctrl+Shift+]把页码调整到最上面一层，页码就顺利露出来了，最后别忘了取消隐藏大图。 总结最后再强调一下主页真的很重要、很重要、很重要： 主页是模板性质的，固定的页眉、页脚、固定的装饰边框图案等都可以设定在主页中，如果是可能会改动文字的标题等就放在页面中去做吧。尝试在设计的最初就做好主页的设置，这样真的可以事半功倍，比如已经排版好的大几百页的书籍，有设计的细节改动，或者页眉的文字改变了，那么你只要在主页上做修改，所有页面就自动同步啦，如果你没有用主页，那你将面临的就是漫长地一页一页的修改和长长的悔恨。 插入页码一般情况，我们都是在主页里添加页码，这样所有页面的页码会自动按顺序排列，即使排版的过程中，你有任何增加删除页面，页码都是自动更新的，很方便。下面我就来手把手教会你设置页码。 【步骤1】双击主页缩略图，来到主页页面，找到你想要页码放置的位置，再用文字工具拉一个文字框，输入页码，设置好页码的字体、字号、颜色等。 【步骤2】插入页码：顶栏工具栏-文字-插入特殊字符-标志符-当前页码，快捷键Ctrl+Shift+Alt+N。此时你会发现主页中的页码变成了字母，稳住，不要害怕！ 【步骤3】应用主页：回到页面中去，执行“将主页应用于页面”（前面有提到过具体操作哦，别忘啦）。到这一步其实页码已经设置成功啦，不过你还可以有更多的样式选择，请见步骤4. 【步骤4】顶栏工具栏-版面-页码和章节页选项，这里可以设定更多页码的细节，比如页码起始页、或者想要在页码前增加章节信息，设置页码样式等。 Tip：还需要注意一个小细节，通常我们的页码都分别在页面的左右两边，左侧的页码文字最好采取左对齐，右侧的则采取右对齐，这样页码随着数字的变换依然能够和书页边缘保持等距，增加了整齐感。 导出印刷文件设计完画册之后，当然就是导出来看看整体效果了，InDesign里面特别贴心的设计是导出时可以选择： PDF打印（是单独一页的便于打印） PDF交互（跟InDesign界面里面的排版一致，是最佳的预览效果）。 如果需要打印下来看效果，就导出为打印；如果是给客户看最终效果，就导出为交互。 客户定稿后，我们就需要将文件交付给印刷厂了，交付之前我们还需要做一些印前检查。 顶栏工具栏-窗口-输出-印前检查：这里可以显示错误，一般会显示是否有文字溢出和颜色模式的错误。双击就可以跳到错误处。 1、检查文字： ①文字是否转曲（这又是一个知识点了，我帮大家百度了一下有没有一键转曲的快捷方法：https://jingyan.baidu.com/article/4dc4084881e8bdc8d946f1f9.html） ②黑色文字是否叠印（相当于PS里面的正片叠底功能，关于叠印：https://helpx.adobe.com/cn/indesign/using/overprinting.html） 2、检查图片： ①检查链接文件：因为InDesign里的图片默认是已外链的方式存在，如果你电脑里的图片不在原来的位置链接就会缺失，有两个方法解决这个问题——其一，在链接面板嵌入图片；其二，打包：文件-打包。默认打包设置即可，默认情况下是字体也都能打包的，但有些字体涉及版权问题，打包不了，需要到系统font文件夹手动复制出来。 ②检查图片的颜色模式（是否为CMKY，以及有无专色） ③检查图片精度，是否清晰 ④检查图片格式 3、其他检查 可能还需要检查陷印预设什么的，太专业啦，还是跟印刷厂确认吧，哈哈哈。 项目比较赶，我在一个星期完成了画册的设计，下班回家的零碎时间用来整理了这个教程，感觉InDesign比PS还好操作一些，高效又科学，希望在大家设计明年的毕业纪念册时，能对你们有所帮助！快快开始学习InDesign吧~~~ 实用小技巧文字相关使文本框大小根据内容重新调整将鼠标移到文本框的右下角，当鼠标箭头变成双箭头的时候（放大缩写的那个箭头），双击 参考文章： https://www.ui.cn/detail/298486.html]]></content>
      <categories>
        <category>设计</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI设计-按钮规范和参考]]></title>
    <url>%2F2019%2F07%2F01%2F%E8%AE%BE%E8%AE%A1%2FUI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2FUI%E8%AE%BE%E8%AE%A1-%E6%8C%89%E9%92%AE%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[🐰… 案例参考后台系统按钮 按钮是后台产品进行交互设计是重要元素，提供给用户进行点击操作，是视觉上最引人注目的控件，具有一定的视觉受范性。常用按钮可分为填充按钮、线性按钮、文字按钮。 按钮的交互状态包括默认、悬停、点击和不可用。 按钮根据需求分为不同尺寸，大中小三个级别用在不同的场景，一般按照8的倍数设定。如高度分别设定为24、32、40px。 规范整理时要规定不同类型按钮的宽高、圆角及文字大小，同时还要将按钮的不同状态展现出来。 填充按钮之间间距最小为10px。 参考文章： https://www.ui.cn/detail/422106.html]]></content>
      <categories>
        <category>设计</category>
        <category>UI设计规范和参考</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI设计-字体规范和参考]]></title>
    <url>%2F2019%2F07%2F01%2F%E8%AE%BE%E8%AE%A1%2FUI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2FUI%E8%AE%BE%E8%AE%A1-%E5%AD%97%E4%BD%93%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[🐰… 案例参考后台系统标准字 后台系统常用的字体：windows系统，中文Microsoft YaHei，英文Arial；Mac字体，中文PingFang SC，英文Helvetica；除此之外可以选择的字体还有segoe UI、思源黑体、Hiragino Sans GB等。 后台系统中常用字体大小为12px、13px、14px、16px、18px、20px、24px、30px。 行高设定，根据文字大小及使用场景设置行高，一般行高=文字大小+6px/8px。 参考文章： https://www.ui.cn/detail/422106.html]]></content>
      <categories>
        <category>设计</category>
        <category>UI设计规范和参考</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI设计-表单规范和参考]]></title>
    <url>%2F2019%2F07%2F01%2F%E8%AE%BE%E8%AE%A1%2FUI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2FUI%E8%AE%BE%E8%AE%A1-%E8%A1%A8%E5%8D%95%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[🐰… 案例参考后台系统表单 表单多由一条或多条列表项组成，单一列表项的类型有字段输入框、条件选择器。 字段输入框的标题和输入框分布方式包括左右、上下、无标题。左右分布是常见的对齐方式，比较适合PC端的使用；上下分布增加了表单的整体高度，视情况选择使用；无标题经常应用在登录注册，虽然减少了面积，但是增加了理解难度。 输入框的交互状态包括默认、输入结果、提示错误、禁用、获取焦点。 输入框的尺寸可按照8的倍数进行设定，比如24px、32px，也可根据系统实际情况进行设定，我常用的输入框高度为30px，宽度视情况而定，无圆角。上下布局的多个输入框上下间距为20px，有错误提示时候竖向增加10px或横向显示在输入框右侧（预留出位置）。 表单中标题文字左对齐，输入框左对齐，标题文字距离输入框20px（多个长度不同的输入框算最长的）；标题文字右对齐，输入框左对齐，也是常用的方式。输入框内正文字体14px，文字和左右两边边框的边距10px。 选择器包括单选、多选、时间选择、开关切换、下拉选择、滑块选择、旋钮等。单选框多为圆形，复选框多为方形。 搜索框和选择框的高度为30px或按照8的倍数自行设定，通常和输入框保持一致。搜索框距离右侧按钮4px，内部文字14px。 单选多选框尺寸16*16px，多个选项横向排列间距16px，纵向排列间距8px。 开关按钮外框4020px，内部圆形1616px。 参考文章： https://www.ui.cn/detail/422106.html]]></content>
      <categories>
        <category>设计</category>
        <category>UI设计规范和参考</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS学习笔记（持续更新）]]></title>
    <url>%2F2019%2F06%2F19%2F%E8%AE%BE%E8%AE%A1%2F%E8%BD%AF%E4%BB%B6%2FPS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 快捷键 SHIFT + 工具本身的快捷键 ：可以切换选中的工具 CTRL+k : 首选项 TAB 键：隐藏或显示工具箱，属性栏，控制面板 SHIFT+TAB 键：只隐藏控制面板 图层 CTRL+J ：复制图层 CTRL+SHIFT+N：新建图层（需要自定义命名） CTRL+SHIFT+ALT+N：新建图层（默认命名） 工具前背景色 前景色填充：ALT+DELETE 背景色填充：CTRL+DELETE 按 D键 ：恢复到默认的黑白色 按 X键 ：前背景色的切换 图层新建图层：CTRL+ALT+SHIFT+N 图层编组：CTRL+G 自由变换 ctrl+t 按下 SHIFT 键，保持比例不变 按下 ALT 键，保持中心不变 调整四个角点可以调整整体比例，调整四个边点可以调整宽度和高度 按下 CTRL 键，可以调整具体的点，对图像进行变换 矩形选框 M 按 SHIFT 键可以强制为正方形（正圆） 按 ALT 键可以保持中心点不变 同时按下 SHIFT+ALT 键，可保持中心不变强制为正方形（正圆） 选区绘制的形状与形状工具绘制的形状的区别 选区绘制的属于位图：需要新建图层，放大会失真 形状工具绘制的属于矢量图：不需要新建图层，放大不会失真 选区的修改 边界：会得到有一定宽度的环形区域，会有羽化效果 平滑：把直角选区变成圆角选区 扩展：均匀的扩大选区 收缩：均匀的缩小选区 羽化：让边缘变得柔和，半透明 SHIFT + F6 选区的布尔运算选区的布尔运算：加选区，减选区，与选区相交 + 加运算：SHIFT键，在选区中加上更多的区域 - 减运算：ALT键，在选区中减去一部分区域 X 相交运算：SHIFT+ALT键，保留公共的（重叠的）区域 反选：CTRL+SHIFT+I 移动工具 V功能：移动对象 复制：按下 ALT 键用移动工具进行拖拽 移动选区和移动内容的区别： 移动选区：绘制选区后，用矩形选框工具指在选区内，会出现白色箭头，可以移动选区。 （属性栏中必须选中的新选区） 移动内容：绘制选区后，用移动工具指在选区内，会出现黑色箭头，可以移动选区内的内容。 套索工具 L 套索工具：按住鼠标拖拽形成一个封闭的选区。特点：灵活，不准确 多边形套索：点击定义一个起点，再次点击确定一条线，反复点击，绘制一个封闭的选区。特点：边缘呈直线的，不太准确。 磁性套索：点一个起点，把鼠标顺着抠选对象边缘滑动，会自动捕捉。特点：通过抠选对象颜色与背景颜色的差异来选择，很准确。 属性： 频率值越大，节点越密集（一般采用默认值，太密集精确度提升，但是边缘也会不圆滑） （按 delete 或者 ← 键可以删除节点） 魔棒工具组 W魔棒工具特点：选择颜色相近的部分。 容差：可选颜色的范围，容差越大，可选范围越大。默认值是32 快速选择工具W特点：也是根据颜色的相似程度来选择对象 笔触：笔尖大小，笔触越大表示作用范围越大，笔触越小范围越小 “[” 表示缩小笔触， ”]” 表示放大笔触 去边处理图层菜单——修边——去边：可以把图像最外边的白边直接去除。（1PX） 这样可以剪去抠图的边缘的白线或者模糊边缘 渐变工具 G注意事项：再做透明渐变时，如果渐变不够理想，需要先撤销，再重新制作渐变，不能直接堆叠在原渐变之上 球体表现 1，新建图层，绘制圆形选区 2，选择渐变工具，单击颜色条调出渐变编辑器 3，第一个色标设置为白色（高光），第二个色标设置为黑色，第三个颜色比黑色浅一些（如上图） 4，用渐变工具选择径向渐变拖拽，得到球体 5，把前景色改为黑色，选择渐变类型为前景色到透明的渐变 6，选择径向渐变拖拽得到投影，自由变换调整投影的大小和形状，放在下一层。 锁定透明像素：锁定透明像素后，填充颜色时只针对有内容的区域，如果没有锁定，填充针对整个图层。 钢笔 P路径路径的组成：锚点，路径线，控制手柄（控制线） “ 直线路径的绘制：选择属性栏中的“路径”，点击确定第一个锚点（起点），再单击确定另一个点，一段路径线被确定，再次单击——单击，直到闭合。 曲线路径的绘制：选择属性栏的“路径”，点击确定第一个锚点，再次单击并拖拽，通过调整控制手柄来调整曲线的弧度，再次单击并拖拽，直到闭合。 路径转换成选区：CTRL+回车 路径的存储： 双击“工作路径”可以对路径进行保存。 支持路径存储的格式：PSD,JPG 去除路径的黑线： 在“工作路径”中单击路径，然后点击面板的空白处 黑白箭头 A路径选择工具（小黑）：选中和编辑整个路径 直接选择工具（小白）：编辑局部锚点的 排除重叠形状： 当抠选需要镂空的图时，需要做两条路径，用小黑工具选中两条路径，修改运算方式为——排除重叠形状，再转换为选区。 钢笔抠图技巧 选锚点时，选在图像边缘靠里1~2PX. 定点原则，在C型上选点 选错后，用CTRL+ALT+Z撤销，不用DELETE 出现上下乱窜时，放弃这步操作，撤销，重新再调整 确定一段曲线之后，按ALT键点击锚点，去除前端的控制手柄 画笔工具 B注意： 出现十字光标时：有可能是大小写切换键打开了，有可能是画笔笔触太大。 画笔面板 F5 画笔笔尖形状：画笔样式，大小，间距 形状动态：大小抖动，角度抖动 散布：散布，数量 颜色动态：前景到背景抖动，色相抖动 传递：不透明度的抖动 画笔描边路径 用画笔样式描边路径得到非常绚丽的效果 绘制一条路径（可以选择钢笔或者图案来绘制路径） 选择画笔工具，预设画笔的样式 在画笔面板点击画笔描边路径，得到效果 自定义画笔 下面以制作一个泡泡画笔为例 新建文档100*100PX,把背景色改成透明 画一个圆形的选区，填充黑色 用白色画笔点击并涂抹，用黑色画笔在边缘拖拽几个色块 在编辑菜单，选择定义画笔预设，命名 选择画笔工具，选择最后一个画笔样式，把前景色改为白色。 文档操作新建文档 基于互联网设计（屏幕显示）：单位：像素，分辨率：72，颜色模式：RGB 基于印刷设计时：单位：毫米MM，分辨率：300，颜色模式：CMYK 保存和打开 保存：CTRL+S 可以把内容存储起来 另存为：CTRL+SHIFT+S ，把文件重新保存一份 默认的格式：PSD（源文件格式） 打开的方式：CTRL+O 把文档拖拽至软件中也可以打开 图像制作图像合成 合成：把各种图像的部分元素抠选出来，放在一个画布中，形成一个新的画面。 抠图：把图像中某一个元素抠选出来保留，其它部分删除。 透底图制作：做选区把保留内容选中，然后反选，把背景图层解锁，然后删除背景，保存PSD格式。 实用小技巧更改某个图层的颜色 锁定该图层的 透明像素，然后再进行颜色填充 锁定透明像素：锁定透明像素后，填充颜色时只针对有内容的区域，如果没有锁定，填充针对整个图层 小案例banner安全尺寸：主要内容做在950PX以内 图像——画布大小，可以改画布大小 ctrl+alt+c 标尺：CTRL+R 参考线绘制参考线：把鼠标放在标尺上，往外拖拽就能得到参考线 删除参考线：选中参考线，把它拖拽出绘图区域 自定义图案1，新建10*10PX的文档，改成透明 2，绘制一个黑色的1PX的矩形块，复制10个按对角线分布 3，在编辑菜单中定义图案并命名 4，在编辑菜单中选择填充——图案——自定义图案——最后一个 阴影突出中心将画笔大小调大，然后取比背景色深的颜色用画笔边缘在四周涂抹，可以制造阴影效果，突出中心]]></content>
      <categories>
        <category>设计</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI设计-间距使用总结]]></title>
    <url>%2F2019%2F06%2F19%2F%E8%AE%BE%E8%AE%A1%2FUI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%92%8C%E5%8F%82%E8%80%83%2FUI%E8%AE%BE%E8%AE%A1-%E9%97%B4%E8%B7%9D%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[🐰…]]></content>
      <categories>
        <category>设计</category>
        <category>UI设计规范和参考</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中的单位及其应用技巧]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2FCSS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BD%8D%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[🐰… css单位：https://www.html.cn/book/css/values/index.htm 文本相对长度单位视口相对长度单位绝对长度单位]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS相关面试题知识点总结（持续更新）]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%8D%E7%AB%AF%2F%E9%9D%A2%E8%AF%95%2FCSS%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 未分类说下几种常用选择器五大类选择器： 基本选择器 元素选择（直接获取元素名 P、h1）【过于直接】 ID选择（#id）【取值唯一不能复用】 类选择（.class）【组合、复用】 * 通用选择器(所有元素) 关系选择器 伪类选择器 :nth-child(n) ： n可以是数字(4)、关键词(old,even)或公式(2n+1) :active: 将样式添加到被激活的元素 :focus: 将样式添加到被选中的元素 :hover: 鼠标悬浮在元素上时 添加样式 ​:link:​ 添加到未被访问过的链接 :visited 添加到被访问过的链接 :first-child: 添加到元素的第一个子元素 :lang： 定义使用的语言 伪元素选择器 :first-letter : 添加到文本的首字母 :first-line : 添加到文本的首行 :before : 某元素之前插入某些内容 :after : 某元素之后插入某些内容 属性选择器 布局flex布局设为 flex属性后，子元素的哪些属性会失效？float、clear 和 vertical-align 移动端响应式移动端开发 rem 布局的原理（rem 单位换算）使用rem布局，实质都是根据设备屏幕通过动态改写html的font-size基准值，来实现不同设备下的良好统一适配]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型和原型链详解]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJS%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[🐰… 普通对象和函数对象 Object 、Function 是 JS 自带的函数对象。 123456789101112131415161718var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function('str','console.log(str)');console.log(typeof Object); //function 因为Object本身为构造函数，new出来的才是对象console.log(typeof Function); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //objectconsole.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function 如何区分普通对象（object）和函数对象（function）？ 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。 注意： Function Object 也都是通过 New Function()创建的。 普通对象123最普通的对象：有__proto__属性（指向其原型链），没有prototype属性。原型对象(Person.prototype 原型对象还有constructor属性（指向构造函数对象）) 函数对象123凡是通过new Function()创建的都是函数对象。拥有__proto__、prototype属性（指向原型对象）。 构造函数我们先复习一下构造函数的知识： 12345678function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name) &#125; &#125;var person1 = new Person('Zaxlct', 28, 'Software Engineer');var person2 = new Person('Mick', 23, 'Doctor'); 上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即： 12console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //true 我们要记住两个概念（构造函数，实例）： person1 和 person2 都是 构造函数 Person 的实例 一个公式： 实例的构造函数属性（constructor）指向构造函数。 结合原型概念理解拥有了描述事物的能力，却没有创造事物的能力，显然是不完整的，因此需要一个Object的生成器来进行对象的生成。 JS将生成器以构造函数constructor来表示，构造函数是一个指针，指向了一个函数。 函数（function） 函数是指一段在一起的、可以做某一件事的程序。 构造函数是一种创建对象时使用的特殊函数。 对象的构造函数function Object同时也是一个对象，因此需要一个能够描述该对象的原型，该原型便是Function.prototype，函数的原型用来描述所有的函数。对象的构造函数的proto指向该原型。 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数 原型对象在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。 其中每个函数对象都有一个 prototype 属性，这个属性相当于一个指针，指向他本身的原型对象，这个原型对象里包含着自定义的方法属性 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = 'Zaxlct';Person.prototype.age = 28;Person.prototype.job = 'Software Engineer';Person.prototype.sayName = function() &#123; alert(this.name);&#125; var person1 = new Person();person1.sayName(); // 'Zaxlct'var person2 = new Person();person2.sayName(); // 'Zaxlct'console.log(person1.sayName == person2.sayName); //true 我们得到了本文第「定律」： 1.每个对象都具有一个名为 __proto__ 的属性； 2.每个构造函数（构造函数标准为大写开头，如Function()，Object()等等JS中自带的构造函数，以及自己创建的）都具有一个名为 prototype 的方法（注意：既然是方法，那么就是一个对象（JS中函数同样是对象），所以 prototype 同样带有 __proto__ 属性）； 3.每个对象的 __proto__ 属性指向自身构造函数的 prototype ； 4.每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性 prototype和__proto__的区别 _proto_ 是对象的属性、prototype 是函数的属性 123456789函数.__proto__ ===Function.prototypeFunction.__proto__ === Function.prototypeObject.__proto__ === Function.prototype //Objec也是个函数，函数都是由Function构造出来的。Number.__proto__ === Function.prototype构造函数.prototype.__proto__ ===Object.prototypeFunction.prototype.__proto__ ===Object.prototypeNumber.prototype.__proto__ ===Object.prototypeObject.__proto__ .__proto__ ===null _proto_属性指向谁？ 12345678910111213141516171819/*1、字面量方式*/var a = &#123;&#125;;console.log(a.__proto__); //Object &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //true/*2、构造器方式*/var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //true/*3、Object.create()方式*/var a1 = &#123;a:1&#125;var a2 = Object.create(a1);console.log(a2.__proto__); //Object &#123;a: 1&#125;console.log(a.__proto__ === a.constructor.prototype); //false（此处即为图1中的例外情况） 总结： 大部分时候，_proto_ 指向构造器的原型 即： _proto_ === constructor.prototype 每个对象的 __proto__ 只会指向它的构造函数的 prototype 对象，Object.__proto__ 除外，它指向 null。 隐式原型和显式原型 显式原型（explicit prototype property ）每一个函数在创建之后都会拥有一个名为 prototype 的属性，这个属性指向函数的原型对象。用来实现基于原型的继承与属性的共享。 隐式原型 （implicit prototype link） JS中任意对象都有一个内置属性 _proto_（部分浏览器为[[prototype]] ），指向创建这个对象的函数（即构造函数）constructor的prototype。用来构成原型链，同样用于实现基于原型的继承。 Function.prototype 每创建一个函数都会有一个prototype属性，这个属性是一个指针，指向一个对象（通过该构造函数创建实例对象的原型对象）。 原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。 原型对象属于普通对象。Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。 Function.prototype === Function._proto_ Function.prototype 是函数，其他所有prototype 都是对象 Function.prototype函数没有prototype （Function.prototype.prototype === undefined），其他函数都有prototype 原型的原型 构造函数.prototype 也是对象啊，它指向谁？ 既然是对象，那么里面就有 __proto__ 属性 1Person.prototype.__proto__ === ??? 问号填什么呢，原型是由谁构造的呢，我们想到了所有对象的根———-Object 在控制台验证如下 123456Person.prototype.__proto__ === Object.prototypetrueArray.prototype.__proto__ === Object.prototypetrueString.prototype.__proto__ === Object.prototypetrue 既然引出了Object，我们来看一下所有对象的祖宗的原型吧 12Object.prototype.__proto__ === nulltrue 特殊的Function前面我们看到了Function构造方法构造除了所有的函数，包括普通的构造函数。 那么他自身也是一个函数，所以也是由Function构造函数构造的。所以由总结的公式可以知道 1Function.__proto__ === Function.prototype 而且，下面这个很重要，易错 1Function.prototype === Object.__proto__ //哈哈，这个老别扭了吧，还给你倒过来写，很容易错的 解释：Object也是构造函数啊，属于对象。Object构造函数也是由Function把它构造出来的，所以是结果是true 总结 当你new一个构造函数的时候，创建一个函数实例，那么 『 函数实例.__proto__ === 该构造函数.prototype』 所有的函数都是由Function构造出来的，那么 『被构造出来的其他函数.__proto__ === Function.prototype』 所有的构造函数的原型对象都是由Object构造出来的，那么 『所有的构造函数.prototype.__proto__ === Object.prototype』 原型链JavaScript对象是动态的属性“包”（指其自己的属性）。JavaScript对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 当我们「读取」 obj.toString 时，JS 引擎会做下面的事情： 看看 obj 对象本身有没有 toString 属性。没有就走到下一步。 看看 obj.proto 对象有没有 toString 属性，发现 obj.proto 有 toString 属性，于是找到了 如果 obj.proto 没有，那么浏览器会继续查看 obj.proto.proto,如果 obj.proto.proto 也没有，那么浏览器会继续查,obj.proto.proto.proto__ 直到找到 toString 或者 proto 为 null（不管你从那个属性开始，连续引用proto的指针，最后输出的那个值就是null）。 上面的过程，就是「读」属性的「搜索过程」。 而这个「搜索过程」，是连着由 proto 组成的链子一直走的。 这个链子，就叫做「原型链」。 MDN 的定义 每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节 instanceof 运算符本质首先这有几个题 1234Object instanceof FunctionFunction instanceof ObjectFunction instanceof FunctionObject instanceof Object 能不假思索的说出来吗，大声告诉我，答案是什么。 没错，全是true 虽然 instanceof运算符算是我们的老朋友了，不过背后是咋判断的呢 规范是这么写的 object instanceof constructor 参数： object 要检测的对象. constructor 某个构造函数 instanceof运算符用来检测 constructor.prototype是否存在于参数 object的原型链上 对于 Object instanceof Function ，Object.__proto__ === Function.prototype 为true，解决 对于 Function instanceof Object ， Function.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototype为true，解决。 对于 Function instanceof Function ，Function.__proto__ === Function.prototype 为true，解决 对于 Object instanceof Object , Object.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototype 为true，解决 在上面的各种原型的变换中，其实难点就在于 Function Object 构造函数也是对象 原型对象等所有对象都由Object构造 这四个点。 面试题instanceof 的实现原理如果 left instanceof right ，那么会沿着 left 的原型链一直往上找，如果找到 right.prototype，就 return true，否则就 return false。说白了就是一个链表的的遍历。 （检测left是否出现在right的原型链中） 原型的作用？ 用来理解对象上属性访问的过程 用来判断对象实例是否由某个函数创建 总结原型对象、构造函数、实例对象之间的关系推荐阅读《深刻理解JavaScript基于原型的面向对象》 从一张图看懂原型对象、构造函数、实例对象之间的关系 constructor ：原型对象中的属性，指向该原型对象的构造函数 prototype ：构造函数中的属性，指向该构造函数的原型对象。 _proto_ ：实例中的属性，指向new这个实例的构造函数的原型对象 几句话能解释一切关于原型方面的问题 当 new 一个函数的时候会创建一个对象，『函数.prototype』 等于 『被创建对象.proto』 每个对象的 __proto__ 属性指向自身构造函数的 prototype 一切函数都是由 Function 这个函数创建的，所以『Function.prototype === 被创建的函数.proto』 一切函数的原型对象都是由 Object 这个函数创建的，所以『Object.prototype === 一切函数.prototype.proto』 每个对象（包括函数）都有 __proto__ , 但 null 没有。 每个对象的 __proto__ 只会指向它的构造函数的 prototype 对象，Object.__proto__ 除外，它指向 null。 构造函数的 prototype 对象的 constructor 属性指回构造函数。 参考文章： https://segmentfault.com/a/1190000017816152 https://segmentfault.com/a/1190000018308979 https://zhuanlan.zhihu.com/p/32887069 https://www.liuyiqi.cn/2019/06/01/js-prototype/]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grid布局]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%B8%83%E5%B1%80%2FGrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[🐰… CSS Grid 网格布局教程 [阮一峰] 相关小游戏： http://cssgridgarden.com/]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计工具（持续更新）]]></title>
    <url>%2F2019%2F06%2F05%2F%E8%AE%BE%E8%AE%A1%2F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 色彩选色网站： https://color.adobe.com/zh/create/color-wheel/ https://flatuicolors.com/palette/defo]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目实战小tip经验总结（持续更新）]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%89%8D%E7%AB%AF%2F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E5%92%8C%E8%A7%84%E8%8C%83%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%B0%8Ftip%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端小demo和经验总结汇总 HTML标签多用h5语义化标签123456789101112131415161718192021&lt;body&gt; &lt;header&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt; …… &lt;/section&gt; &lt;section&gt; …… &lt;/section&gt; &lt;section&gt; …… &lt;/section&gt; &lt;article&gt; &lt;header&gt;……&lt;/header&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; &lt;footer&gt; &lt;address&gt;……&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; 事件对象onscroll滚动事件滚动条事件window.onscroll 处理页面滚动事件： 123456789101112131415161718192021222324252627282930313233343536// vue环境下handleScroll() &#123; var _self = this var tur = true var appOffset = document.getElementsByClassName('app-main') // 条件判断+延迟执行阻止scroll事件多次执行 function haha() &#123; console.log('你滚动了页面，进入判断') _self.$nextTick(() =&gt; &#123; _self.setIsLoginShow(true) &#125;) tur = true &#125; var oldTop = document.documentElement.scrollTop || document.body.scrollTop window.onscroll = function() &#123; var newTop = document.documentElement.scrollTop || document.body.scrollTop var OffTop = newTop - oldTop // 滚动的偏移量 // 排除：1.当用户没有登录 2.登录框没有显示时 3.非处理页面 if (!_self.isLogin &amp;&amp; !_self.isLoginShow) &#123; if (_self.notHandlePath.indexOf(_self.$route.path) !== -1) &#123; return &#125; else &#123; if (tur &amp;&amp; OffTop &gt; 50 || OffTop &lt; -50) &#123; setTimeout(haha, 500); tur = false &#125; else &#123; return &#125; &#125; &#125; &#125;&#125;, 方法封装 可以给封装的方法的形参中添加一个回调函数，以达到多种不同情况的额外应用 12345678910111213function test(call) &#123; //...函数方法 if(call) call()&#125;// 调用的不同情况// 普通调用test()// 额外情况调用test(() =&gt; &#123; // 这里放额外需要在这个方法中另外调用的函数方法&#125;) 各类控件导航类Tab标签Vue.js实现tab切换效果 table表格待研究 基于Vue实现可以拖拽的树形表格（原创） 搜索框 vue 搜索结果匹配关键字高亮 样式相关切换主题 Vue中如何使用sass实现换肤(更换主题)功能 vue项目引入scss、elementui使用全局scss修改主题色，vue的路由引入]]></content>
      <categories>
        <category>前端</category>
        <category>经验总结和规范</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue相关面试题详解（持续更新）]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%89%8D%E7%AB%AF%2F%E9%9D%A2%E8%AF%95%2FVue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 原理未computed和methods的区别？浅析Vue中computed与method的区别 computed是属性调用，而methods是函数调用 computed带有缓存功能，而methods不是 Vue的双向数据绑定原理是什么？vue.js 是采用数据劫持 结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 请详细说下你对vue生命周期的理解？总共分为8个阶段 创建前/后，载入前/后，更新前/后，销毁前/后 创建前/后： 在beforeCreated阶段，vue实例的挂载元素 $el 和数据对象data都为undefined，还未初始化。 在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后： 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后： 当data变化时，会触发beforeUpdate和updated方法。 销毁前/后： 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 实际运用vue-router 如何做用户登录权限？实际上就是应用了vue-router提供的router.beforeEach来注册一个全局钩子 官网导航守卫介绍 具体查看文章：用Vue写后台：学习和使用笔记 路由简单的一句话问题vue-router 有哪几种导航钩子？三种： 全局钩子（一般定义在 main.js 文件中） 某个路由的钩子（一般定义在 router.js 文件中） 组件内钩子（一般定义的具体的 .vue 组件文件中，和 data , methods 平级）]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios使用技巧总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F24%2FHTTP%E7%BD%91%E7%BB%9C%2FAxios%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… GET 请求POST 请求默认 官方的一个最简单的post请求的示例 默认的post请求的格式是 application/json 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了，浏览器的原生 form 表单 如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据 在aixos设置这种格式时，必须设置请求头，并引入qs转换格式 12345678910111213141516import axios from 'axios'import qs from 'qs'axios.post('/url', qs.stringify(data), &#123; headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125; &#125;) .then(res =&gt; &#123; _this.msg = res.data &#125;, err =&gt; &#123; console.log(err) &#125;) .catch(function (error) &#123; console.log(error); &#125;) 在浏览器中的格式： 12345POST http://www.example.com HTTP/1.1 Content-Type: application/x-www-form-urlencoded;charset=utf-8 title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded； 其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。 我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值 （当然也可以直接传递参数） 12345678910111213141516var fd = new formData() // 创建form对象fd.append('file',file) // 通过append向form对象添加数据axios.post('/user', fd, &#123; headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125;&#125;) .then(res =&gt; &#123; _this.msg = res.data &#125;, err =&gt; &#123; console.log(err) &#125;) .catch(function (error) &#123; console.log(error); &#125;) application/json（默认） 这又是一个常见的 POST 数据提交的方式。 我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。 json 123456789101112131415import axios from 'axios'axios.post('/url', data, &#123; headers: &#123; 'Content-Type': 'application/json; charset=UTF-8' &#125; &#125;) .then(res =&gt; &#123; _this.msg = res.data &#125;, err =&gt; &#123; console.log(err) &#125;) .catch(function (error) &#123; console.log(error); &#125;) 在浏览器中格式： 实用demo下载文件12345678910111213141516171819202122232425262728// 电子书下载调用的apiexport function download(book, onSucess, onError, onProgress) &#123; // 如果只传入三个参数 if (onProgress == null) &#123; onProgress = onError onError = null &#125; // 可以使用自定义配置新建一个 axios 实例 // axios.create([config]) return axios.create(&#123; baseURL: process.env.VUE_APP_EPUB_URL, method: 'get', responseType: 'blob', // 下载电子书是一个blob对象，这里定义了可以省去我们自己转换blob对象 timeout: 180 * 1000, // 超时时间 onDownloadProgress: progressEvent =&gt; &#123; // 如果第4个参数onProgress存在，则返回progressEvent if (onProgress) onProgress(progressEvent) &#125; &#125;).get(`$&#123;book.categoryText&#125;/$&#123;book.fileName&#125;.epub`) .then(res =&gt; &#123; // 将获取到的图书blob格式的文件保存到 indexDB 中（key值为书名） const blob = new Blob([res.data]) setLocalForage(book.fileName, blob, () =&gt; onSucess(book), // 保存成功，则将图书 err =&gt; onError(err)) // 保存失败，则将错误信息传递给第三个参数onError &#125;).catch(err =&gt; &#123; // 出现异常，则将错误信息传递给第三个参数onError if (onError) onError(err) &#125;)&#125;]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端发送http请求的几种常用方法]]></title>
    <url>%2F2019%2F05%2F24%2FHTTP%E7%BD%91%E7%BB%9C%2F%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[🐰… 前端进行HTTP请求的要点 传入基本参数（url，请求方式） 请求参数、请求参数类型 设置请求头 获取响应的方式 获取响应头、响应状态、响应结果 异常处理 携带cookie设置 跨域请求 前端进行HTTP请求的方式 form表单、ifream、刷新页面 Ajax - 异步网络请求的开山鼻祖 jQuery - 一个时代 fetch - Ajax的替代者 axios、request等众多开源库 form 最原始的一种http请求的方式 12345&lt;FORM method="post" action="http://w.sohu.com" &gt; &lt;INPUT type="text" name="txt1"&gt; &lt;INPUT type="text" name="txt2"&gt; &lt;INPUT type="submit" value="提交"&gt; &lt;/FORM&gt; AjaxAjax的出现解决了什么问题在Ajax出现之前，web程序是这样工作的： 这种交互的的缺陷是显而易见的，任何和服务器的交互都需要刷新页面，用户体验非常差，Ajax的出现解决了这个问题。Ajax全称Asynchronous JavaScript + XML（异步JavaScript和XML） 使用Ajax，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。 Ajax本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，浏览器的XMLHttpRequest是实现Ajax最重要的对象（IE6以下使用ActiveXObject）。 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。 原生Ajax这里主要分析XMLHttpRequest对象，下面是它的一段基础使用： 1234567891011121314151617181920212223242526272829var xhr = new XMLHttpRequest();xhr.open('post','www.xxx.com',true)// 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;"name1":"value1","name2":"value2"&#125;;postData = (function(value)&#123;var dataString = "";for(var key in value)&#123; dataString += key+"="+value[key]+"&amp;";&#125;; return dataString;&#125;(postData));// 设置请求头xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");// 异常处理xhr.onerror = function() &#123; console.log('Network request failed')&#125;// 跨域携带cookiexhr.withCredentials = true;// 发出请求xhr.send(postData); 下面分别对XMLHttpRequest对象常用的的函数、属性、事件进行分析。 函数open 用于初始化一个请求，用法： 1xhr.open(method, url, async); method：请求方式，如get、post url：请求的url async：是否为异步请求 send 用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出，用法： 1xhr.send(param) param：http请求的参数，可以为string、Blob等类型。 abort 用于终止一个ajax请求，调用此方法后readyState将被设置为0，用法： 1xhr.abort() setRequestHeader 用于设置HTTP请求头，此方法必须在open()方法和send()之间调用，用法： 1xhr.setRequestHeader(header, value); getResponseHeader 用于获取http返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串，用法： 1var header = xhr.getResponseHeader(name); 属性readyState 用来标识当前XMLHttpRequest对象所处的状态，XMLHttpRequest对象总是位于下列状态中的一个： 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send()方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 status 表示http请求的状态, 初始值为0。如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200。 responseType 表示响应的数据类型，并允许我们手动设置，如果为空，默认为text类型，可以有下面的取值： 值 描述 &quot;&quot; 将 responseType设为空字符串与设置为&quot;text&quot;相同， 是默认类型 （实际上是 DOMString）。 &quot;arraybuffer&quot; response 是一个包含二进制数据的JavaScript ArrayBuffer 。 &quot;blob&quot; response是一个包含二进制数据的 Blob 对象 。 &quot;document&quot; response 是一个HTML Document或XML XMLDocument，这取决于接收到的数据的 MIME 类型。 &quot;json&quot; response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为JSON解析得到的。 &quot;text&quot; response是包含在DOMString对象中的文本。 response 返回响应的正文，返回的类型由上面的responseType决定。 withCredentials ajax请求默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。 事件回调onreadystatechange 1xhr.onreadystatechange = callback; 当readyState属性发生变化时，callback会被触发。 onloadstart 1xhr.onloadstart = callback; 在ajax请求发送之前（readyState==1后, readyState==2前），callback会被触发。 onprogress 123xhr.onprogress = function(event)&#123; console.log(event.loaded / event.total);&#125; 回调函数可以获取资源总大小total，已经加载的资源大小loaded，用这两个值可以计算加载进度。 onload 1xhr.onload = callback; 当一个资源及其依赖资源已完成加载时，将触发callback，通常我们会在onload事件中处理返回值。 异常处理onerror 1xhr.onerror = callback; 当ajax资源加载失败时会触发callback。 ontimeout 1xhr.ontimeout = callback; 当进度由于预定时间到期而终止时，会触发callback，超时时间可使用timeout属性进行设置。 jQuery jQuery将原生的ajax进行了封装，使使用更加简洁 在很长一段时间里，人们使用jQuery提供的ajax封装进行网络请求，包括$.ajax、$.get、$.post等，这几个方法放到现在，依然很实用 12345678910111213$.ajax(&#123; dataType: 'json', // 设置返回值类型 contentType: 'application/json', // 设置参数类型 headers: &#123;'Content-Type','application/json'&#125;,// 设置请求头 xhrFields: &#123; withCredentials: true &#125;, // 跨域携带cookie data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;), // 传递参数 error:function(xhr,status)&#123; // 错误处理 console.log(xhr,status); &#125;, success: function (data,status) &#123; // 获取结果 console.log(data,status); &#125;&#125;) $.ajax只接收一个参数，这个参数接收一系列配置，其自己封装了一个jqXHR对象，有兴趣可以阅读一下jQuary-ajax 源码 常用配置url 当前页地址。发送请求的地址。 type 类型：String 请求方式 (&quot;POST&quot; 或&quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它HTTP请求方法，如PUT和 DELETE也可以使用，但仅部分浏览器支持。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp 在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分。 error 类型：Function 。请求失败时调用此函数。 注意：源码里对错误的判定： 1isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304; 返回值除了这几个状态码都会进error回调。 dataType 123456"xml": 返回 XML 文档，可用 jQuery 处理。"html": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。"script": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 "cache" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）"json": 返回 JSON 数据 。"jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。"text": 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值:true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： 12345&#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 Ajax中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传：application/x-www-form-urlencoded 这种形式是没有办法将复杂的JSON组织成键值对形式。 1234567&#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 12345$.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) Axios axios基于Promise对原生的XHR进行了非常全面的封装，使用方式也非常的优雅。另外，axios同样提供了在node环境下的支持，可谓是网络请求的首选方案 具体详情请见： POST请求使用axios发送post请求主要有下面三种方式 Content-Type: application/x-www-form-urlencoded Content-Type: multipart/form-data Content-Type: application/json fetch Fetch API是一个用用于访问和操纵HTTP管道的强大的原生 API。 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。 可见fetch是作为XMLHttpRequest的替代品出现的。 使用fetch，你不需要再额外加载一个外部资源。但它还没有被浏览器完全支持，所以你仍然需要一个polyfill。 使用方式：https://segmentfault.com/a/1190000018668190#articleHeader11 参考： https://segmentfault.com/a/1190000018668190]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP消息头总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F24%2FHTTP%E7%BD%91%E7%BB%9C%2FHTTP%E6%B6%88%E6%81%AF%E5%A4%B4%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… ，MDN：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers HTTP 消息结构客户端请求信息 客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头（header）、空行和请求数据（请求体）四个部分组成 下图给出了请求报文的一般格式。 服务器响应消息 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 实例下面实例是一点典型的使用GET来传递数据的实例： 客户端请求： 1234GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应: 123456789HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: "34aa387-d-1568eb00"Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain HTTP 消息头概念HTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。 根据不同上下文可将消息头分为： 一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。 请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。 响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。 实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。 根据代理对其的处理方式分为： 端到端消息头 这类消息头必须被传输到最终的消息接收者，也即，请求的服务器或响应的客户端。中间的代理服务器必须转发未经修改的端到端消息头，并且必须缓存它们。 逐跳消息头 这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发。这些消息头包括 Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailer, Transfer-Encoding 及 Upgrade。注意，只能使用 Connection 来设置逐跳一般头。 常见的请求头属性 一览表：http://tools.jb51.net/table/http_header Accept：指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。 Accept属性的值可以为一个或多个MIME类型的值，关于MIME类型，大家请参考：https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types Accept-Encoding : 指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式 Accept-Language : 指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。 cookie ：客户端的Cookie就是通过这个报文头属性传给服务端的 Referer：表示这个请求是从哪个URL过来的 Cache-Control ：对缓存进行控制 如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。 如以下设置，相当于让服务端将对应请求返回的响应内容不要在客户端缓存： Cache-Control: no-cache Content-Type：请求头的长度 Connec-Length：显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性 Hose : 客户端地址 User-Agent : 客户端信息 x-Requested-With : 是否为同步请求 ，如果为XMLHttpRequest，则为 Ajax 异步请求。如果为null则为传统同步请求 常见的响应头属性 响应头Response Header 一览表：http://tools.jb51.net/table/http_header 常用的Content-Type Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，比如用PHP输出图片文件、JSON数据、XML文件等非HTML内容时，就必须用header函数来指定Content-Type，才能达到输出一张图片或是其它指定内容类型的需求。 一览表：http://tools.jb51.net/table/http_content_type 关于Content-Type中application/x-www-form-urlencoded 和 multipart/form-data的区别及用法 HTTP协议之multipart/form-data请求分析]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端用户认证方式（持续更新）]]></title>
    <url>%2F2019%2F05%2F24%2FHTTP%E7%BD%91%E7%BB%9C%2F%E5%89%8D%E7%AB%AF%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… JSON Web TokenJSON Web Token 入门教程 JWT Token存储在Cookie还是LocalStorage cookie和sessioncookie以下来自MDN的官方解释： HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 session和cookie的联系Session 中文意思名为“会话”，是一种解决方案，代表客户端和服务端的一次通信过程，在这个过程中如果客户端需要记录数据，服务端会暂时把数据挂载到 session 对象上，当请求结束响应时，将 session 中挂载的数据持久化到客户端的 cookie上，清空 session，关闭会话 Cookie 可以看做一个信息容器，借助浏览器的环境对服务端的数据进行持久化存储，随后每次都会在 HTTP 请求头中携带并发送至服务端，这样服务端就可以辨识请求的来源 cookie和token的区别Cookie和Token cookie和token的五点区别 Cookie 还是Token，这是一个问题]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex Cokkbook阅读笔记（持续更新）]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2FVuex-Cokkbook%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 地址：https://cn.vuejs.org/v2/cookbook/index.html 书签添加实例属性]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue常用弹出框类组件（持续更新）]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%89%8D%E7%AB%AF%2FVue%2F%E7%BB%84%E4%BB%B6%E5%BA%93%E5%92%8C%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2FVue%E5%B8%B8%E7%94%A8%E5%BC%B9%E5%87%BA%E6%A1%86%E7%B1%BB%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 书签 vue-js-modal https://www.npmjs.com/package/vue-js-modal#dialog vue-js-modal npm：https://www.npmjs.com/package/vue-js-modal Demo: http://vue-js-modal.yev.io/ basic 安装1npm install vue-js-modal --save 引入main.js 文件 123import VModal from 'vue-js-modal' Vue.use(VModal) 自定义组件名12// 默认组件名为 "modal"，如果需要自定义则：Vue.use(VModal, &#123; componentName: "foo-modal" &#125;) 组件中使用： 1&lt;foo-modal name="bar"&gt;&lt;/foo-modal&gt; 在组件中使用Create modal: 123&lt;modal name="hello-world"&gt; hello, world!&lt;/modal&gt; Call it from anywhere in the app: 12345678methods: &#123; show () &#123; this.$modal.show('hello-world'); &#125;, hide () &#123; this.$modal.hide('hello-world'); &#125;&#125; You can easily send data into the modal: 1this.$modal.show('hello-world', &#123; foo: 'bar' &#125;) And receive it in beforeOpen event handler: 123456&lt;modal name="hello-world" @before-open="beforeOpen"/&gt;methods: &#123; beforeOpen (event) &#123; console.log(event.params.foo); &#125;&#125; Dialog 查看demo演示：http://vue-js-modal.yev.io/ npm：https://www.npmjs.com/package/vue-js-modal#dialog 12]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>组件库和插件工具</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VeeValidate：表单验证组件（持续更新）]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%89%8D%E7%AB%AF%2FVue%2F%E7%BB%84%E4%BB%B6%E5%BA%93%E5%92%8C%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2FVeeValidate%EF%BC%9A%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… github：https://github.com/baianat/vee-validate 官方文档：https://baianat.github.io/vee-validate/guide/ 验证规则：https://baianat.github.io/vee-validate/guide/rules.html 教程文章 一个简单显而易见的教程 使用方式首先安装 1npm install vee-validate --save 使用 npm 安装，注入依赖。这边配置使用主要是3个文件： vee-validate.js ：自己创建一个文件，单独将关于表单验证的代码抽离出来，从 node_modules 中引入 VeeValidate，配置相关项 main.js ：vue 主文件入口，引入validate.js form.vue ：表单组件 main.js 引入引入 vee-validate.js 文件，将相关配置独立在一个文件夹里 1import './utils/vee-validate.js' vee-validate.js 基本配置先展示一个全部代码的示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import Vue from 'vue'import VeeValidate, &#123; Validator &#125; from 'vee-validate'import zh_CN from 'vee-validate/dist/locale/zh_CN' // 支持中文错误提示的文件import VueI18n from 'vue-i18n' // i18n国际化import &#123; byteSize, checkTel, CheckPassWord &#125; from './validate.js' // 验证规则Vue.use(VueI18n) // 使用i18n国际化const i18n = new VueI18n(&#123; locale: 'zh_CN'&#125;)// 配置中文错误提示Vue.use(VeeValidate, &#123; i18n, i18nRootKey: 'validation', dictionary: &#123; zh_CN &#125;&#125;)// 自定义验证规则function customMethod() &#123; Validator.extend('mobile', &#123; getMessage: () =&gt; '请输入正确的固话或者手机号码', validate: value =&gt; checkTel(value) &#125;) Validator.extend('company', &#123; getMessage: () =&gt; '请输入50字节以内的公司名称', validate: value =&gt; byteSize(value, 50) &#125;) Validator.extend('department', &#123; getMessage: () =&gt; '请输入20字节以内的部门名称', validate: value =&gt; byteSize(value, 20) &#125;) Validator.extend('password', &#123; getMessage: value =&gt; value + '需要由字母和数字组成', validate: value =&gt; CheckPassWord(value) &#125;) Validator.extend('psw', &#123; getMessage: () =&gt; '密码由字母和数字组成，固定6位', validate: value =&gt; &#123; if (value === null || value.length !== 6) &#123; return false &#125; CheckPassWord(value) return true &#125; &#125;)&#125;customMethod()// 自定义validateconst Dictionary = &#123; zh_CN: &#123; messages: &#123; required: field =&gt; '请输入' + field &#125;, attributes: &#123; userName: '用户名', companyName: '公司名称' &#125; &#125;&#125;// 自定义validate error 信息Validator.localize(Dictionary) 引入 引入表单验证依赖文件 1234import Vue from 'vue'import VeeValidate, &#123; Validator &#125; from 'vee-validate'import zh_CN from 'vee-validate/dist/locale/zh_CN' // 支持中文错误提示的文件import VueI18n from 'vue-i18n'; // i18n国际化 配置中文版错误提示1234567891011121314Vue.use(VueI18n) // 使用i18n国际化const i18n = new VueI18n(&#123; locale: 'zh_CN'&#125;)// 配置中文错误提示Vue.use(VeeValidate, &#123; i18n, i18nRootKey: 'validation', dictionary: &#123; zh_CN &#125;&#125;) 自定义表单验证提示语为了避免下面的场景 我们来自定义表单验证提示语 ⭐：注意！除了这个办法还可以直接在组件中操作：具体看组件中使用 message ： 提示语 attributes： filed 1234567891011121314// 自定义validateconst Dictionary = &#123; zh_CN: &#123; messages: &#123; required: field =&gt; '请输入' + field &#125;, attributes: &#123; userName: '用户名', companyName: '公司名称' &#125; &#125;&#125;// 自定义validate error 信息Validator.localize(Dictionary) 扩展自定义的验证 扩展自定义的验证，比如这边自定义了电话的表单验证 ··· 1234Validator.extend('mobile', &#123; getMessage: () =&gt; '请输入正确的固话或者手机号码', validate: value =&gt; checkTel(value) // checkTel（）是具体的验证方法 &#125;) 在组件中使用 比如：form.vue 组件中的代码 12&lt;input v-model="name" v-validate="'required|min:3|alpha'" :class="&#123;'input': true, 'is-danger': errors.has('name') &#125;" type="text" name="name" placeholder="账户"&gt;&lt;span v-show="errors.has('name')" class="text-style" v-cloak&gt; &#123;&#123; errors.first('name') &#125;&#125; &lt;/span&gt; 这是其中的一个 input 拿出来讲： 1、首先在 input 中你得有 name 属性。 2、v-validate 属性：管道形式进行过滤，验证条件。 3、span 就是错误提示 。 data-vv-as为了避免下面的场景 我们可以加入data-vv-as，比如： 123456&lt;input type="text" v-validate="'required'" name="departmentName" data-vv-as="部门名称" v-model="form.department" placeholder="请输入部门名称"&gt; 这样就会提示 data-vv-as 中定义的字段 data-vv-validate-on规定具体的输入项在哪些事件上验证 1&lt;input name="field" v-validate="'required'" data-vv-validate-on="change|blur"&gt; 一进入就验证 比如我们想达到：一开始进入的时候按钮是不可点的的效果 配置：v-validate.initial=&quot;&quot; 12345&lt;input type="text" v-validate.initial="'required|max:6|alpha_num'" name="userName" v-model="form.username" placeholder="请输入用户名"&gt; v-validate123v-validate=&quot;&apos;required|email&apos;&quot;v-validate 是由该插件提供的指令 作用于 html 上&quot;&apos;required|email&apos;&quot; 字段验证的规则，注意双引号之内必须有单引号，多个规则之间用 | 连接 一些示例： 1v-validate="'required|min:3|alpha'" 错误提示 errors.has (‘email’) 判断 emai 字段值是否验证通过 email 内容指向 input 的 name 属性 必须设置成一样 这意味着要用该插件，input 上的 name 属性必须设置 errors.first (&#39;field&#39;)： 显示字段 field 的第一个出错信息 errors.collect (&#39;field&#39;): 显示字段 field 的所有出错信息(list) errors.has (&#39;field&#39;)： 判断 fileds 字段是否检验有误(true/false) erros.all (): 显示表单所有的出错信息(list) errors.any ()： 判断表单是否有错误(true/false) 常用实例校验两次输入的密码是否一致123456789101112131415161718&lt;div&gt; &lt;mt-field label="密码" placeholder="请输入密码" v-validate="'required'" data-vv-name="password" :class="&#123;'is-danger': errors.has('password') &#125;" :type="passwordType" :attr="&#123;maxlength:20&#125;" v-model="user.password"&gt; &lt;/mt-field&gt; &lt;div v-show="errors.has('password')"&gt; &lt;p&gt;&#123;&#123; errors.first('password') &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;mt-field label="确认密码" placeholder="请再次输入密码" v-validate="&#123;'required': 'true', 'is': user.password&#125;" data-vv-name="repassword" :class="&#123;'is-danger' :errors.has('repassword') &#125;" :type="passwordType" :attr="&#123;maxlength:20&#125;" v-model="user.repassword"&gt; &lt;/mt-field&gt; &lt;div v-show="errors.has('repassword')"&gt; &lt;p&gt;&#123;&#123; errors.first('repassword') &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 失去焦点和改变时验证 Validation Events 123Vue.use(VeeValidate, &#123; events: 'change|blur'&#125;); 参考文章： https://blog.csdn.net/docallen/article/details/73650179]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>组件库和插件工具</category>
      </categories>
      <tags>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件-事件流总结]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJavaScript%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[🐰… 事件事件是文档或者浏览器窗口中发生的，特定的交互瞬间。 事件是用户或浏览器自身执行的某种动作，如 click , load 和 mouseover 都是事件的名字。 事件是javaScript和DOM之间交互的桥梁。 典型的例子有： 页面加载完毕触发 load事件 ； 用户单击元素，触发 click事件 。 事件流事件流描述的是从页面中接收事件的顺序。 事件流感性认识问题：单击页面元素，什么样的元素能感应到这样一个事件？ 答案：单击元素的同时，也单击了元素的容器元素，甚至整个页面。 例子：有三个同心圆， 给每个圆添加对应的事件处理函数，弹出对应的文字。单击最里面的圆，同时也单击了外面的圆，所以外面圆的click事件也会被触发。（如果下方例子没有出现，请多刷新几次页面或者直接点击例子链接查看） 事件流事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。【推荐】 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。 事件捕获的思想就是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;Click me!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段html代码中，单击了页面中的元素， 在冒泡型事件流中click事件传播顺序为—》—》—》document 在捕获型事件流中click事件传播顺序为document—》—》—》 note: 所有现代浏览器都支持事件冒泡，但在具体实现中略有差别：IE5.5及更早版本中事件冒泡会跳过\元素(从body直接跳到document)。 IE9、Firefox、Chrome、和Safari则将事件一直冒泡到window对象。IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。 由于老版本浏览器不支持，很少有人使用事件捕获。建议使用事件冒泡。 DOM事件流DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。 DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件捕获阶段：实际目标（\）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到\再到\就停止了。上图中为1~3.L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"position":"left","width":240,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false}); 处于目标阶段：事件在\上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 note: 尽管“DOM2级事件”标准规范明确规定事件捕获阶段不会涉及事件目标，但是在IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两次机会在目标对象上面操作事件。 并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。 两次机会在目标对象上面操作事件例子 （如果下方例子没有出现，请多刷新几次页面或者直接点击例子链接查看） ⭐ 该例子和上一个例子的区别 IE事件流和DOM事件流的区别执行的顺序不一样12345&lt;body&gt; &lt;div&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) 捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流) DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡) 事件侦听函数的区别IE使用: 12[Object].attachEvent("name_of_event_handler", fnHandler); //绑定函数 [Object].detachEvent("name_of_event_handler", fnHandler); //移除绑定 DOM使用： 12[Object].addEventListener("name_of_event", fnHandler, bCapture); //绑定函数 [Object].removeEventListener("name_of_event", fnHandler, bCapture); //移除绑定 参数不一样和this指向不一样IE下注册多个事件监听器与移除监听器方法注册多个事件监听器1element.attachEvent('onclick', observer); attachEvent接受两个参数。 第一个参数是事件名称 第二个参数observer是回调处理函数。 这里得说明一下，有个经常会出错的地方，IE下利用attachEvent注册的处理函数调用时this指向不再是先前注册事件的元素，这时的this为window对象了，笔者很奇怪IE为什么要这么做，完全看不出好处所在。 移除先前注册的事件的监听器1element.detachEvent('onclick', observer); DOM标准下注册多个事件监听器与移除监听器方法注册多个事件监听器实现DOM标准的浏览器与IE浏览器中注册元素事件监听器方式有所不同，它通过元素的addEventListener方法注册，该方法既支持注册冒泡型事件处理，又支持捕获型事件处理。 1element.addEventListener('click', observer, useCapture); addEventListener方法接受三个参数。 第一个参数是事件名称，值得注意的是，这里事件名称与IE的不同，事件名称是没’on’开头的; 第二个参数observer是回调处理函数; 第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用 它可以在一个DOM元素上绑定多个事件处理器，并且在处理函数内部，this关键字仍然指向被绑定的DOM元素，另外处理函数参数列表的第一个位置传递事件event对象。 移除先前注册的事件的监听器1element.removeEventListener('click', observer, useCapture); 事件绑定和普通事件的区别添加事件的方法不同普通添加事件的方法：onclick 123456789var btn = document.getElementById("hello");btn.onclick = function()&#123; alert(1);&#125;btn.onclick = function()&#123; alert(2);&#125; // 执行上面的代码只会alert 2 事件绑定方式添加事件：addEventListener() 123456789var btn = document.getElementById("hello");btn.addEventListener("click",function()&#123; alert(1);&#125;,false);btn.addEventListener("click",function()&#123; alert(2);&#125;,false);// 执行上面的代码会先alert 1 再 alert 2 👆关于这两者的区别：在上面事件流的章节里有更加详细的例子 是否可以添加多个事件 普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的 而事件绑定（addEventListener）方式添加事件可以添加多个，按照顺序依次执行。 是否支持DOM事件流 普通事件：不支持 事件绑定：支持 绑定的事件是否可以取消 普通方式绑定事件后，不可以取消 addEventListener绑定后则可以用 removeEvenListener 取消 事件流的典型应用 -事件委托什么是事件委托它还有一个名字叫事件代理。 JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 用取快递来解释这个现象，大家认真领会一下事件委托到底是一个什么原理： 有三个同事预计会在周一收到快递。为签收快递，有两种办法： 一是三个人在公司门口等快递；二是委托给前台MM代为签收。 现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 为什么要用事件委托​ 一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ ​ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； ​ 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 总结： 将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。 DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。 事件委托的原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件 举个例子： 页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div 有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 事件委托怎么实现？替代遍历循环终于到了本文的核心部分了，哈哈，在介绍事件委托的方法之前，我们先来看一段一般方法的例子： 12345678910111213141516171819202122232425&lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt;&lt;/ul&gt; &lt;script&gt; var colorList=document.getElementById("color-list"); var colors=colorList.getElementsByTagName("li"); for(var i=0;i&lt;colors.length;i++) &#123; colors[i].addEventListener('click',showColor,false); &#125;; function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; alert(targetElement.innerHTML); &#125;&lt;/script&gt; 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； 那么我们用事件委托的方式做又会怎么样呢？ 1234567891011121314151617&lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt;&lt;/ul&gt; &lt;script&gt; var colorList=document.getElementById("color-list"); colorList.onclick = function() &#123; alert(targetElement.innerHTML); &#125;&lt;/script&gt; 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发。 当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发 解决方法 li 的事件处理程序中检测 target 元素 Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源。 也就是说，target 就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用e.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用 nodeName 来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较 1234567891011var colorList=document.getElementById("color-list");colorList.addEventListener('click',showColor,false);function showColor(e) &#123; e=e||window.event; var targetElement=e.target||e.srcElement; if(targetElement.nodeName.toLowerCase()==="li")&#123; alert(targetElement.innerHTML); &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？ 一般的dom处理方式： 12345678910111213141516171819202122232425262728&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt;&lt;script&gt;window.onload = function () &#123; var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function () &#123; alert('添加'); &#125;; Remove.onclick = function () &#123; alert('删除'); &#125;; Move.onclick = function () &#123; alert('移动'); &#125;; Select.onclick = function () &#123; alert('选择'); &#125;&#125;&lt;/script&gt; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 123456789101112131415161718192021222324window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125; &#125; 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的 新添加的元素现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？ 看一下正常的添加节点的方法： 1234567&lt;input type="button" name="" id="btn" value="添加" /&gt; &lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; 现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点 1234567891011121314151617181920212223window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？ 一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下： 123456789101112131415161718192021222324252627window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () &#123; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; &#125; mHover (); //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); &#125;;&#125; 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的 那么有事件委托的方式，能做到优化吗？ 1234567891011121314151617181920212223242526272829303132window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "red"; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "#fff"; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。 实际应用例子 点击一个列表时，输出对应的索引 12345678910&lt;script&gt; var ul=document.querySelector('ul'); var lis=ul.querySelectorAll('ul li'); ul.addEventListener('click', function (e) &#123; var target= e.target; if(target.nodeName.toUpperCase()==='LI')&#123; alert([].indexOf.call(lis,target)); &#125; &#125;,false)&lt;/script&gt; e.target与e.currentTarget理解https://www.jianshu.com/p/1dd668ccc97a 总结那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，再比如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不能用事件委托了。 此文只做总结归纳，方便后续理解复习，并非全部原创，参考原文来自： http://www.cnblogs.com/starof/p/4066381.html https://www.cnblogs.com/nikiguo/p/8522317.html 12]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP/IP相关的知识总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F17%2FHTTP%E7%BD%91%E7%BB%9C%2F%E5%85%B3%E4%BA%8ETCP%2CIP%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰仅作为一个前端从事者的整理，可能不会特别深入 待看文章 重学TCP/IP 协议 与三次握手 基础OSI(Open Systems Interconncection，开放系统互联)网络分层 从上到下分别是： 7.应用层(Application)6.表示层(Presentation)5.会话层(Session)4.传输层(Transport)3.网络层(Network) – 路由器2.数据链路层(Data Link) – 交换机1.物理层(Physical) – 网卡、集线器（Hub）TCP头部报文结构tcp的头部报文结构 三次握手和四次挥手相关的关键词 ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； 三次握手： 客户端发送 syn 包到服务器，等待服务器确认接收。 服务器确认接收 syn 包并确认客户的 syn ，并发送回来一个 syn+ack 的包给客户端。 客户端确认接收服务器的 syn+ack 包，并向服务器发送确认包 ack ，二者相互建立联系后，完成tcp三次握手。 四次握手：就是中间多了一层 等待服务器再一次响应回复相关数据的过程 相关有趣的总结 谈谈你对 TCP 三次握手和四次挥手的理解 https://juejin.im/post/5c078058f265da611c26c235#heading-11 详解三次握手和四次挥手：遇到心动的女孩时，如何去把握？ 此处仅作知识整理，便于自己查阅，详情参考原文： https://juejin.im/post/5c078058f265da611c26c235]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目性能优化总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F17%2F%E5%89%8D%E7%AB%AF%2F%E6%80%A7%E8%83%BD%E5%92%8C%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 记一次vue+element+echarts项目的优化（如何轻松将项目性能提升70%） 已阅，待总结和实际运用]]></content>
      <categories>
        <category>前端</category>
        <category>性能和构建部署</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一句话就可以回答的面试题（持续更新）]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%89%8D%E7%AB%AF%2F%E9%9D%A2%E8%AF%95%2F%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E7%AD%94%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 待看文章HTML和CSS未分类说一说CSS3新特性？ CSS3 多媒体查询 @media all and(min-width:800px){…} CSS3 转换和变形：transform CSS3 过渡：transition CSS3 动画：animation 布局请简述一下比较常见的几种布局方式？比较常见的主要有float布局，table布局，flex布局，grid布局 使用inline-block 的问题以及解决方案 水平间隙问题 这是因为编写代码时输入空格、换行都会产生空白符。而浏览器是不会忽略空白符的，并且对于多个连续的空白符自动合并成一个，故产生了所谓的间隙。 一般来说我们有两种方法来去掉这个换行引起间隙： 代码不换行 和 设置 font-size。 (推荐) 通过设置父元素的 font-size 为 0 来去掉这个间隙，然后重置子元素的 font-size，让其恢复子元素文字字符。 只要设置 inline-block 就要去间隙 请大概讲解下position定位方式 JavaScript未分类如何准确判断一个变量是数组类型？ arr instanceof Array Array.isArray(arr) Object.prototype.toString.call(arr) === &#39;[object Array]&#39; 描述new一个对象的过程 创建一个对象 对象._proto_ = 构造函数.prototype this指向这个对象 执行代码即对this赋值 返回this 异步promise Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？ promise构造函数是同步执行的，then方法是异步执行的 一句话概述下什么是 promise promise是一个用来传递异步操作的对象，分离了异步获取和业务逻辑，解决了曾经用回调函数来做异步的回调地狱的问题。 promise基本的api有哪些？ Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 Promise.all([p1,p2,p3]) 异步请求的实现方式 最原始的js ,new XMLHttpRequest(); //由于浏览器兼容的原因，代码复杂，多使用基于jQuery的异步请求方法（内部封装） 基于jQuery的Ajax方法： Vue–axios （promise） 算法数组 将一个多重数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 1Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; a-b) Vue原理 为什么vue组件中的data要用function返回对象？ 类似于原生js中的引用数据类型，js在赋值objec对象时，是直接一个相同的内存地址 而vue组件可能被用来创建多个实例，如果data是一个纯粹的对象，那么所有的实例中的data将共享引用同一个对象的内存地址（那么一个数据改变了，其他实例也会跟着改变） 而用 function return 其实就相当于返回了一个新的对象实例，相互独立，解决了这个问题 vue中computed和methods的区别 computed是属性调用，而methods是函数调用 computed带有缓存功能，而methods不是 网络HTTP未HTTP请求信息由哪3部分组成？ 请求方法URI协议/版本 （例如：GET/haorooms.jspHTTP/1.1） 请求头(Request Header)（例如：Accept:image/gif.image/jpeg./ Accept-Language:zh-cn Connection:Keep-Alive Host:localhost等等） 请求正文]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组相关技巧方法总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJS%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… [数组，算法，面试] 待看文章 JavaScript数组去重（12种方法，史上最全） 目前只看了首尾的ES6的两种方法 未分类 利用 apply 将二维数组转换为一维数组 12345const c = [[1, 2, 3], [4, 5, 6]]// apply 会将传入的数组转换为参数传入const newArray = [].concat.apply([], c)console.log(newArray) // [1, 2, 3, 4, 5, 6] 将树状的数组转换为一维数组 1234567891011export function flatten(array) &#123; return [].concat(...array.map(item =&gt; [].concat(item, ...flatten(item.subitems))))&#125;// 将上面的代码结构化function flatten(array) &#123; const newArray = array.map( item =&gt; &#123; return [].concat(item, ...flatten(item.subitems)) &#125;) return [].concat(...newArray)&#125; filter() 结合 indexOf() ：从一个数组中过滤另一个数组 1234// 原理：indexOf() 方法可返回数组中某个指定的元素位置。如果在数组中没找到指定元素则返回 -1。// 过滤Array1中与Array2相等的部分NewArray = Array1.filter(item =&gt; Array2.indexOf(item) &lt; 0) 具体方法运用Array.prototype.reduce()MDN 相关文章： Javascript中数组方法reduce的妙用之处 数组去重ES6 ES6的两种方法如果不考虑兼容性，是目前最简洁最使用的数组去重的方法 Set + Array.from()Array.from(new Set(arr)) 例子： 123456function unique (arr) &#123; return Array.from(new Set(arr))&#125;var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;];console.log(unique(arr)) //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;] …[扩展符] + Set[...new Set(arr)] 例子： 1234// ...拓展运算符，是遍历Symbol.iterator // 和for...of一样的遍历方法var tt = [...new Set([5,5,6,6,8,])] // 5，6，8 总结两个方法中的 Array.from() 和 [] 都是为了将类数组去重后转换为数组 ES5es5的 filter() 123[1, 3, 4, 5, 1, 2, 3, 3, 4, 8, 90, 3, 0, 5, 4, 0].filter(function (elem, index, Array) &#123; return index === Array.indexOf(elem);&#125;) 原生JS总结综合数组去重合并1234567function combine()&#123; let arr = [].concat.apply([], arguments); // 1.拼接 return Array.from(new Set(arr)); // 2.去重&#125; var m = [1, 2, 2], n = [2,3,3]; console.log(combine(m,n)); // [1, 2, 3] 该方法的解析 多层数组扁平化去重排序1Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; a-b) 解析： 解析以上可以分步总结为以下步骤： 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 123456789var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]// 1.扁平化let flatArr = arr.flat(4)// 2.去重let disArr = Array.from(new Set(flatArr))// 3.排序let result = disArr.sort((a, b) =&gt; a - b)console.log(result)// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 拍平数组：const flatArray = arr =&gt; arr.reduce((a,b) =&gt; a.concat(Array.isArray(b) ? flatArray(b): b), []); 去重+排序: […new Set(flatArray)].sort((a,b) =&gt; a-b); 相关知识点 Array.prototype.flat() Array.from() Array.prototype.sort() 参考： https://segmentfault.com/a/1190000016418021#articleHeader11]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一道题理解JS的事件循环（异步机制）]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2F%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%90%86%E8%A7%A3JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 相关待看文章 js同步和异步 JavaScript 运行机制详解：再谈Event Loop 理解 JavaScript 中的 macrotask 和 microtask setTimeout、Promise、Async/Await 题目12345678910111213141516171819202122232425262728293031323334353637//请写出输出内容async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 涉及知识点任务队列首先我们需要明白以下几件事情： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 根据规范，事件循环是通过任务队列的机制来进行协调的。 一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合； 每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。 宏任务(macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： 1(macro)task-&gt;渲染-&gt;(macro)task-&gt;... (macro)task主要包含： script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比 setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 microtask主要包含： Promise.then MutaionObserver process.nextTick(Node.js 环境) 运行机制在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 流程图如下： Promise和async中的立即执行我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在Promise中的代码是被当做同步任务立即执行的。 而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？ await做了什么从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。 很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await里面的表达式会先执行一遍，将await里面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。 由于因为async await 本身就是promise+generator的语法糖。所以await后面的代码是microtask。所以对于下例中的 12345async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125; 等价于 123456async function async1() &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; 回到本题以上就本道题涉及到的所有相关知识点了，下面我们再回到这道题来一步一步看看怎么回事儿。 首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以，上面例子的第一步执行如下图所示： 然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中： script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1 start。 遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(&#39;async1 end&#39;)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码。 script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。 script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。 因而在script任务（宏任务）执行完毕之后，开始查找清空微任务队列。此时，微任务中， Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 Microtasks （宏任务）执行完毕之后，表示第一轮的循环就结束了。 第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束。 原题拓展变式变式一在第一个变式中我将async2中的函数也变成了Promise函数，代码如下： 1234567891011121314151617181920212223242526272829async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; //async2做出如下更改： new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2'); &#125;);&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise3'); resolve();&#125;).then(function() &#123; console.log('promise4');&#125;);console.log('script end'); 可以先自己看看输出顺序会是什么，下面来公布结果： 123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 在第一次macrotask执行完之后，也就是输出script end之后，会去清理所有microtask。所以会相继输出promise2，async1 end ，promise4，其余不再多说。 变式二在第二个变式中，我将async1中await后面的代码和async2的代码都改为异步的，代码如下： 12345678910111213141516171819202122232425262728async function async1() &#123; console.log('async1 start'); await async2(); //更改如下： setTimeout(function() &#123; console.log('setTimeout1') &#125;,0)&#125;async function async2() &#123; //更改如下： setTimeout(function() &#123; console.log('setTimeout2') &#125;,0)&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout3');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 可以先自己看看输出顺序会是什么，下面来公布结果： 12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 在输出为promise2之后，接下来会按照加入setTimeout队列的顺序来依次输出，通过代码我们可以看到加入顺序为3 2 1，所以会按3，2，1的顺序来输出。 变式三变式三是我在一篇面经中看到的原题，整体来说大同小异，代码如下： 123456789101112131415161718192021222324252627282930313233async function a1 () &#123; console.log('a1 start') await a2() console.log('a1 end')&#125;async function a2 () &#123; console.log('a2')&#125;console.log('script start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve('promise2.then') console.log('promise2')&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;)&#125;)console.log('script end') 无非是在微任务那块儿做点文章，前面的内容如果你都看懂了的话这道题一定没问题的，结果如下： 12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout tips：注意该题还涉及到promise的直接执行的顺序（具体请查看） 本文只做整合理解，具体参考原文： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%B8%83%E5%B1%80%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[🐰… 菜鸟教程：https://www.runoob.com/cssref/css-reference.html#flexbox flex属性计算详解1flex: flex-grow flex-shrink flex-basis|auto|initial|inherit; Flex-grow、Flex-shrink、Flex-basis 是Flex属性的分写模式；如 .box { flex: 4 3 100px; } 等于 .box { flex-grow: 4; flex-shrink: 3; flex-basis: 100px; } flex-grow 是扩展比率 flex-shrink 是收缩比率 flex-basis 伸缩基准值 看以下例子123456789&lt;div class="flex-parent"&gt; &lt;div class="flex-son"&gt;&lt;/div&gt; &lt;div class="flex-son"&gt;&lt;/div&gt; &lt;div class="flex-son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style type="text/css"&gt; .flex-parent &#123; width: 800px; &#125; &lt;/style&gt; 第一种情况 当子元素的总量&lt;父元素时 flex-parent 是父级，而且他的宽度是固定为800px，不会改变； 开始设置子级flex属性： 12345&lt;style type="text/css"&gt; .flex-son:nth-child(1)&#123; flex: 3 1 200px; &#125; .flex-son:nth-child(2)&#123; flex: 2 2 300px; &#125; .flex-son:nth-child(3)&#123; flex: 1 3 500px; &#125; &lt;/style&gt; flex-basis 总和加起来为 200px + 300px + 500px = 1000px； 那么 1000px &gt; 800px (父级的宽度)；子元素势必要压缩；溢出了200px； 1234son1 = (flex-shrink) * flex-basis； // 1*200px = 200pxson2 = (flex-shrink) * flex-basis； // 2*300px = 600px....sonN = (flex-shrink) * flex-basis； // 3*500px = 1500px 如果 flex-basis 的总和加起来大于父级宽度，子级被压缩，最后的选择是 flex-shrink 来进行压缩计算加权值 = son1 + son2 + …. + sonN； 所以最后的加权值是1*200 + 2*300 + 3*500 = 2300px 那么压缩后的计算公式就是压缩后宽度 w = ( 子元素flex-basis值 (flex-shrink) / 加权值 ) 溢出值 所以：son1的压缩量：(200 1/ 2300) 200，即约等于16px；son2的压缩量：(300 2/ 2300) 200，即约等于52px；son3的压缩量：(500 3/ 2300) 200，即约等于130px； 最后son1、son2、son3，的实际宽度为：200 – 16 = 184px；300 – 52 = 248px；500 – 130 = 370px； 第二种情况 当子元素总量&gt;父元素时 上面的例子已经说明，继续看第二个例子，同样上面的例子，我们改下父级宽度为1200px; flex-basis 的总和为 1000px，小于父级宽度，将有200px的剩余宽度；既然有剩余，我们就不要加权计算，剩余的宽度将根据 flex-grow值的总和进行百分比，那么200px就会根据份数比来分配剩余的空间； 剩余后宽度 w = ( 子元素flex-grow值 / 所有子元素flex-grow的总和 ) * 剩余值 总分数为 total = 1 + 2 + 3；son1的扩展量：(3/total) 200，即约等于100px；son2的扩展量：(2/total) 200，即约等于67px；son3的扩展量：(1/total) * 200，即约等于33px； 最后son1、son2、son3，的实际宽度为：200 + 100 = 300px；300 + 67 = 367px；500 + 33 = 533px； 总结所以以上两种情况下： 第一种 flex-grow是不列入计算公式的 第二种 flex-basis 和 flex-shrink 是不列入计算公式的； ok，上面的两种情况总结完毕，但是很多时候我们的父级是不固定的，那么怎么办？其实很简单了，对照上面的公式，前提是已经设置了 flex-basis 值的元素，如果宽度的随机值小于 flex-basis 的时候就按第一种计算，反之第二种；明白了吧。 但是在实际中，我们有些子元素不想进行比例分配，永远是固定的，那么 flex 就必须设置为none；否则设置的宽度（width）将无效； 一些缩写表示的意思： flex: 1 其计算值为 flex: 1 1 0% flex: auto其计算值为 flex: 1 1 auto flex: none其计算值为 flex: 0 0 auto 根据上面的公式： flex：1 的时候第一种方式其实是无效的，因为加权值是0，所以只能是第二种方式计算； flex：none 的时候，两种都失效，子元素不参与父级剩余还是溢出的分配 参考： https://zhidao.baidu.com/question/1950248018695262828.html]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>布局</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css布局（持续更新）]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%B8%83%E5%B1%80%2Fcss%E5%B8%83%E5%B1%80%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 两列布局 左侧固定宽右侧自适应 浮动布局关键点： 一、先让固定宽度的div浮动！使其脱离文档流。 二、margin-left的值等于固定div的宽度相等。 点击查看示例 关键代码： 123456789101112.left &#123; float: left; width: 200px; height: 600px; background: pink;&#125;.right &#123; margin-left: 200px; height: 600px; background: lightblue;&#125; calc()计算属性 注意兼容性 注意：使用calc计算属性的时候 运算符(- +等等)两边必须有空格 关键点： 注意两个div必须一左一右浮动。 calc的宽度必须要减去的宽度要与固定宽度保持一致。 点击查看示例 关键代码： 123456.right &#123; float: right; width: calc(100% - 200px); // calc计算属性 height: 600px; background-color: lightblue;&#125; flex布局 注意兼容性 关键点： 需要给父级div设置display: flex属性。 固定宽度的div设置flex: 0 0 200px即可。 内容区域的div直接写出flex: 1即可。 点击查看示例 123456789101112131415.main &#123; display: flex;&#125;.left &#123; flex: 0 0 200px; height: 600px; background-color: pink;&#125;.right &#123; flex: 1; height: 600px; background-color: lightblue;&#125; 三栏布局 绝对定位 + 中间版块不给宽度 两侧浮动 + 中间自动撑开（使用 calc 动态计算宽度，设置对应宽度的 margin） flex，左右设置 flex-basis，中间设置 flex-grow flex布局点击查看示例 html 12345 &lt;div class="content"&gt; &lt;div class="left"&gt;im left&lt;/div&gt; &lt;div class="main"&gt;im center&lt;/div&gt; &lt;div class="right"&gt; im right&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718192021*&#123; padding: 0px; margin:0px;&#125;.content&#123; width: 100%; height:300px; display: flex;&#125;.left&#123; background-color: bisque; width: 200px;&#125;.right&#123; background-color:bisque; width: 200px;&#125;.main&#123; flex: 1; background-color: cadetblue;&#125; float布局（两边float，中间自适应）点击查看示例 html 123&lt;div class="left"&gt;left 200px &lt;/div&gt;&lt;div class="right"&gt;right 200px&lt;/div&gt;&lt;div class="center"&gt;center&lt;/div&gt;&lt;!-- 自适应的DIV一定要放在浮动DIV后面 --&gt; css 12345678910111213141516171819202122body &#123; margin: 0px; &#125;.left &#123; float: left; width: 200px; height: 200px; background-color: lightblue;&#125;.right &#123; float: right; width: 200px; height: 200px; background-color: lightblue;&#125;.center &#123; margin-left: 200px; margin-right: 200px; height: 200px; background-color: pink;&#125; 为什么自适应的DIV一定要放在浮动DIV后面？ float布局（float+calc）中间宽度 计算出来 ： calc(100% - 左边宽度+右边宽度） 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Calc三列布局&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; margin: 0px; &#125; .center&#123; float: left; width: calc(100% - 400px); background: #ccc; height: 200px; &#125; .left&#123; float: left; width: 200px; height: 200px; background: red; &#125; .right&#123; float: left; width: 200px; height: 200px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt;left 200px &lt;/div&gt; &lt;div class="center"&gt;center=calc(100%-400px)&lt;/div&gt; &lt;div class="right"&gt;right 200px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; position绝对定位布局点击查看示例 html 12345&lt;div class="mian"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718192021222324body &#123; margin: 0 &#125;.main &#123; width: 100%, height: 500px; position: relative; &#125;.left,.right,.center &#123; position: absolute; &#125;.left &#123; left: 0; width: 200px; height: 500px; background-color: lightblue;&#125;.right &#123; right: 0; width: 200px; height: 500px; background-color: lightblue;&#125;.center &#123; left: 200px; right: 200px; background-color: pink; height: 500px;&#125; 双飞翼布局(margin+float)点击查看示例 圣杯布局中对left盒子设置负内边距-100%的一点解释 参考文章： https://www.jianshu.com/p/81ef7e7094e8]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>布局</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js常用工具类方法（持续更新）]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2Fjs%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 待整理获取URL的查询参数 这个获取URL的查询参数代码，是我见过最精简的 QAQ 12345// ?foo=bar&amp;baz=bing =&gt; &#123;foo: bar, baz: bing&#125;q=&#123;&#125;;location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);q; 生成随机颜色 123// 使用JavaScript简洁代码生成随机十六进制代码'#' + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, '0'); 数组去重 这是一个原生的JS函数但是非常简洁，Set接受任何可迭代对象，如数组[1,2,3,3]，并删除重复项 1[...new Set(arr)]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些不容易注意到的js知识点]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2F%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%AE%B9%E6%98%93%E6%B3%A8%E6%84%8F%E5%88%B0%E7%9A%84js%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[🐰… 1231eN N表示多少个0比如1e5=100000此方法可以用来简写 函数调用也可以用二元表达式简写 简化前： 1`function x() &#123; console.log("x");&#125;function y() &#123; console.log("y");&#125;let z = 3;if (z == 3) &#123; x();&#125; else &#123; y();&#125;` 简化后： 1`function x() &#123; console.log("x");&#125;function y() &#123; console.log("y");&#125;let z = 3;(z == 3 ? x : y)();` 参考： https://mp.weixin.qq.com/s?__biz=MzI5ODM3MjcxNQ==&amp;mid=2247486656&amp;idx=1&amp;sn=33431b4041c06089ac51d00b4dfec462]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML DOM对象（持续更新）]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FHTML%20DOM%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰 … 概述背景 ​ 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 DOM= Document Object Model，文档对象模型，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的常用方法。 有一点很重要，DOM的设计是以对象管理组织（OMG）的规约为基础的，因此可以用于任何编程语言。 最初人们把它认为是一种让JavaScript在浏览器间可移植的方法，不过DOM的应用已经远远超出这个范围 Dom技术使得用户页面可以动态地变化，如可以动态地显示或隐藏一个元素，改变它们的属性，增加一个元素等，Dom技术使得页面的交互性大大地增强。 DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。可以把DOM认为是页面上数据和结构的一个树形表示，不过页面当然可能并不是以这种树的方式具体实现。 通过 JavaScript，您可以重构整个 HTML 文档。您可以添加、移除、改变或重排页面上的项目。 要改变页面的某个东西，JavaScript 就需要获得对 HTML 文档中所有元素进行访问的入口。这个入口，连同对 HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。 DOMDOM 是遵循 W3C（万维网联盟）的标准。 DOM 定义了访问 HTML 和 XML 文档的标准： “W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 XML DOMXML DOM 是： [1] 用于 XML 的标准对象模型 用于 XML 的标准编程接口 中立于平台和语言 W3C 标准 XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法（接口）。 换句话说：XML DOM 是用于获取、更改、添加或删除 XML 元素的标准。 HTML DOMHTML DOM 是： [2] HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准 HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法（接口）。 换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。 HTML DOM 节点 在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 文档对象：文档是一个文档节点。 元素对象：所有的HTML元素都是元素节点。 属性对象：所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。 注释是注释节点。 文档对象当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 ⭐ Document 对象属性和方法 元素对象在 HTML DOM 中, 元素对象代表着一个 HTML 元素。 元素对象 的 子节点可以是, 可以是元素节点，文本节点，注释节点。 NodeList 对象 代表了节点列表，类似于 HTML元素的子节点集合。 元素可以有属性。属性属于属性节点 ⭐ 元素对象 属性和方法 属性对象在 HTML DOM 中, Attr 对象 代表一个 HTML 属性。 HTML属性总是属于HTML元素 ⭐ 属性对象 方法 事件对象HTML DOM 事件允许Javascript在HTML文档元素中注册不同事件处理程序。 事件通常与函数结合使用，函数不会在事件发生前被执行！ (如用户点击按钮)。 ⭐ HTML 事件对象：不同事件对象的属性和方法 内容如果过多，就整理成新的文章 javaScript事件（二）事件处理程序]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GSAP官方文档总结]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%8A%A8%E7%94%BB%2FGSAP%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[🐰… TweenLite/TweenMax 文档 TweenLite/TweenMax 是GreenSock 动画平台中的核心动画工具，可用来构建补间动画(tween)。 官方教程API文档：https://www.tweenmax.com.cn/api/tweenmax/ 补间是flash时代的专业词汇，意思是在起始状态和终点状态之间补全中间过程。 虽然现在我们使用动画这个词，但是其本质是不变的，仍然要包含四个要素：动画目标（target）、起始状态、终点状态、补间效果 例如将一个div从 opacity:1 经过5秒钟降低至 opacity:0 12345TweenLite.fromTo('div', 5, &#123;opacity:1&#125;, &#123;opacity:0&#125;);//动画目标：div//起始状态：opacity:1//终点状态：opacity:0//补间：5秒完成状态改变 起点状态经常可以省略，例如div以当前位置为起点，向右移动300px： 1TweenLite.to('div', 5, &#123;x:300&#125;); 注意：例子中使用的CSS属性动画（opacity、x等）需要CSSPlugin插件支持，此插件包含在TweenMax.min.js中。如果你使用TweenLite.min.js，需另外加载CSSPlugin.min.js。 ⭐TweenLite和TweenMax区别： 我们的API文档大部分以TweenMax为例。如果你使用的是简约版的TweenLite，把TweenMax改为TweenLite即可。 例如 .to() 方法是公用的 12TweenMax.to(obj, 1, &#123;x:100&#125;);TweenLite.to(obj, 1, &#123;x:100&#125;); 我们已经在API上面标明了哪些方法是公用的，哪些是TweenMax独有的 这里是一个简要的列表 术语说明 GSAP GreenSock Animation Platform/GreenSock 动画平台 delayedCalls 延迟执行函数 eventCallback 事件回调函数 tween 动画/补间动画 starting value 起点属性 current values 当前属性 destination values/ending values 终点属性 stagger 错开 ease 时间曲线/速度曲线 timeline 时间轴 TweenLite/TweenMax 动画实例 TimelineLite/TimelineMax 时间轴实例 label 标记/标签 obj/target 动画目标/动画对象 kill 删除/清除/杀死 动画结构 关于设置动画目标和起始、终点状态的动画的结构化方法 官方文档：https://www.tweenmax.com.cn/api/tweenmax/TweenMax() 总结：（具体看文档👆） 方法 描述 TweenMax() TweenMax的构造函数，用来构建一个TweenMax对象。 TweenMax.to() 创建一个从当前属性到指定目标属性的TweenMax动画对象。 TweenMax.from() 通过设置动画起始点来初始化一个TweenMax，相当于动画从设置点开始。 TweenMax.fromTo() 通过设置动画起始点和结束点来初始化一个TweenMax，相当于动画从设置点到第二个设置点。 TweenMax.staggerTo() stagger系列方法为多个目标制作一个有间隔的动画序列，相当于多个TweenMax的数组。需要设置每个动画的开始间隔。如不设置则为零，同时开始动画。 TweenMax.staggerFrom() 通过设定序列动画的终点来初始化一组TweenMax。 TweenMax.staggerFromTo() 通过设定序列动画的起点和终点来初始化一个TweenMax。 TweenMax.delayedCall() 提供一种在设定的时间（或帧）后调用函数的简单方法。 TweenMax.set() 立即设置目标的属性值而不产生过渡动画，相当于0的动画时间。返回TweenMax对象。 动画初始设置 对动画进行一些初始化设置，如重复次数(repeat)缓动方式(ease)等 官方文档：https://www.tweenmax.com.cn/api/tweenmax/delay 总结：（具体看文档👆） 方法 描述 delay 动画开始之前的延迟秒数（以帧为单位时则为帧数）。 ease 过渡效果的速度曲线（缓动效果）。时间曲线Easing paused 如果设置为true，动画将在创建时立即暂停。默认false immediateRender 立即渲染，默认false。（from()方法的运动对象是立即渲染的，默认true） overwrite 用来控制同一个对象上有多个动画时的覆盖之类的情况。 useFrames 当设置为true时，对这个TweenMax对象的时间计算方式基于帧而不是秒，一般帧速约为16.66ms（60帧/秒）。 lazy 延迟渲染（当动画第一次渲染并读取其起始值时，将默认自动“延迟渲染”该特定瞬间） autoCSS 自动识别CSS属性，省略css:{}包装器。默认true。 callbackScope 用于所有回调的范围（onStart，onUpdate，onComplete等）。范围是“this”在任何回调中引用的内容。 repeat 动画在第一次完成后应重复的次数。 repeatDelay 每次重复之间的秒数（或帧）。 yoyo 如果设置yoyo为true，那么重复的动画将往返进行。默认为false。 yoyoEase 定义动画返回时，缓动效果如何，默认false，返回时的缓动效果按照前进时的反转。 startAt 设置动画属性开始时的值 cycle cycle 属性允许在stagger的相关方法中使用循环设定的属性值 动画事件 介绍动画的事件函数，如开始事件(onStart)、结束事件(onComplete)、返回事件(onReverseComplete)等 官方文档：https://www.tweenmax.com.cn/api/tweenmax/onComplete 总结：（具体看文档👆） 方法 描述 onComplete 在动画结束时触发此回调函数。 onCompleteParams 传递给onComplete函数的参数数组 onCompleteScope 定义onComplete函数的作用域，即函数内this的指向。 onReverseComplete 反向播放动画完成时执行此回调函数。 onReverseCompleteParams 传递给onReverseComplete函数的参数数组 onReverseCompleteScope 定义onReverseComplete函数的作用域，即函数内this的指向。 onStart 当动画开始渲染时执行此事件函数，有可能会被执行多次，因为动画是可以重复开始的。 onStartParams 传递给onStart事件函数的参数数组 onStartScope 定义onStart函数的作用域，即函数内this的指向。 onUpdate 当动画发生改变时(动画进行中的每一帧)不停的触发此事件。 onUpdateParams 传递给onUpdate事件函数的参数数组 onUpdateScope 定义onUpdate函数的作用域，即函数内this的指向。 onOverwrite 当一个补间动画被另外一个补间动画覆盖时发生的事件。 onRepeat 在每次动画重复时(repeat)执行此事件函数。 onRepeatParams 传递给onRepeat事件函数的参数数组 onRepeatScope 定义onRepeat函数的作用域，即函数内this的指向。 .eventCallback() 获取或者设置事件，以及应传递给该回调的任何参数。 动画播放组件 介绍动画的事件函数，如开始事件(onStart)、结束事件(onComplete)、返回事件(onReverseComplete)等 官方文档：https://www.tweenmax.com.cn/api/tweenmax/play() 总结：（具体看文档👆） 以下方法大部分都返回self，方便链式调用 方法 描述 .play() 控制动画往正方向播放，可设定开始的时间点。 .pause() 暂停动画，可选择跳转到特定时间。 .paused() 获取或设置动画的暂停状态，该状态指示动画当前是否已暂停。 .restart() 重新开始动画/重头开始。 .resume() 恢复播放而不改变方向（前进或后退），可选择首先跳到特定时间。 .reverse() 控制动画反向播放。动画的各种表现都会反转，例如ease。 .reversed() 获取或设置动画的反转状态，指示是否应该反向播放动画。 .seek() 不改变状态（播放、暂停、方向）的情况下直接跳转到某个时间点。 .timeScale() 获取/设定动画速度，默认为1。如果设置则返回此动画实例便于链式调用。如不设置则返回时间调节比例。 动画属性调整 下面列出了你可以获取到的动画属性以及调整他们的方法，如动画时长（time）、播放进度（progress）等 官方文档：https://www.tweenmax.com.cn/api/tweenmax/duration() 总结：（具体看文档👆） 方法 描述 .duration() 获取或设置动画持续的时间。 .totalDuration() 获取或设定全部重复的动画的持续时间。 .time() 获取或设置当前动画时间。 .totalTime() 获取或设置总的动画时长。 .progress() 获取或者设置单次动画的进程（从0到1） .totalProgress() 获取或者设置总的动画进程（从0到1） .delay() 获取或者设置动画的开始延迟秒数（帧）。 .invalidate() 刷新任何内部记录的开始/结束值，如果您想要重新启动动画而不恢复到以前记录的任何起始值，这将非常有用。 .isActive() 指示动画当前是否处于活动状态 .updateTo() 更新动画的值（当动画正在运行中）updateTo()仅适合改变非插件值 .startTime() 获取/设定动画在其父时间轴上的开始时间。 .endTime() 获取动画在父时间轴上的结束时间。 .repeat() 获取或者设定动画在第一次完成后的重复次数。 .repeatDelay() 获取或者设置每次重复动画之间的间隔时间（秒） .yoyo() 获取或设置补间动画的yoyo的状态。如果你要使用yoyo的话，还需要设置repeat（动画重复次数） 实例属性 介绍TweenLite/TweenMax实例的属性设置，如设置选择器、读取时间轴等 官方文档：https://www.tweenmax.com.cn/api/tweenmax/data 总结：（具体看文档👆） 方法 描述 .data 可用于存储你需要的数据。 TweenLite.defaultEase 用于更改TweenLite默认的缓动方式默认是Power1.easeOut。 TweenLite.defaultOverwrite 设置TweenLite的默认overwrite模式。 默认是&quot;auto&quot;。 TweenLite.onOverwrite 当一个补间动画被另外一个补间动画覆盖时产生的事件函数。 TweenLite.selector 当动画接收字符串作为其目标时使用的选择器引擎 .target 获取动画的目标对象。 .timeline 获取动画的父级时间轴对象（只读）。 .vars 一个存储了传递给构造器的配置变量的对象。包含动画选项和回调函数等。 TweenMax.ticker 设置动画核心引擎，每当引擎update时这个对象将分配tick事件，你可以添加你自己的lisener来运行自定义逻辑（非常适合游戏开发人员） 。 实例方法 介绍TweenLite/TweenMax实例的函数方法，如删除动画、动画渲染 官方文档：https://www.tweenmax.com.cn/api/tweenmax/TweenMax.getTweensOf() 总结：（具体看文档👆） 方法 描述 TweenMax.getTweensOf() 用来获取某个物体上的所有TweenLite、TweenMax对象 TweenMax.getAllTweens() 获取所有动画实例的数组（或时间轴，不包括根时间轴）。 .kill() 消灭整个动画或部分参数。返回self便于链式调用。 TweenMax.killDelayedCallsTo() 立刻杀死所有延迟执行函数。 TweenMax.killTweensOf() 移除指定对象的所有动画（或特定动画属性）或移除延迟执行函数。 TweenMax.killAll() 删除所有补间动画或延迟执行函数或时间轴，可选择强制它们先完成。 TweenMax.killChildTweensOf() 删除/杀死（kill）特定DOM元素的子元素的所有补间动画，可选择强制它们首先完成。 TweenLite.render() 强制渲染所有活动的补间动画。 TweenMax.lagSmoothing() 卡顿平滑补偿机制，当你的动画卡住时平分卡顿的时间使其看起来不是很卡。 TweenMax.globalTimeScale() 用来读取或设置所有动画的全局播放速率，例如1为正常速度，0.5为一半速度，2为2倍速度，能取的最小值为0.0001。 TweenMax.isTweening() 判断一个元素是否处于动画激活状态，返回true或false。元素在时间轴上反方向移动或者加/减速时会出现错判。 TweenMax.pauseAll() 暂停所有动画或时间轴或回调函数。 TweenMax.resumeAll() 恢复运行所有暂停的动画或时间轴或回调函数。 TimeLineMax/TimeLineLite 文档 TimelineLite/TimelineMax是GreenSock 动画平台中的动画组织、排序、管理工具，可创建时间轴（timeline）作为动画或其他时间轴的容器，这使得整个动画控制和精确管理时间变得简单。 官方文档：https://www.tweenmax.com.cn/api/timelinemax/ 我们已经在API上面标明了哪些方法是公用的，哪些是TimeLineMax独有的 该页面的尾部总结了共有和独享的方法 时间轴初始化及动画管理 介绍了创建时间轴及添加删除动画的各种方法 官方文档：https://www.tweenmax.com.cn/api/timelinemax/TimelineMax() 总结：（具体看文档👆） 以下大部分方法：返回该时间轴以便链式调用。 方法 描述 TimelineMax() 构建一个TimelineMax实例，创建时间轴。配置你的TimelineMax，可配置时间轴选项和回调函数等 .add() 向时间轴添加动画、其他时间轴、回调函数或标签（或它们的数组）。 .addCallback() 在特定位置插入回调函数。 .addLabel() 在时间轴上添加一个标记，便于标记重要位置/时间。 .addPause() 在时间轴上添加一个暂停点。 .remove() 从时间轴上移除一个动画、时间轴、函数或标签(或者他们的数组)。 .removeCallBack() 从特定位置移除回调函数。如果没有设置时间点或者标记，则移除所有该回调函数。 .removeLabel() 从时间轴中删除标记。你也可以使用remove()方法来移除。 .removePause() 删除通过TimelineMax.addPause()添加到时间轴的暂停点。 .to() 添加一个TweenLite.to()动画到时间轴，相当于add(TweenLite.to(...)) .from() 添加一个TweenLite.from()动画到时间轴，相当于add(TweenLite.from(...)) .fromTo() 添加一个TweenLite.fromTo()动画到时间轴，相当于add(TweenLite.fromTo(...)) .staggerTo() 为一组目标设定相同的终点变化属性，但是错开一定的时间，创建成一个间隔均匀的动画序列。将此动画序列添加到时间轴。 .staggerFrom() 为一组目标设定相同的起点变化属性，但是错开一定的时间，创建成一个间隔均匀的动画序列。将此动画序列添加到时间轴。 .staggerFromTo() 为一组目标设定相同的起点和终点变化属性，但是错开一定的时间，创建成一个间隔均匀的动画序列。将此动画序列添加到时间轴。 .set() 将零持续时间的动画添加到时间轴的末尾（或使用“位置”参数的其他位置）立即设置值（当虚拟播放头到达时间轴上的该位置时）。这是一种方便的方法，可以完成同样类似于 add( TweenLite.to(target, 0, {...}) )的事情，但代码较少。 时间轴初始设置 对时间轴进行一些初始化设置，如重复次数(repeat)缓动方式(ease)等 官方文档： 总结：（具体看文档👆） 方法 描述 delay 时间轴动画开始之前的延迟秒数（或帧数）。restart() 无视delay。 paused 如果设置为true，时间轴将在创建时立即暂停。默认false useFrames 当设置为true时，这个时间轴的时间模式基于帧而不是秒，一般帧速约为16.66ms（60帧/秒）。 tweens 要将多个动画一起插入时间轴，可使用tweens属性，这比使用add()要简洁。你可以将此选项与align 和stagger 属性结合使用，以使用最少的代码设置复杂序列。 stagger 仅与tweens属性一起使用。它将tweens内的动画错开了一定的秒数（或帧），默认值为0。 align 仅与tweens属性一起使用，设置tweens内的动画的对齐方式，默认为”normal”。 autoRemoveChildren 如果设置为true，则一旦子动画/时间轴完成，它们将自动被移除。 这通常是不可取的，因为子动画可以防止时间后退（如果您想要reverse()或将进度设置得更低等等）。但是，它可以提高速度和内存管理。默认设置是：false（除了根时间轴）。 smoothChildTiming 控制是否自动重新定位子动画/时间轴（更改其startTime），以便在动态更改属性时保持平滑播放。 repeat 动画在第一次完成后应重复的次数。要无限重复，请使用-1。 repeatDelay 每次repeat之间的秒数（或帧）。 yoyo 如果设置yoyo为true，那么重复的动画将往返进行。默认为false。 callbackScope 用于所有回调的范围（onStart，onUpdate，onComplete等）。范围是“this”在任何回调中引用的内容。 时间轴事件 介绍了时间轴的事件函数，如开始事件(onStart)、结束事件(onComplete)、返回事件(onReverseComplete)等 官方文档：https://www.tweenmax.com.cn/api/timelinemax/onStart 总结：（具体看文档👆） 方法 描述 onStart 时间轴播放组件 常用的时间轴播放组件，如播放（play）、暂停（pause）、重新播放（restart）等 官方文档：https://www.tweenmax.com.cn/api/timelinemax/play() 总结：（具体看文档👆） 方法 描述 .tweenTo() 创建一个线性动画，将时间轴播放到特定时间或标签，然后停止。 .tweenFromTo() 创建一个线性动画，将时间轴从某时间或标签播放到指定时间或标签，然后停止。 时间轴属性调整 列出了你可以获取到的时间轴属性以及调整他们的方法，如时间轴时长（time）、播放进度（progress） 官方文档：https://www.tweenmax.com.cn/api/timelinemax/delay() 总结：（具体看文档👆） 方法 描述 .endTime() 获取时间轴的结束时间。 .startTime() 获取或设置某个动画在其父时间轴上的起始时间 实例属性 介绍了TimelineLite/TimelineMax实例的属性设置，如设置数据、读取父时间轴等 官方文档：https://www.tweenmax.com.cn/api/timelinemax/.autoRemoveChildren 总结：（具体看文档👆） 方法 描述 .autoRemoveChildren 如果设置为true，则子动画/时间轴在完成时会被自动移除（默认为false，除了根时间轴）。 .smoothChildTiming 控制是否自动重新定位子动画/时间轴（更改其startTime），以便在动态更改属性时保持平滑播放。 .timeline 获取父时间轴，所有的动画都依附于时间轴（默认是根时间轴），并只能有一个父时间轴 实例方法 介绍了TimelineLite/TimelineMax实例的函数方法，导出时间轴、清空时间轴等 官方文档：https://www.tweenmax.com.cn/api/timelinemax/call() 总结：（具体看文档👆） 方法 描述 .call() 在时间轴的末尾（或position位置）增加一个回调函数，作用类似于add( TweenLite.delayedCall(...) ) .clear() 清空时间轴的所有动画，时间轴和回调函数（以及标签）。不会清除事件回调（如onComplete, onUpdate, onStart等）如果你想清除可使用eventCallback()方法，如myTimeline.eventCallback(&quot;onComplete&quot;, null);。 .currentLabel() 获取当前时间或之前最接近的label标记，或跳转到指定的label标记。如跳转则返回self（便于链式调用）。 .eventCallback() 获取或设置一个事件，以及应传递给该回调事件的任何参数。 TimelineMax.exportRoot() 将全部动画、时间轴、函数（可选）从根时间轴导出至新的时间轴便于执行一些高级操作，并且不影响导出后创建的动画/时间轴。 .getActive() 返回时间轴中当前处于活动状态的动画/时间轴，这意味着时间轴的播放头位于子动画/时间轴上，并且子项未暂停。 .getChildren() 返回一个数组，其中包含嵌套在此时间轴中的所有动画和时间轴。 .getLabelAfter() 返回time参数后面的下一个标签（如果有）。可配合tweenTo()使时间轴动画至该标记。 .getLabelBefore() 返回在time参数之前发生的上一个label标记（如果有）。 可配合tweenTo()使时间轴动画至该标记。 .getLabelsArray() 返回一个标记对象数组，按时间轴中出现的顺序排列，每个标记对象有“time”和“name”属性。 .getLabelTime() 返回特定标记的时间位置。 .getTweensOf() 返回此时间轴内特定对象的动画（TweenLite和TweenMax）。 .invalidate() 刷新任何内部记录的开始/结束值，如果您想要重新启动动画而不恢复到以前记录的任何起始值，这将非常有用。 .isActive() 指示动画当前是否处于活动状态（意味着播放头在此实例的时间范围内正在活动，并且未暂停，也不是其任何祖先时间轴）。 .kill() 根据参数完全或部分kill时间轴。 .recent() 返回最近添加的子动画/时间轴/回调函数，无论其在时间轴中的位置如何。 .shiftChildren() 将此时间轴的子项的开始时间（startTime）移动一定秒数或帧。当你想在某个点插入动画，将已存在的动画后移以腾出位置给新动画时，可以考虑使用此方法。 .useFrames() 如果为true，则时间线的计时模式是基于帧而不是秒。]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>动画</category>
      </categories>
      <tags>
        <tag>GSAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GreenSock动画平台（GSAP）学习笔记]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%8A%A8%E7%94%BB%2FGreenSock%E5%8A%A8%E7%94%BB%E5%B9%B3%E5%8F%B0%EF%BC%88GSAP%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[🐰… 优秀文章 符号表示目前是否看完 GSAP - 专业的 Web 动画库 ✔ TweenMax 中文使用说明 ✖ GreenSock组成简介组成在官网选择Download zip就可以拿到GSAP源码，解压后可以看到有这些文件： 这里的 TweenLite.js、TweenMax.js、TimelineLite.js 和 TimelineMax.js 4个文件就是GSAP的一般引用库文件 这4个文件分别包含了什么东西呢？ TweenLite ：是GSAP的主体核心，它用于创建基本动画，是其他各类模块的基础。一般都会搭配 plugins/CSSPlugin 以实现DOM元素的动画（也就是我们最熟悉的动画了）。 TimelineLite ：是一个叫做时间轴的动画容器，它用于对多个动画进行有序的组织与控制。 TimeLineMax ：是 TimelineLite 的升级版，在 TimelineLite 的基础之上，可以有更高级的组织与控制。 TweenMax ：是GSAP集合包，除前面3个之外，还包括 plugins 里的常用插件以及 easing 里的缓动函数补充。 ⭐ 一张图说明GSAP动画平台四个插件的不同功能 关系不过，这几个文件还有一些重叠和包含的关系，如下图： GSAP在Customize里是这样描述自己拥有的模块的： 默认勾选的 TweenLite + css plugin 是最简单的应用组合 使用建议 如果想要简单地引入GSAP的主体功能，使用 TweenMax.js 这一个文件即可（请看第一张图中反映出的这个文件的大小）。 而如果要争取更小的库文件大小，应该使用 TweenLite.js（必需）+ 其他文件的组合。 学习提示TweenMax 是 TweenLite 的升级版，拥有其全部特性，只是增加了一些额外的高级控制。它们的语法完全一致，使用时用全局搜索把所有 TweenLite 替换成 TweenMax ，不会有任何影响。TimelineMax 和 TimelineLite 的关系也是如此。 （但是将Max替换成原本的要注意是否是Max中特有的语法） 所以： 我们直接学习 TweenMax 和 TimelineMAX 就可以了 后面的实际运用篇我们只选择了 TimelineMax ，但是第一次学习使用，建议还是先大概学一下 TweenMax 再学习 TimelineMax 原因：因为 TweenLite 是整个GSAP最基础的部分，先理解这一部分对于后面的学习也能快速上手，并且可以理解得更加充分 GSAP学习文档最好的学习方式就是去将官方的两篇文档大概过一遍，然后再实际上手练习 TweenMax中文手册 TimelineMax中文手册 我在第一遍学习阅读的时候，对相关API进行了总结 实际运用为什么选择TimelineLite？好像 TweenLite + css plugin 就已经足够用了，这个Timeline系列是做什么的呢？ 想象你是一个动画的导演，你要按剧本安排演员在一个CUT里依次上场和退场。在 TweenLite 里，我们只有一个演员（#ball1），但现在，我们要拍一个有20+演员的动画大片，要怎么办呢？ 你也许曾用css3的 animation 做过类似的事情，做法是，当转换到一个场景（CUT）后，为场景里的所有演员依次设定适当的 delay 。只要 delay 计划好，看起来就是漂亮精彩的大片。 不过，这可没有那么简单，假如你已经安排好了20位演员的上场时间，现在改了下剧本，来了第21位演员要在最开始上场，你会发现你可能要依次调整在它之后的所有演员的delay… GSAP的 TweenLite 也会有同样的问题，因此，我们需要有一个工具来统一管理多个元素的多个动画 如果你做过视频编辑，你一定很熟悉“时间轴”这个概念。简单来说，每一个元素的单次动画都是一段素材，我们需要把它们分别放置到同一个时间轴的适当位置，才能集合在一起得到有序的动画大片。 这就是TimelineLite。 然后通过上面两者官方API文档的总结我们可以发现，几乎所有 TweenLite 常用的API方法都可以在 TimelineLite 中找到。 而且明显的如果两者结合使用还不如只用 TweenlineLite 更加简便。 如下面的例子： 添加一个TweenLite.to()动画到时间轴，相当于add(TweenLite.to(...))，以下两行产生相同的结果： 12345// 两者结合使用myTimeline.add( TweenLite.to(element, 1, &#123;left:100, opacity:0.5&#125;) );// 只使用TweenlineLitemyTimeline.to(element, 1, &#123;left:100, opacity:0.5&#125;); 所以，目前我的实际运用中主要只使用了 TimelineLite 来实现动画效果（暂时我的使用过程中还未发现有什么单独用TimelineLite不行，而结合TweenLite可以的例子。如果有会再次更新进行相关的说明） animate和TweenlineMax的区别？从上一节的分析我们就可以看得出来，这两者的区别除了一个是js一个是css之外和上面 TweenLite 和TimelineLite 的区别很像，主要是后者引入了时间轴的概念 下面我们来看分别用两种方法实现的例子 多个元素相同的动画：多个文字实现向下渐隐出现的效果 tips：如果👇的示例没有出现，请多刷新几次或者直接点击标题链接进行查看（右上角可以查看源码） animate的实现方式 从上面示例可以看出，主要只添加了HTML部分的代码 TweenlineMax中的实现方式 从上面示例可以看出，主要只添加了JS部分的代码 总结从上面代码我们可以看出 一个只添加了HTML代码的类名，一个只添加了js的方法 当只对单个（同时或者不考虑连续时间）不同的元素添加动画时，用animate比较方便 当对多个相同的元素添加动画时，用GSAP比较方便（可以通过js一次性获得所有相同元素的dom，然后一次性添加动画） 当对多个元素（无论是否相同），需要引入时间轴（或者时间比较复杂时），使用GSAP animate只能通过延迟来把控时间，如果时间元素过多，不好把控 而且容易出现“如果需要在开头新添一个元素的动画，可能需要修改全部元素的延迟时间”这种麻烦的事情 两种相互转换如果你想使用animate中的动画效果，可以分析animate的源码，找到相应动画的 keyframe 即可以将其转换成GSAP动画的模式（上面的实例就是根据这个方法实现的） 因为本质上两者都是用css3实现的动画，原理是相同的 项目顺序在实际运用中，一定要切记一点！ 我们最好是先把整个页面的最终排版布局样式都完成了再来进行相关的动画。千万不能一边布局一边进行动画，这样的话，如果其中某步的布局有问题需要调整，可能会影响整个动画结果。 下面是我建议的一个流程顺序： 对页面进行排版布局（包括细节的css样式） 确定整个页面时间轴的动画，梳理出一个大概顺序 通过以上顺序，（最好）先确定好一些必须要添加标记的地方，以及该标记先后的动画 大概有这样一幅图在脑海中或者草稿先画出来 最后再书写具体的动画 创建dom元素从上面建议的项目顺序第一步，如果dom元素相对较少，就不需要采取下面的方式。 如果页面拥有特别多的dom元素（比如页面上有二三十个小球同时运动），那么这种建议使用js来进行创建dom 因为使用GSAP一般会默认引入jQuery，所以请善用jQuery来创建大量的dom元素！这样可以节省很多手写dom标签的时间。 并且对后面直接操控dom元素来添加动画也更加利于理解 常用的方法1234567891011// 这个就不必解释了吧？创建动画的第一步var tl = new TimelineMax(); // 适用于样式需要变化时tl.fromTo(元素, 时长, &#123;初始样式&#125;, &#123;最终样式&#125;, "标记名字或者相对时间（不填默认上个动画结尾处）") // 使用于简单的动画（最终还是回归初始样式）模仿animate的样式很多可以用这个方法tl.from(元素, 时长, &#123;初始样式&#125;) .to(".gold", 0.5, &#123;scale: 0.7&#125;).addLabel("label1") 常用初始设置12345&#123; repeat: true, // 动画在第一次完成后应重复的次数 yoyo: true // 如果设置yoyo为true，那么重复的动画将往返进行。默认为false delay: 时长 // 时间轴动画开始之前的延迟秒数（或帧数&#125; CSSPlugin常用具体查看CSSPlugin文档 width, height, margin, padding, top, left transforms (rotation, scaleX, scaleY, skewX, skewY, x, y, rotationX, and rotationY), colors, opacity 等 alpha, autoAlpha, transformOrigin,className 1234567891011tl.fromTo(元素, 时长, &#123;初始css样式&#125;)&#123; scale: 1, // 大小 opacity: 0, top,bottom,left,right // 绝对定位 x,y // 相当于CSS3的translateX和translateY xPercent: 10%, // 水平方向位移，以百分比为单位 rotation: 10, // 旋转，相当于CSS3的rotate，默认是角度deg &#125; 一些注意点.play()的补充说明 由于序列动画（staggerTo()等）分解成了一个个动画，因此不能简单的使用tween动画的play()控制。可将序列动画添加至时间轴，再使用timeline的play()方法来播放。 动画结束后清空style属性默认情况下，执行过动画的元素会留下style的内联样式，如果你担心这可能造成额外影响，可以设定clearProps参数清空它： 12345TweenLite.to("#ball1", 2, &#123; x: 200, clearProps: "all", autoAlpha: 0&#125;); 如果只需要清理个别样式，单独写出来即可，如clearProps: &quot;opacity&quot;。 指定默认缓动如果你大部分动画都使用同一种缓动函数，那么用TweenLite.defaultEase会很方便，比如修改为Expo.easeOut： 1TweenLite.defaultEase = Expo.easeOut; 实例DEMO 这节所有的demo都是用的实际运用里所说的模式 参考文章： https://segmentfault.com/a/1190000005366176 http://svgtrick.com/book/greensock/]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>动画</category>
      </categories>
      <tags>
        <tag>GSAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端编程规范]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%2F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E5%92%8C%E8%A7%84%E8%8C%83%2F%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[🐰目前编程中自己首选的一些规范 待看文章 使用sass进行模块化的7-1模式 前端开发规范：命名规范、html规范、css规范、js规范 CSS 目前书写css所用的预处理器为：sass 规范选择的是： 使用Sass来写OOCSS CSS 12345678910111213141516171819202122232425/* 好的方式 */%btn &#123; min-width: 100px; padding: 1em; border-radius: 1em;&#125;%twitter-bg &#123; color: #fff; background: #55acee;&#125;%facebook-bg &#123; color: #fff; background: #3b5998;&#125;.btn &#123; &amp;-twitter &#123; @extend %btn; @extend %twitter-bg; &#125; &amp;-facebook &#123; @extend %btn; @extend %facebook-bg; &#125;&#125; 编译结果： 1234567891011121314151617@charset "UTF-8";/* 好的方式 */.btn-facebook, .btn-twitter &#123; min-width: 100px; padding: 1em; border-radius: 1em;&#125;.btn-twitter &#123; color: #fff; background: #55acee;&#125;.btn-facebook &#123; color: #fff; background: #3b5998;&#125; HTML中使用 12&lt;div class="btn-twitter"&gt;&lt;/div&gt;&lt;div class="btn-facebook"&gt;&lt;/div&gt; CSS命名 参考几种设计规范的思想，目前采取的是OOCSS结合SMACSS命名（语法基于sass） 使用规范利用OOCSS思想来提取公共类 12345678// 可以分成几大类// 这类数字的可以用sass的循环语法一次性生成.mt20 &#123; margin-top: 20px &#125;.tc &#123; text-align: center &#125;.abs &#123; position: absolute &#125;.clearfix:after &#123; content: ‘’; display: block; clear: both; height: 0 &#125; 利用SMACSS思想来给具体的dom命名 123456789101112131415161718// 某个页面的dom.index &#123; &amp;-top &#123; &#125; &amp;-middle &#123; &#125; &amp;-bottom &#123; &#125;&#125;// 自定义可复用的dom样式（此处利用@extend再次复用公共类）.btn-red &#123; @extend .btn; color: red;&#125; 对于一些状态类的样式有两种方法 12345678// 直接定义在公共类中（这个适用于该状态样式能多次复用的情况）.active &#123;&#125;// 在类名中体现 （这个状态很少使用的时候）.btn-red-active &#123; @extend .btn-red // 该状态的样式代码&#125; OOCSS面向对象的CSS，主要思想是 “结构和设计的分离，容器和内容的分离”简单的说就是抽象公共类，把复用度高的样式抽取出来，例如： 1234.mt20 &#123; margin-top: 20px &#125;.tc &#123; text-align: center &#125;.abs &#123; position: absolute &#125;.clearfix:after &#123; content: ‘’; display: block; clear: both; height: 0 &#125; SMACSS可扩展和模块化结构 CSS 的一个简称。主要目标是 减少代码量，简化代码的维护。在整个系列中，包括了base，modules，staes，themes。修饰符使用的是–，子模块使用__符号。 Base 基本规则，整体样式，比如 body、input、button、form Layout 布局规则，比如 顶部，页脚，边栏，模块的大小等 Module 可复用的模块样式规则 State 状态样式 比如 隐藏 当前高亮 Theme 主题 控制整体UI BEMBEM 是一种前端项目开发的方法学，由 Yandex 公司提出。BEM 的名称来源于该方法学的三个组成部分的英文首字母，分别是块（Block）、元素（Element）和修饰符（Modifier）。这三个不同的组成部分称为 BEM 实体。 Block——块 块即是通常所说的 Web 应用开发中的组件或模块。每个块在逻辑上和功能上都是相互独立的。块中封装了组件相关的 JavaScript、CSS 代码和 HTML 模板。由于块是独立的，可以在应用开发中进行复用，从而降低代码重复并提高开发效率。块可以放置在页面上的任何位置，也可以互相嵌套。 Element——元素 元素是块中的组成部分。元素不能离开块来使用。BEM 不推荐在元素中嵌套其他元素。 Modifier——修饰符 修饰符用来定义块或元素的外观和行为。同样的块在应用不同的修饰符之后，会有不同的外观。 1234// 简单地说.block &#123; /* styles */ &#125;.block__element &#123; /* styles */ &#125; .block--modifier &#123; /* styles */ &#125; 举个栗子 如何使用呢BEM命名方法呢？请先看以下例子： 123456//我们要为这个菜单写样式&lt;ul class=""&gt; &lt;li class=""&gt;Menu Item 1&lt;/li&gt; &lt;li class=""&gt;Menu Item 2&lt;/li&gt; &lt;li class=""&gt;Menu Item 3&lt;/li&gt;&lt;/ul&gt; “祖传”命名 放在以前，我们或许会这么写： 12345&lt;ul class="nav"&gt; &lt;li class="item selected"&gt;Menu Item 1&lt;/li&gt; &lt;li class="item"&gt;Menu Item 2&lt;/li&gt; &lt;li class="item"&gt;Menu Item 3&lt;/li&gt;&lt;/ul&gt; 看了一下，还是多清爽的。但是各位朋友是否注意到了一个问题：子元素item和其父元素menu，从命名上看，关系似乎太不紧密。一个box也可以有item子类，一个xxx也可以包含一个item子类。看看其样式的写法： 123456789101112131415161718192021//sass.nav &#123; list-style: none; .item &#123; font-weight: bold; &amp;.selected &#123; color: red; &#125; &#125; &#125; //编译后产生的css.nav &#123; list-style: none;&#125;.nav .item &#123; font-weight: bold;&#125;.nav .item.selected &#123; color: red;&#125; 从样式文件上看，仿佛也没有太大问题，但是，这是在我们代码层数较少的情况。如果是一个复杂的页面元素，我们sass层级会非常深。编译后的css，层级也会很深。 BEM命名 现在我们使用BEM再来编写看看： 12345678910111213141516171819202122232425262728&lt;ul class="nav"&gt; &lt;li class="nav__item nav__item--selected"&gt;Menu Item 1&lt;/li&gt; &lt;li class="nav__item"&gt;Menu Item 2&lt;/li&gt; &lt;li class="nav__item"&gt;Menu Item 3&lt;/li&gt;&lt;/ul&gt;//sass.nav &#123; list-style: none; &amp;__item &#123; font-weight: bold; &amp;--selected &#123; color: red; &#125; &#125;&#125;//使用sass编译后的css是.nav &#123;//菜单 list-style: none;&#125;.nav__item &#123;//菜单item font-weight: bold;&#125;.nav__item--selected &#123; //被选中的菜单item color: red;&#125; 乍看之下，根据 BEM 命名规则产生的 CSS 类名都会很复杂，但实际上在熟悉了命名规则之后，可以很容易理解其含义。其次，css不再存在复杂的层级关系，浏览器渲染的时候，样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出，减少层级就能提升性能，对应静态css文件大小也会减少。 很多人会吐槽两个下划线和两个横杠作为连接符，并不优雅。但是我觉得，BEM是一种思想，是我们需要理解的，至于我们用什么样的连接符，什么样的方式实现，可以根据自己项目的情况考虑。 参考文章： https://segmentfault.com/a/1190000012633974]]></content>
      <categories>
        <category>前端</category>
        <category>经验总结和规范</category>
      </categories>
      <tags>
        <tag>🍓无🍓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue风格指南阅读笔记和总结]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2Fvue%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[🐰…]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS异步函数]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJS%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[🐰… 待整理文章 深入理解 promise：promise的三种状态与链式调用 只整理了第一节，后面的看不懂（等之后深入理解之后再继续看） [Javascript] Promise ES6 详细介绍 .catch() .all() Generator 异步 同步与异步我们知道，JavaScript的执行环境是「单线程」。所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。但实际上还有其他线程，如事件触发线程、ajax请求线程等。 这也就引发了同步和异步的问题。 同步同步模式，即上述所说的单线程模式，一次只能执行一个任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「线程阻塞」。 1234/* 例2.1 */var x = true;while(x);console.log("don't carry out"); //不会执行 上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。 异步下面就来看看异步模式。异步模式，即与同步模式相反，可以一起执行多个任务，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。最常见的异步模式就数定时器了，我们来看看以下的例子。 12345678910/* 例2.2 */setTimeout(function() &#123; console.log('taskA, asynchronous');&#125;, 0);console.log('taskB, synchronize');//while(true);-------ouput-------taskB, synchronizetaskA, asynchronous 我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，异步任务会在当前脚本的所有同步任务执行完才会执行。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。 回调函数提起异步，就不得不谈谈回调函数了。回调函数是实现异步的一种方式 上例中，setTimeout 里的 function 便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。以下是WikiPedia对于callback的定义。 In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. 可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。 WikiPedia同时提到 The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. 也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。 在同步调用下，回调函数一般是最后执行的。 而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。 同步回调1234567891011121314151617181920var fun1 = function(callback) &#123; //do something console.log("before callback"); (callback &amp;&amp; typeof(callback) === 'function') &amp;&amp; callback(); console.log("after callback");&#125;var fun2 = function(param) &#123; //do something var start = new Date(); while((new Date() - start) &lt; 3000) &#123; //delay 3s &#125; console.log("I'm callback");&#125;fun1(fun2);-------output--------before callback//after 3sI’m callbackafter callback复制代码 由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。 异步回调上一小节中 setTimeout 就是常见的异步回调，另外常见的异步回调即ajax请求。 12345678910111213141516function request(url, param, successFun, errorFun) &#123; $.ajax(&#123; type: 'GET', url: url, param: param, async: true, //默认为true,即异步请求；false为同步请求 success: successFun, error: errorFun &#125;);&#125;request('test.html', '', function(data) &#123; //请求成功后的回调函数，通常是对请求回来的数据进行处理 console.log('请求成功啦, 这是返回的数据:', data);&#125;,function(error) &#123; console.log('sorry, 请求失败了, 这是失败信息:', error);&#125;); 回调地狱上面的ajax异步回调，如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？ 12345678910111213141516request('test1.html', '', function(data1) &#123; console.log('第一次请求成功, 这是返回的数据:', data1); request('test2.html', data1, function (data2) &#123; console.log('第二次请求成功, 这是返回的数据:', data2); request('test3.html', data2, function (data3) &#123; console.log('第三次请求成功, 这是返回的数据:', data3); //request... 继续请求 &#125;, function(error3) &#123; console.log('第三次请求失败, 这是失败信息:', error3); &#125;); &#125;, function(error2) &#123; console.log('第二次请求失败, 这是失败信息:', error2); &#125;);&#125;, function(error1) &#123; console.log('第一次请求失败, 这是失败信息:', error1);&#125;); 以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。也被称作为回调地狱 为了解决这种状况，在ES6中引入了 promise ，在ES7中引入了更为优雅的 async/await 比如，用 promise 改写上述例子 123456789101112sendRequest('test1.html', '').then(function(data1) &#123; console.log('第一次请求成功, 这是返回的数据:', data1); return sendRequest('test2.html', data1);&#125;).then(function(data2) &#123; console.log('第二次请求成功, 这是返回的数据:', data2); return sendRequest('test3.html', data2);&#125;).then(function(data3) &#123; console.log('第三次请求成功, 这是返回的数据:', data3);&#125;).catch(function(error) &#123; //用catch捕捉前面的错误 console.log('sorry, 请求失败了, 这是失败信息:', error);&#125;); promise什么是 Promise 呢？以下是MDN对 Promise 的定义 The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn’t completed yet, but is expected in the future. 译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 三种状态用new Promise实例化的Promise对象有三个状态： “has-resolution” - Fulfilled 代表操作成功 reslove(成功时)，调用 onFulfilled “has-rejection” - Rejected 代表操作失败 reject(失败时)。调用 Rejected “unresolve” - Pending 初始值 既不是 resolve 也不是 reject 状态，也就是 Promise 刚刚被创建后的初始化状态。 note： 在Chrome中输出 resolve 可以得到 Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}可以看出 [[PromiseStatus]] 中存储的就是 Promise 的状态，但是并没有公开访问 [[PromiseStatus]] 的用户API所以暂时还无法查询其内部状态。 注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一 Promise 中的 then 的回调只会被调用一次 Promise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。 一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。 当状态发生变化，promise.then绑定的函数就会被调用。 Promise 的状态只会从 Pending 变为 Fulfilled 或者 Rejected ，不可逆，所以 then 只会被调用一次 基本用法 resolve 函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 一个简易的promise例子: 123456let promiseDemo = new Promise((resolve, reject) =&gt; &#123; /* 异步操作成功 */ resolve('success') /* 异步操作失败 */ reject('failed') &#125;) promise的最终状态会凝固，成功了以后即便再执行 reject(&#39;failed&#39;) 状态也不会改变。 上述例子相当于 12345678let promiseDemo = new Promise((resolve, reject) =&gt; &#123; if (/* 异步操作成功 */) &#123; resolve(data); &#125; else &#123; /* 异步操作失败 */ reject(error); &#125;&#125;) Promise实例生成以后，可以用 then 方法指定 resolved 状态和 reject 状态的回调函数。 1234567promise.then(onFulfilled, onRejected);promise.then(function(data) &#123; // do something when success&#125;, function(error) &#123; // do something when failure&#125;); then 方法会返回一个Promise。它有两个参数，分别为Promise从 pending 变为 fulfilled 和 rejected 时的回调函数（第二个参数非必选）。这两个函数都接受Promise对象传出的值作为参数。 简单来说，then 就是定义 resolve 和 reject 函数的，其 resolve 参数相当于： 123function resolveFun(data) &#123; //data为promise传出的值&#125; 而新建Promise中的 resolve(data) ，则相当于执行 resolveFun 函数。 Promise新建后就会立即执行。而 then 方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。如下例： 1234567891011121314151617181920var promise = new Promise(function(resolve, reject) &#123; console.log('before resolved'); resolve(); console.log('after resolved');&#125;);promise.then(function() &#123; console.log('resolved');&#125;);console.log('outer');-------output-------before resolvedafter resolvedouterresolved// 很明显可以看出：before resolved 和 after resolved 的输出顺序并不受 resolve() 的影响// 而是直接执行 由于 resolve 指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印’resolved’ 基本API.then()语法：Promise.prototype.then(onFulfilled, onRejected) 对promise添加 onFulfilled 和 onRejected 回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的 resolve 函数。 因此，我们可以使用链式写法，如回调地狱中的例子 由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 .catch()语法：Promise.prototype.catch(onRejected) 该方法是 .then(undefined, onRejected) 的别名，用于指定发生错误时的回调函数 具体查看 .all()语法：Promise.all(iterable) 该方法用于将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.all([p1, p2, p3]); 有时候需要多个彼此没有关联的多个异步任务全部执行完成后再执行后面的操作，这时候就需要用到Promise.all() 它接收一个Promise的对象的数组作为参数，当这个数组里的所有Promise对象全部变成 resolve 或者 reject 的时候，它才会去调用后面的 .then() 这里需要说明一点，两个彼此无关的异步操作会同时执行，每个Promise的结果（即每个返回的Promise的resolve或reject时传递的参数）和传递给 Promise.all 的 Promise数组 的顺序一致。也就是说，假设有两个异步操作TaskA和TaskB，如果传入顺序为 Promise.all([TaskA,TaskB]) ，则执行完成后传给 .then的顺序为 [TaskA,TaskB] 1234567891011 function setTime(time)&#123; return new Promise((resolve)=&gt;&#123; setTimeout(()=&gt;resolve(time),time); &#125;) &#125;let startTime = Date.now();Promise.all([setTime(1),setTime(100),setTime(200)]) .then((value)=&gt;&#123; console.log(value); //[1,100,200] console.log(Date.now() - startTime); //203 &#125;); 从上面函数的输出值可以看出 Promise.all() 里的异步操作是同时执行的而且传给 .then() 的，顺序和 Promise.all() 里的顺序一样。 最终执行时间约为200ms，为什么不是200ms，这里涉及到关于 setTimeout 的精准问题，具体原因查看 .race()语法：Promise.race(iterable) Promise.rance() 的用法与 Promise.all() 类似，不同的地方在于 Promise.all() 是在接收到的所有Promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理 而 Promise.race() 只要有一个Promise对象进入 FullFilled 或者 Rejected 状态，就会继续进行后续处理 这相当于 Promise.all() 进行且运算 而 Promise.rance() 进行或运算 但是这里有一点需要注意一下： 1234567891011121314151617181920212223var taskA = new Promise(function (resolve) &#123; setTimeout(function () &#123; console.log('this is taskA'); resolve('this is taskA'); &#125;, 4);&#125;);var taskB = new Promise(function (resolve) &#123; setTimeout(function () &#123; console.log('this is taskB'); resolve('this is taskB'); &#125;, 1000);&#125;);Promise.race([winnerPromise, loserPromise]).then(function (value) &#123;console.log(value); &#125;); /* 输出结果：this is taskAthis is taskAthis is taskB*/ 从这里可以看出，在第一个Promise变为 FulFiled 状态运行 then 里的回调后，后面的Promise并没有停止运行，而是接续执行。 也就是说， Promise.race 在第一个promise对象变为 Fulfilled 之后，并不会取消其他promise对象的执行。 .resolve()语法： Promise.resolve(value); Promise.resolve(promise); Promise.resolve(thenable); 它可以看做 new Promise() 的快捷方式。 123456Promise.resolve('Success');/*******等同于*******/new Promise(function (resolve) &#123; resolve('Success');&#125;); 这段代码会让这个Promise对象立即进入 resolved 状态，并将结果 success 传递给 then 指定的 onFulfilled 回调函数。由于 Promise.resolve() 也是返回Promise对象，因此可以用 .then() 处理其返回值。 12345678910111213141516171819// Resolving an valuePromise.resolve('success').then(function (value) &#123; console.log(value);&#125;);-------output-------Success// Resolving an arrayPromise.resolve([1,2,3]).then(function(value) &#123; console.log(value[0]); // =&gt; 1&#125;);// Resolving a Promisevar p1 = Promise.resolve('this is p1');var p2 = Promise.resolve(p1);p2.then(function (value) &#123; console.log(value); // =&gt; this is p1&#125;); Promise.resolve() 的另一个作用就是将 thenable 对象（即带有 then 方法的对象）转换为 promise 对象。 123456789101112var p1 = Promise.resolve(&#123; then: function (resolve, reject) &#123; resolve("this is an thenable object!"); &#125;&#125;);console.log(p1 instanceof Promise); // =&gt; truep1.then(function(value) &#123; console.log(value); // =&gt; this is an thenable object! &#125;, function(e) &#123; //not called&#125;); 再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成 resolved 或 rejected ，状态不会再改变，这和新建promise是一样的。 1234567891011121314151617181920212223242526272829//在回调函数前抛异常var p1 = &#123; then: function(resolve) &#123; throw new Error("error"); resolve("Resolved"); &#125;&#125;;var p2 = Promise.resolve(p1);p2.then(function(value) &#123; //not called&#125;, function(error) &#123; console.log(error); // =&gt; Error: error&#125;);//在回调函数后抛异常var p3 = &#123; then: function(resolve) &#123; resolve("Resolved"); throw new Error("error"); &#125;&#125;;var p4 = Promise.resolve(p3);p4.then(function(value) &#123; console.log(value); // =&gt; Resolved&#125;, function(error) &#123; //not called&#125;); promise传递参数在Promise的链式调用中，有可能各个task之间存在相互依赖，例如TaskA想给TaskB传递一个参数，像下面这样： 123456789101112131415161718192021222324252627282930313233343536373839/*例1.使用Promise.resolve()启动*/let task1 = (value1)=&gt;value1+1;let task2 = (value2)=&gt;value2+2;let task3 = (value3)=&gt;&#123;console.log(value3+3)&#125;;Promise.resolve(1).then(task1).then(task2).then(task3);//console =&gt; 7/*例2.普通的返回一个Promise*/function task1(value1)&#123; return new Promise((resolve,reject)=&gt;&#123; if(resolve)&#123; resolve(value1+1); &#125;else&#123; throw new Error("throw Error @ task1"); &#125; &#125;);&#125;function task2(value2)&#123; return new Promise((resolve,reject)=&gt;&#123; if(resolve)&#123; resolve(value2+2); &#125;else&#123; throw new Error("throw Error @ task1"); &#125; &#125;);&#125;function task3(value3)&#123; return new Promise((resolve,reject)=&gt;&#123; if(resolve)&#123; console.log(value3+3); &#125;else&#123; throw new Error("throw Error @ task1"); &#125; &#125;);&#125; task1(1).then(task2).then(task3);//console =&gt; 7 关于 reslove 与 reject 有以下两点说明： reslove 函数的作用是将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去； reject 函数的作用是将Promise对象状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去； 所以从上面的例子和它们的用法可以看出，如果想要传递给后面task有两种方法： 如果使用 Promise.resolve() 启动Promise，则像例1中那样在需要传递的参数前面加 return 即可。 如果是利用Promise包装了任务，则把想要传递给下一个task的参数传入 resolve() 即可。 特别说明：如果需要 resolve() 往后传递多个参数，不能直接写 resolve(a1,a2,a3)，这样只能拿到第一个要传的参数，需要以数组或对象去传递 12345let obj = &#123;a1:a1,a2:a2,a3:a3&#125;;resolve(obj)//orlet arr =[a1,a2,a3];resolve(arr); 常见问题then与catch返回新的Promise 在Promise中无论是then还是catch方法，都会返回返回一个新的Promise对象，而 then 内部只是返回的数据 1234567891011var aPromise = new Promise(function(resolve) &#123; resolve(100)&#125;)var thenPromise = aPromise.then(function(value) &#123; console.log(value)&#125;)var catchPromise = thenPromise.catch(function(error) &#123; console.error(error)&#125;)console.log(aPromise !== thenPromise) // =&gt; true console.log(thenPromise !== catchPromise); // =&gt; true 所以可以查看下面两个例子的区别 1234567891011121314151617181920212223242526272829//方法1：对同一个promise对象同时调用 then 方法var p1 = new Promise(function (resolve) &#123; resolve(100);&#125;);p1.then(function (value) &#123; return value * 2;&#125;);p1.then(function (value) &#123; return value * 2;&#125;);p1.then(function (value) &#123; console.log("finally: " + value);&#125;);-------output-------finally: 100//方法2：对 then 进行 promise chain 方式进行调用var p2 = new Promise(function (resolve) &#123; resolve(100);&#125;);p2.then(function (value) &#123; return value * 2;&#125;).then(function (value) &#123; return value * 2;&#125;).then(function (value) &#123; console.log("finally: " + value);&#125;);-------output-------finally: 400 第一种方法中，then 的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。 reject和异步操作error的区别12345678910111213141516function ReadEveryFiles(file)&#123;return new Promise((resolve,reject)=&gt;&#123; if(resolve)&#123; fs.readFile(`$&#123;__dirname&#125;/jQuery/$&#123;file&#125;`,(err,data)=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; let obj = &#123;data:data,file:file&#125;; resolve(obj); &#125; &#125;); &#125;else&#123; //promise reject error &#125; &#125;);&#125; 这里的readFile的error和Promise的reject不一样，一个是readFile过程中导致的错误，而另一个是Promise做处理的时候导致的错误可以这样理解，假设读取文件成功了，但是Promise还需要讲这个异步操作得到的数据拿到处理，在Promise做这些操作的时候可能出错。 reject和catch的区别 promise.then(onFulfilled, onRejected)在 onFulfilled 中发生异常的话，在 onRejected 中是捕获不到这个异常的。 promise.then(onFulfilled).catch(onRejected).then 中产生的异常能在 .catch 中捕获 一般情况，还是建议使用第二种，因为能捕获之前的所有异常。 当然了，第二种的 .catch() 也可以使用 .then() 表示，它们本质上是没有区别的.catch === .then(null, onRejected) GeneratorGenerator 异步 总结基本流程总结一下创建promise的流程： 使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象 在fn中指定异步的处理处理结果正常，调用resolve处理结果错误，调用reject 如果使用ES6的箭头函数，将会使写法更加简单清晰。 总结实现JS异步编程的方法主要有： 回调函数 promise async/await Generator 其他：参考文章 Javascript异步编程的4种方法 （其他里面没总结到的两种不是很常用，所以没有在此处总结） 不同方式的优缺点回调函数（callback）123setTimeout(() =&gt; &#123; // callback 函数体&#125;, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 123456789ajax('XXX1', () =&gt; &#123; // callback 函数体 ajax('XXX2', () =&gt; &#123; // callback 函数体 ajax('XXX3', () =&gt; &#123; // callback 函数体 &#125;) &#125;)&#125;) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） PromisePromise就是为了解决callback的问题而产生的。 Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装 优点：解决了回调地狱的问题 12345678910ajax('XXX1') .then(res =&gt; &#123; // 操作逻辑 return ajax('XXX2') &#125;).then(res =&gt; &#123; // 操作逻辑 return ajax('XXX3') &#125;).then(res =&gt; &#123; // 操作逻辑 &#125;) 缺点：无法取消 Promise ，错误需要通过回调函数来捕获 Generator特点：可以控制函数的执行，可以配合 co 函数库使用 123456789function *fetch() &#123; yield ajax('XXX1', () =&gt; &#123;&#125;) yield ajax('XXX2', () =&gt; &#123;&#125;) yield ajax('XXX3', () =&gt; &#123;&#125;)&#125;let it = fetch()let result1 = it.next()let result2 = it.next()let result3 = it.next() Async/awaitasync、await 是异步的终极解决方案 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 1234567async function test() &#123; // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3')&#125; 下面来看一个使用 await 的例子： 12345678let a = 0let b = async () =&gt; &#123; a = a + await 10 console.log('2', a) // -&gt; '2' 10&#125;b()a++console.log('1', a) // -&gt; '1' 1 对于以上代码你可能会有疑惑，让我来解释下原因 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。 参考文章： https://www.jianshu.com/p/dc61ea153874 https://www.jianshu.com/p/4e6be72236d6 https://juejin.im/post/5cc3c54751882525166c4636 https://github.com/sisterAn/blog/issues/29]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识体系]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%2F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E5%92%8C%E8%A7%84%E8%8C%83%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[🐰… 知识体系图 （cr：水印）]]></content>
      <categories>
        <category>前端</category>
        <category>经验总结和规范</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx知识点总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%90%8E%E5%8F%B0%2FNginx%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… nginx在应用程序中的作用 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。 下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。 为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？ 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 基本配置配置结构下面是一个nginx配置文件的基本结构： 12345678910111213141516171819202122232425# nievents &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main: nginx的全局配置，对全局生效。 events: 配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域先追本溯源以下，跨域究竟是怎么回事。 定义跨域的定义 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义 如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 nginx解决跨域的原理例如： 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在前端 fe.server.com 对后台 dev.server.com 发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器： 将 server_name 设置为 fe.server.com 然后设置相应的 location 以拦截前端需要跨域的请求 最后将请求代理回 dev.server.com 如下面的配置： 1234567server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略： fe.server.com 访问 nginx 的 fe.server.com 属于同源访问 而 nginx 对服务端转发的请求不会触发浏览器的同源策略。 请求过滤 根据状态码过滤 12345error_page 500 501 502 503 504 506 /50x.html; location = /50x.html &#123; # 将跟路径改编为存放html的路径。 root /root/static/html; &#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 123location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。 123if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 配置gzip GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。 对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。 并不是每个浏览器都支持gzip的，如何知道客户端是否支持gzip呢，请求头中的Accept-Encoding来标识对压缩的支持。 启用gzip同时需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了,我们可以通过nginx的配置来让服务端支持gzip。下面的respone中content-encoding:gzip，指服务端开启了gzip的压缩方式。 12345gzip on;gzip_http_version 1.1; gzip_comp_level 5;gzip_min_length 1000;gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml; gzip 开启或者关闭gzip模块 默认值为off 可配置为on / off gzip_http_version 启用 GZip 所需的HTTP 最低版本 默认值为HTTP/1.1 这里为什么默认版本不是1.0呢？ HTTP 运行在TCP 连接之上，自然也有着跟TCP 一样的三次握手、慢启动等特性。 启用持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。 HTTP/1.1默认支持TCP持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于TCP持久连接上的HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有Content-Length。而在HTTP/1.1中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。 nginx同样有着配置chunked的属性chunked_transfer_encoding，这个属性是默认开启的。 Nginx在启用了GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出Content-Length这个响应头部。 所以，在HTTP1.0中如果利用Nginx启用了GZip，是无法获得Content-Length的，这导致HTTP1.0中开启持久链接和使用GZip只能二选一，所以在这里gzip_http_version默认设置为1.1。 gzip_comp_level 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 默认值为 1 压缩级别取值为1-9 gzip_min_length 设置允许压缩的页面最小字节数，Content-Length小于该值的请求将不会被压缩 默认值:0 当设置的值较小时，压缩后的长度可能比原文件大，建议设置1000以上 gzip_types 要采用gzip压缩的文件类型(MIME类型) 默认值:text/html(默认不压缩js/css) 负载均衡什么是负载均衡 如上面的图，前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。 把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡Upstream指定后端服务器地址列表 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 1234567server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 123456upstream balanceServer &#123; least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 123456upstream balanceServer &#123; fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。 123456upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器123456location ~* \.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 小结nginx的功能非常强大，还有很多需要探索，上面的一些配置都是公司配置的真实应用（精简过了），如果您有什么意见或者建议，欢迎在下方留言… 此处只是一个总结整理，非原创，原文来自： https://segmentfault.com/a/1190000018454271]]></content>
      <categories>
        <category>后台</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue使用记录（持续更新）]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%89%8D%E7%AB%AF%2FVue%2FVue%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰总结实际应用中vue的一些小技巧 未分类利用路由嵌套来实现【整个布局不改变，只改变主体内容】的效果链接 初始化时执行watch中的方法 详情 性能优化小技巧 能用v-show的地方就不要用v-if，善用keep-alive和v-once，Object.freeze()处理 vue big data 问题等 css样式相关未分类 可以利用 vue的 computed() 计算属性 来给 :style:&quot;计算属性名字&quot; 内联样式动态绑定一个css对象方法 因为计算属性得到的是 一个方法返回的值 可以在这个方法中根据不同的情况返回不同的值，达到动态绑定的效果 深度选择器 当子组件使用了scope，但在父组件中又想修改子组件的样式时，可以使用深度选择器 &gt;&gt;&gt; 来实现 123&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; 将会编译成 123.a[data-v-f3f3eg9] .b &#123; /* ... */&#125; 所以你想覆盖某个特定页面 element 的 button 的样式，你可以这样做： 123.xxx-container &gt;&gt;&gt; .el-button&#123; xxxx&#125; 在scss等预处理器中 &gt;&gt;&gt; 可能不生效，可以使用 /deep/ 代替 1234&lt;style lang="scss" scoped&gt;/deep/ &#123; // 放你想修改的类样式&#125; ssh://git@ops-gitlab.jrj.cn:62222/genius/broswer-web.git 动画相关 一个dom中同时显示和隐藏 存在两个动画 参考 Popup.vue 组件中的处理方式：利用 setTimeout() 来使两个动画都能得以实现 transition-group 与 &lt;transition&gt; 的不同：&lt;transition-group&gt; 会给里面遍历的每一个item都添加一个class动画类 api文档 列表过渡教程 具体应用案例：ebook书架 DOM相关关于vue 的 this.$refs 打印为undefined解决办法 1如果写在method中，那么可以使用 this.$nextTick(() =&gt; &#123;&#125;) 等页面渲染好再调用 表单相关Vue.js 表单 实例 vuejs使用FormData对象，ajax上传图片文件 数据相关未分类修改对象或数组中的键，视图未发生变化$set()使用 $set 方法修改 官方文档详情 123456789101112131415161718192021222324252627282930&lt;script&gt; export default&#123; data() &#123; return &#123; item: &#123; title: '222' &#125;, options: [11, 22], list: [ &#123; title: '2222' &#125; ] &#125; &#125;, created() &#123; /* 对于对象，第一个为要修改的对象，第二个参数为对象的键，第三个为要修改的键对应的值 */ this.$set(this.item, 'title', '2200'); /* 对于对象，第一个为要修改的数组，第二个参数为数组索引，第三个为要修改的索引对应的值 */ this.$set(this.options, 0, 33); /* 对于数组里包含对象，可以利用循环对其进行修改 */ this.list.forEach(item =&gt; &#123; this.$set(item, '_disableExpand', true); &#125;); /* 对于数组里包含对象，也可以利用Object.assign对其进行修改 */ this.list[0] = Object.assign(&#123;&#125;, this.list[0], &#123; num: 10 &#125;); this.$set(this.list, 0, this.list[0]); &#125;, &#125;&lt;/script&gt; $forceUpdata() 也可以直接进行修改后对页面进行强制刷新，使用 $forceUpdate() 方法 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 12this.options[0] = 100;this.$forceUpdate(); vuex结合localStorage 合理运用vuex结合localstorage动态监听storage的变化 需求： 不同组件间共用同一数据，当一个组件将数据发生变化时，其他组件也可以响应该变化。 分析： vue无法监听localstorage的变化。localstorage主要用于不同页面间传值，vue适合组件间传值。对于组件间共用同一数据又想保存住信息或者再页面刷新的时候不丢失数据（vuex在页面刷新的时候存储的值会丢失，localstorage存储在本地浏览器中），可以采用vuex+localstorage的方式。 区别： 1.最重要的区别：vuex存储在内存，localstorage则以文件的方式存储在本地 2.应用场景：vuex用于组件之间的传值，localstorage则主要用于不同页面之间的传值。 3.永久性：当刷新页面时vuex存储的值会丢失，localstorage不会。 注：很多同学觉得用localstorage可以代替vuex, 对于不变的数据确实可以，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。 指令相关 `@keyup.enter.exact=”search()” ` ：此处的 exact 表示只有按了 enter 键才会触发事件（不能组合按键） 过滤器全局过滤器和本地过滤器官方文档 12345678910111213// 全局Vue.filter('filterName', function (value) &#123; // 数据处理 return ....&#125;)// 本地filters: &#123; filterName: function (value) &#123; // 数据处理 return .... &#125;&#125; 格式化时间利用插件Moment.js 123456filters: &#123; formDate: function(val) &#123; if (!val) return '' return moment(val, 'YYYYMMDD').format('YYYY-MM-DD') &#125;,&#125;, 组件相关未分类 vue公共组件：使用 插槽 的标签来达到组件复用 插槽 :is 点击不同的标签切换组件 12345678910111213141516171819202122&lt;component :is="tab"&gt;&lt;/component&gt;&lt;script&gt; data() &#123; return &#123; tab: 传入已注册组件的名字 // 可以点击标签修改tab的值达到切换组件 &#125; &#125;&lt;/script&gt;如果只有两个标签&lt;component :is="currentTab === 1 ? content : bookmark"&gt;&lt;/component&gt;&lt;script&gt;data() &#123; return &#123; currentTab: 1, content: EbookSlideContents, bookmark: EbookSlideBookmark &#125;&#125;&lt;/script&gt; 刷新当前组件 这个方法相比 this.$router.go(0) 而言不会出现白屏，用户体验比较好 html 1&lt;router-view v-if="isRouterAlive" /&gt; method 1234567// 刷新当前页面reloadPage() &#123; this.isRouterAlive = false this.$nextTick(function () &#123; this.isRouterAlive = true &#125;)&#125;, vue组件之间通信的方式props和$emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的 八种方式：https://blog.csdn.net/lyr190/article/details/88355949 路由相关vue 监听路由变化 可复用性 &amp; 组合插件相关 插件通常用来为 Vue 添加全局功能。 官方文档：https://cn.vuejs.org/v2/guide/plugins.html 插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者属性 添加全局资源：指令/过滤器/过渡等 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 开发插件1234567891011121314151617181920212223242526272829export default &#123; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125; &#125;&#125; 使用插件1234567// 在main.js中// 引入文件import MyPlugin from './utils/MyPlugin'// 使用插件Vue.use(MyPlugin)]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iframe优缺点和使用总结（持续更新）]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2Fiframe%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 基本概念和使用基本属性1&lt;iframe src="demo.html" height="300" width="500" name="demo" scrolling="auto" sandbox="allow-same-origin"&gt;&lt;/iframe&gt; src iframe页面地址，有同域跨域之分 height iframe高度 width iframe宽度 name iframe命名，可通过window.frames[xxx]被调用 scrolling iframe滚动模式 sandbox html5新特性，用于限制iframe的功能 基本使用我们可以通过 contentWindow 和 contentDocument 两个API获取iframe的window对象和document对象。 123let iframe = document.getElementById('demo');let iwindow = iframe.contentWindow; // 获取iframe的window对象let idoc = iframe.contentDocument; // 获取iframe的document对象 刚刚我们提到了iframe的name属性，我们也可以通过 window.frames[iframeName] 来调用iframe。 1let iframe = window.frames['demo'] 获取父级对象 我们通过window.self，window.parent，window.top这三个属性分别获取自身window对象，父级window对象，顶级window对象。 1234iframe1.self === iframe1 // 自身window对象iframe2.parent === iframe1 // 父级window对象iframe1.parent === windowiframe1.top === window // 顶级window对象 同域/跨域基本概念什么是同域什么跨域咧？同域跨域的区别在哪咧？我们一般会使用iframe来进行父子页面的通信，然鹅父子页面是否同域决定了它们之间能否进行通信。 js遵循同源策略，即同协议，同域名，同端口号，否则都算跨域。 同源策略 是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。实际上，这种策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 跨域 简单的来说，指的是两个资源非同源。（三个中有一个不同就算）出于安全方面的考虑，页面中的JavaScript在请求非同源的资源时就会出 跨域问题 ——即跨域请求，这时，由于同源策略，我们的请求会被浏览器禁止。也就出现了 我们常说的 跨域 问题。 iframe跨域通讯之document.domain对于主域相同子域不同的两个页面，我们可以通过document.domain + iframe来解决跨域通信问题。 举个🌰，网页a(http://www.easonwong.com)和网页b(http://script.easonwong.com)，两者都设置document.domain = &#39;easonwong.com&#39;（这样浏览器就会认为它们处于同一个域下），然后网页a再创建iframe上网页b，就可以进行通信啦～！ 网页a 123456789document.domain = 'easonwong.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.easonwong.com';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; let doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html&#125;; 网页b 1document.domain = 'easonwong.com'; iframe跨域通讯之postMessagepostMessage 是html5的新特性，具体介绍不在此赘述。 postMessage介绍 MDN postMessage 兼容性 IE8以上 can I use 我们可以通过html5这个新特性进行iframe间的跨域通信 使用 postMessage 进行数据传递 通过 Message 监听通信事件。举个🌰 网页a 1234567document.domain = 'easonwong.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.easonwong.com';ifr.style.display = 'none';document.body.appendChild(ifr);// 发送数据ifr.postmessage('hello, I`m a', 'http://script.easonwong.com'); 网页b 123456789// 监听message事件window.addEventListener('message', receiver, false);function receiver(e) &#123; if (e.origin == 'http://www.easonwong.com') &#123; if (e.data == 'hello, I`m a') &#123; e.source.postMessage('hello, I`m b', e.origin); // 信息 &#125; &#125;&#125; iframe优缺点优点 iframe能够把嵌入的网页原样展现出来； 模块分离，便于更改，如果有多个网页引用iframe，只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷； 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，增加代码的可重用； 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决； 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页； 方便制作导航栏。 缺点 样式和脚本需要额外链入，调用外部页面,需要额外调用css,增加页面额外的请求次数，增加服务器的http请求 代码复杂，在网页中使用框架结构最大的弊病是搜索引擎的“蜘蛛”程序无法解读这种页面，会影响搜索引擎优化，不利于网站排名 框架结构有时会让人感到迷惑，滚动条除了会挤占有限的页面空间外会使iframe布局混乱，还会分散访问者的注意力，影响用户体验 链接导航疑问。运用框架结构时，必须保证正确配置所有的导航链接，否则，会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者陷住了，因为此时他没有其他地点可去； 产生多个页面，不易管理 多数小型的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 为什么尽量少用iframeiframes提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。iframe的创建比其它包括scripts和css的 DOM 元素的创建慢了1-2个数量级。 使用iframe的页面一般不会包含太多iframe，所以创建DOM节点所花费的时间不会占很大的比重。 但带来一些其它的问题：onload事件以及连接池(connection pool)，即： iframe会阻塞主页面的Onload事件 iframe和主页面共享连接池，会影响页面的并行加载。 iframes阻塞页面加载，影响网页加载速度 及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload事件加载延迟后，它给用户的感觉就是这个网页非常慢。 window的onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发，就会影响网页加载速度。 通过 JavaScript 动态设置 iframe的SRC可以避免这种阻塞情况。 唯一的连接池 对每个 web 服务器来说，浏览器只打开极少的几个连接数。老的浏览器，包括 IE 6/7 和 Firefox 2，每个主机只有2个连接。在新的浏览器中，连接数增加了。Safari 3+和Opera 9+增至4个，Chrome 1+、IE 8及Firefox 3增至6个。 在大多数浏览器中，连接被主页面和它的 iframe所共享，这意味着有可能iframe中的资源占用了可用连接而阻塞了主页面的资源加载。如果iframe中的内容同等重要，或比主页面更重要，这很好。然而在通常情况下iframe中的内容对页面来说不太重要，iframe 占用连接数是不可取的。 一个解决方案是在优先级更高的资源下载完成后再动态的给iframe的src赋值。 总之，iframe会给你的页面性能带来冲击，尽可能不使用iframe，当确实需要时，谨慎地使用他们。目前框架的优点可以使用Ajax实现，这在某种角度也是一种替代方案。 iframe的应用场景iframe的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent的CSS或者全局的JavaScript的影响。 异步请求 在很久很久很久以前，久到ajax还没出现的时候，人们会用iframe来进行异步请求。大概就是异步创建iframe，然后后台返回数据在iframe中，我们在从里面获取数据。 例如在我做过的一个项目中，通过iframe.src传入一个文件下载地址，实现无需打开新窗口下载文件。 典型的，比如所见即所得的网页编辑器 跨域通信。JavaScript跨域总结与解决办法 ，类似的还有浏览器多页面通信，比如音乐播放器，用户如果打开了多个tab页，应该只有一个在播放 历史记录管理，解决ajax化网站响应浏览器前进后退按钮的方案，在html5的history api不可用时作为一种替代 纯前端的utf8和gbk编码互转。比如在utf8页面需要生成一个gbk的encodeURIComponent字符串，可以通过页面加载一个gbk的iframe，然后主页面与子页面通信的实现转换 用iframe实现无刷新文件上传，在FormData不可用时作为替代方案 创建一个全新的独立的宿主环境。iframe还可以用于创建新的宿主环境，用于隔离或者访问原始接口及对象，比如有些前端安全的防范会覆盖一些原生的方法防止恶意调用，通过创建一个iframe，然后从iframe中取回原始对象和方法来破解这种防范； 用来加载广告，例如联盟广告 一般邮箱使用iframe，如QQ邮箱 一些简单的后台页面。 需要独立样式和带有交互的内容，例如幻灯片 sandbox沙箱隔离 参考文章： https://blog.csdn.net/baxiadsy_csdn/article/details/86245809 https://www.jianshu.com/p/7ec986aa28a7]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>🐰未分类🐰</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[⭐Cynthia 的五月记录⭐]]></title>
    <url>%2F2019%2F05%2F05%2F%E3%80%90%E6%AF%8F%E6%9C%88%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%2F2019-05%2F</url>
    <content type="text"><![CDATA[🐰… 阅读技术文章 💔：此处只总结较为优秀的文章（大部分已过滤） ✖：表示看了但未整理的 ⭐：表示正在看，还没看完的 ✔：表示看了，不需整理或已整理的文章 第一周（5.5-5.12） vue-element-admin 后台模板官方使用文档 ✔ 全面分析前端的网络请求方式 ✔ iframe相关 ✔ 浅谈iframe的优缺点及应用场景 深入浅出iframe - 简书 vue路由和复用组件的解决办法 ✖ vue刷新当前路由：router-view 复用组件时不刷新的3种解决方案总结 ✖ router-view 组件的 key 和 Vue-Router 的 beforeRouteUpdate ✖ 利用:key来复用组件 ✖ 前端开发者必备的Nginx知识 ⭐（待看待整理啊） 看和整理到请求过滤 在vue中使用NProgress.js ✖ js同步和异步 ✖（纠结下到底整理在面试题详解中还是知识点的文章分配） JavaScript 运行机制详解：再谈Event Loop 理解 JavaScript 中的 macrotask 和 microtask setTimeout、Promise、Async/Await 手摸手，带你用vue撸后台 系列五(v4.0新版本) 圣杯布局和双飞翼布局的理解与思考 ✖（还没看完） 第二周（5.13-5.19） 2019前端工程师自检清单与思考 ✔ （感观：菜鸟前端的前路还很遥远） [Javascript] Promise ES6 详细介绍 ✔ 数组去重 JavaScript数组去重（12种方法，史上最全） ⭐（还没看完） ES6数组去重的最佳实践 ✔ HTTP 状态码对照表 ✖ 第三周（5.20-5.26） 前端流行趋势（最新技术了解） 一图看懂编程语言迁移模式：终点站是Python、Go、JS ✔ 框架的游戏：2019 年 JavaScript 流行趋势 ✔ 前端开发者手册2019 ✔ 每个前端工程师都应该了解的图片知识 ✖ CSS3 中关于 -of-type 和 -child的差异性及适用场景 ✖ 整理下css3的选择器总结 前端框架Vue（11）——Vue+表单验证 VeeValidate 实践 ✔ [译]学习如何去学习 JavaScript - 5 个你应该如何花在学习 JS 上时间的建议 ✔ cookie和token ✔ Cookie和Token cookie和token的五点区别 Cookie 还是Token，这是一个问题 JSON Web Token 入门教程 JWT Token存储在Cookie还是LocalStorage 基础知识巩固 一些基础知识（可能之前已经整理过的），碎片知识积累巩固 JSparseInt()1234567parseInt(string, radix);// radix：一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。// 当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。// 返回解析后的整数值。 // 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。 Arguments 对象arguments 是一个对应于传递给函数的参数的类数组对象。 数组方法Array.prototype.map()123456789101112131415// map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。// 语法var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])// 具体参数含义看链接// callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。// 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。// 如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。// map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。 Array.prototype.flat()1234567// 语法var newArray = arr.flat(depth)// depth 可选// 指定要提取嵌套数组的结构深度，默认值为 1// 返回一个包含将数组与子数组中所有元素的新数组 主要用于 扁平化嵌套数组 和 扁平化与空项 （具体查看链接详情） Array.from()1234// Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例// 可以把类数组对象(array-like obj)和可迭代对象(iterable objects -- eg:Map or Set)转为常规数组具体看链接 Array.prototype.concat()123// concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组具体看链接 Array.prototype.sort()12// sort() 方法用原地算法对数组的元素进行排序，并返回数组。// 排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。 对数组中的数字进行排序 123456789101112var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);也可以写成：var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =&gt; a - b); // 记住这个方法！！console.log(numbers);// [1, 2, 3, 4, 5] Array.prototype.reduce()123// reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。具体太复杂了，看链接吧 Array.prototype.indexOf()CSS 不定时的总结一下使用的css属性，加深记忆和理解 animation动画 动画属性 主要是 @keyframes 123@keyframes animationname &#123; // 关键帧名字 keyframes-selector &#123;css-styles;&#125; // 动画持续的时间比（也可以填入from或to）&#125; animation 1234567animation: 1name 2duration 3timing-function 4delay 5iteration-count 6direction 7fill-mode 8play-state;// 依次填入动画属性的：// 1名字、2时间、3周期函数（如具体的函数或者ease等）、4动画开始前的延迟间隔、5播放次数// 6是否应该轮流反向播放动画// 7规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式// 8指定动画是否正在运行或已暂停 background背景 背景属性 重点： background 1234567891011background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;// 背景颜色// 背景图片、背景图片的位置，背景图片的大小、背景图片是否重复// bg-image：可以同时设置多张图片，前者会覆盖后者// bg-origin：背景图片的的定位区域（padding-box|border-box|content-box）// bg-clip：背景图像的绘画区域// bg-attachment：设置背景图像是否固定或者随着页面的其余部分滚动// 常用示例：background: url('xxx/xx.jpg') center contain(或者数值和百分比) no-repeat; transition过渡 过渡属性 transition 123456transition: property duration timing-function delay;// 需要改变的css属性名称 持续时间 效果函数 延迟时间// 示例：transition: width 3s ease 1s; animation和transition的区别https://segmentfault.com/a/1190000019115237 transform变换 2D/3D转换属性 123456789transform: none|transform-functions;// 可以填入的变换函数有：// 1.matrix系列：定义转换，使用矩阵// 2.translate系列：定义转换，使用轴// 3.scale系列：定义缩放转换// 4.rotate系列：定义旋转// 5.skew系列：定义倾斜转换（拉伸）// 6.perspective：为 3D 转换元素定义透视视图 flex布局 弹性盒子模型 flex 1flex: flex-grow flex-shrink flex-basis|auto|initial|inherit; jQuery遍历 jQuery 遍历 - each() 方法 jQuery 遍历 - find() 方法 jQuery 遍历 - first() 方法 jQuery 遍历 - siblings() 方法 jQuery 文档操作 - prependTo() 方法 jQuery 属性操作 - attr() 方法 jQuery 效果 - slideToggle() 方法 Vue.js 不定时查阅文档巩固的基础知识 未分类 事件处理 事件修饰符 按键修饰符 系统修饰键 自定义事件 123456&lt;el-input v-model="search" placeholder="搜索商家或地点" @focus="focus" @blur="blur" @input="input"/&gt; 用自定义事件绑定方法更加清楚直观 watch watch：文档 实例$watch()：文档 watch 一个对象 键 是需要观察的表达式 值 是对应回调函数。值也可以是方法名，或者包含选项的对象。 Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 $watch参数参数： {string | Function} expOrFn 方法名/函数表达式 {Function | Object} callback 回调函数 {Object} [options] 包含选项的 对象 {boolean} deep {boolean} immediate $watch() 选项 deep 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 immediate 在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调 示例12345678910111213141516171819202122232425262728293031323334353637383940414243var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; // 1.函数表达式 a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 2.方法名 b: 'someMethod', // 3.该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 4.该回调将会在侦听开始之后被立即调用 d: &#123; handler: 'someMethod', immediate: true &#125;, // 5.不同的调用模式 e: [ 'handle1', function handle2 (val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;, /* ... */ &#125; ], // watch vm.e.f's value: &#123;g: 5&#125; 'e.f': function (val, oldVal) &#123; /* ... */ &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1 interview-question第1题（JavaScript函数深入理解） [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt) what &amp; why ? 解析1 解析2 第2题（JS事件循环及异步机制） setTimeout、Promise、Async/Await 判断下面的输出顺序 123456789101112131415161718192021222324252627// 今日头条面试题async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function () &#123; console.log('settimeout')&#125;)async1()new Promise(function (resolve) &#123; console.log('promise1') resolve()&#125;).then(function () &#123; console.log('promise2')&#125;)console.log('script end') 答案 12345678script startasync1 startasync2promise1script endasync1 endpromise2settimeout ⭐详细分析可以看： 第3题（数组操作，js高阶函数运用） 将一个多重数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 1Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; a-b) 解析以上可以分步总结为以下步骤： 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 123456789var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]// 1.扁平化let flatArr = arr.flat(4)// 2.去重let disArr = Array.from(new Set(flatArr))// 3.排序let result = disArr.sort((a, b) =&gt; a - b)console.log(result)// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 拍平数组：const flatArray = arr =&gt; arr.reduce((a,b) =&gt; a.concat(Array.isArray(b) ? flatArray(b): b), []); 去重+排序: […new Set(flatArray)].sort((a,b) =&gt; a-b); 相关知识点 Array.prototype.flat() Set Array.from() Array.prototype.sort() 本月计划目标 备注：这个目标设定开始于五月中旬 🍉：表示当前进行中 JS原理 JS异步机制 总结和整理 JS事件机制 总结和整理 JS原型和原型链 总结和整理 框架和插件 element-ui 框架学习和使用 🏦 大致看一下官方文档 vue-element-admin 后台框架学习和使用 🏦 把基础文档和教程大致看一遍 当前计划：把👆看的过程中总结的疑问解决 Swiper 触摸滑动插件学习使用 🍉 模仿年报速览项目的模板 简易轮播图 研究demo（制定日后的相关学习计划） GSAP Web动画库学习使用 🏦 TweenMax 和 TimelineMax 文档通读 相关技术文章和 实战demo经验总结 CSShexo博客优化博客样式 优化分类页，可以展开折叠父级分类 优化归档页：增加月份分割线 置顶文章 增加背景壁纸（原理根据之前分类页的列表样式来） 迁移旧博客文章工具构建工具 gulp学习使用 将公司项目中曾经使用过gulp的项目整理出一个模板（可多次使用的） Vue 写简单的权限验证的demo（和文章记录） 项目实战 美团网实战项目（vue+node+koa2+nuxtjs+ssr）]]></content>
      <categories>
        <category>每月记录和总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mockjs模拟数据技巧总结（持续更新）]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2Fmockjs%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 官方文档：https://github.com/nuysoft/Mock/wiki 实时演示：http://mockjs.com/0.1/editor.html 例子demo演示：http://mockjs.com/examples.html mock工具使用RAP2和Mock.JS实现Web API接口的数据模拟和测试 （可以前后端一起写模拟接口） 阿里妈妈 RAP2 github easy-mock 相关文章 代码demohttp://rap2.taobao.org/repository/editor?id=162580&amp;mod=238378&amp;itf=884374 json格式对象数组1234567891011121314// mock代码var data = Mock.mock(&#123; 'categorys|3-5': [&#123;&#125;]&#125;)//生成&#123; "categorys": [ &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125; ]&#125;]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http中的跨域问题总结（持续更新）]]></title>
    <url>%2F2019%2F04%2F30%2FHTTP%E7%BD%91%E7%BB%9C%2Fhttp%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 待看文章 不要再问我跨域的问题了 前端常见跨域解决方案（全） 跨域总结 解决方案cors cors全称为 Cross Origin Resource Sharing（跨域资源共享） 这种方法对于前端来说和平时发请求写法上没有任何区别，工作量基本都在后端这里 原理： 每一次请求浏览器必须先以 OPTIONS 请求方式发送一个预请求=&gt;获知服务器端对跨源请求所支持 HTTP 方法。 在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。 前端解决方案但总有后端觉得cors麻烦不想这么搞。那前端也是有解决方案的 在 dev 开发模式下： 使用webpack 的 proxy 使用也是很方便的看一下文档就会使用了，个人项目可以采用这个方法 在生产环境下： 使用Nginx反向代理 总结 开发环境 生产环境 cors cors proxy nginx 参考文章： https://segmentfault.com/a/1190000010043013#articleHeader9]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git基本命令（持续更新）]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%B7%A5%E5%85%B7%2FGit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… Git 手册 VSCode Git 操作 操作面板中英文对照 Vim命令 vi-vim ：删除、撤销、恢复删除、复制删除 Git flow不同的模式Git flow有很多，从简单到复杂，没有绝对的标准，选择适合自己的就好： 如果整个项目只有你一个人，在一个master分支上玩就可以 如果项目有多人合作，且master分支总是可以跟线上环境吻合，使用master分支+branches开发。 如果项目有多人合作，并且master分支并不一定跟线上环境吻合，使用master分支+production分支+branches开发。 方案二 https://www.cnblogs.com/windchen/p/6290685.html 主代码在master分支上 要对代码做的任何一个改动，无论是开发功能，修复bug，均从master分支开新的branch 代码完成，发pull/merge request，如果有CI，此时会跑test脚本，通过之后，reviewers会来评审你的代码，期间可能需要你再对code做一些修改 完成之后，代码被合并至master分支，如果有CI，会自动部署到stage（QA）环境 创建分支1234567891011121314# 在实际多人合作开发过程中，无论是开发功能或者修复bug# 均需先获取远程master分支最新代码，再创建branch$ git checkout master$ git pull origin master$ git checkout -b [branch-name]# 首先 git add，避免新添加的文件无法加入储藏$ git add# 将暂存区中的文件提交到本地版本库$ git commit -m "修改消息....."# 将分支推送到远程仓库$ git push origin [branch-name] 合并分支 为什么要使用git pull –rebase？ 1234567891011121314# 此时这个branch的代码还不在master分支中，在提交merge request之前# 要先合并master分支的最新代码到当前分支，避免merge失败$ git pull --rebase origin master# (如果遇到错误提示，则打开冲突的文件，修改冲突)# 所有冲突的文件调整好之后，提交到暂存区$ git add .# 执行下面命令，合并冲突$ git rebase --continue# 再push到远程$ git push 建立pull/merge requestGit 基本命令待整理 git add [file-name] 将文件放入暂存区 git add . 将所有文件放入暂存区 git status 查看工作区和暂存区状况 git commit -m “message” [file-name] 提交文件到版本库 git commit -m “message” 提交所有暂存区中的文件到版本库 git push origin [branch-name] 将当前分支推到远端分支 git pull –rebase origin master 将远端master的修改更新到本地当前分支 git diff [file-name] 比较工作区文件与暂存区/版本库的差别 git checkout [file-name] 忽略文件当前工作区的修改，如果暂存区有该文件的修改，则回到暂存区的版本，否则回到版本库的版本 git rm [file-name] 删除文件 git log 查看版本库提交历史 git reset –hard [commit-id] 将代码回退到某一次commit，丢弃所有更改。另外HEAD代表当前版本，HEAD^表示上一次commit，HEAD^^表示上上次，以此类推，当然，还有这种表示方法：HEAD~10 git reset –soft [commit-id] 取消commit记录，但保留代码修改。这个在从feature branch上merge回master的时候非常有用，通常开发一个feature会有多次commit，如果不经过处理直接marge到master，commit也会一并marge进去，导致master分支的commit太多不容易阅读和维护。最好是在push到origin的时候，先将commit清空，仅保留一个描述当前功能的commit git tag 查看所有标签 git tag -a [tag-name] -m “message” 给当前最新一次commit打标签，并给标签添加说明 git tag -a [tag-name] -m “message” [commit-id] 给某一个commit打标签，并添加说明 git push origin [tag-name] 将本地标签推到远程 git push origin –tags 将本地未推送的标签批量推到远程 git tag -d [tag-name] 删除标签 git push origin :refs/tags/[tag-name] 删除远程标签 git branch 查看本地分支 git branch -a 查看远程分支 git branch -d [branch-name] 删除本地分支 git branch -d -r origin/[branch-name] 删除远程分支 推荐用下面的方法 git push origin :[branch-name] 删除远程分支 git branch |grep ‘bran’|xargs git branch -d 批量删除以bran开头的本地分支 git branch -a | grep ‘bran’ | sed ‘s/remotes\///‘ | xargs git branch -d -r 批量删除以bran开头的远程分支 git check-ignore -v [file] 检查文件是被哪条规则ignore 邮箱和用户名1234567# 查看用户名和邮箱地址：$ git config user.name$ git config user.email# 修改用户名和邮箱地址$ git config --global user.name "xxxx"$ git config --global user.email "xxxx" 提交代码三大基本命令1234## 提交代码git add .git commit -m "说明"git push 查看操作 查看远程库的信息 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 分支 基本操作1234567891011## 创建dev分支并切换到dev分支$ git checkout -b dev## git checkout命令加上-b参数表示创建并切换，相当于以下两条命令# 创建分支$ git branch dev# 切换分支$ git checkout dev# 查看分支git branch 查看分支12345678910# 查看分支$ git branch # 查看指明最新提交信息的分支列表$ git branch -v# 查看已合并至当前分支的所有分支$ git branch --merged# 查看未合并至当前分支的所有分支$ git branch --no-merged 远程分支 分支都是存在本地的，即本地分支，还需要了解远程分支，如[remote]/[branch]这种形式，表示是远端主机的某分支 这两类分支之间应该有某种关系将他们关联起来 ，当我们从一个远程分支切出（创建）一个本地分支时，这个分支就叫跟踪分支（tracking branch）,而远程分支叫上游分支（upstream branch）12345678# 创建跟踪分支指令如下：$ git checkout -b 本地分支名 远端主机别名/远程分支名1# 当然也可以不指定分支名，使用远程分支同名：$ git checkout --track 远端主机别名/远程分支名# 从远程分支（下面指远程主机origin上的develop分支），切出新的本地分支 test分支$ git checkout -b test origin/develop 合并分支 基本操作： 12345# 切换到当前分支$ git checkout master# 选择需要合并的分支（dev就是分支的name）$ git merge dev 分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 123456789# 切换到当前分支$ git checkout master# 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward# 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。$ git merge --no-ff -m "merge with no-ff" dev# 合并后，可以用git log查看分支历史$ git log 解决合并分支的冲突 如果合并分支遇到冲突 12$ git status # 查看冲突的文件 然后，修改当前文件重新add和commit（之后保存vscode会弹出相关操作） 最后再重新合并即可 删除分支12345# 合并完成后可选择删除分支$ git branch -d dev# 强制删除未合并的分支$ git branch -D &lt;name&gt; stash 命令 git stash git stash 用于保存和恢复工作进度。 廖雪峰教程 (该教程是简单的指令) git stash详解 应用场景 当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。 由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。 总的来说，git stash命令的作用就是： 将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。 这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。 git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。 简易版操作： 1234567891011# 保存当前工作进度（save 描述可以省略）$ git stash save '描述'# 查看暂存区中的内容$ git stash list# 恢复暂存区中的内容$ git stash apply# 恢复并删除暂存区中的内容$ git stash pop 具体版操作： 123456789101112131415161718# 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。$ git stash save "说明...."# 显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候选择。$ git stash list# 删除某个队列$ git stash drop stash@&#123;0&#125; 这是删除第一个队列# 清空所有队列$ git stash clear# 指定恢复某一个具体进度。如果 --index 没有这个参数，默认恢复最新进度# 恢复完毕会从进度列表中删除&lt;stash&gt;。 $ git stash pop --index stash@&#123;0&#125;# 除了不删除恢复的进度之外，其余和git stash pop 命令一样。$ git stash apply --index stash@&#123;0&#125; 未整理的运用场景： 解决突发情况 git merge git pull 时候遇到冲突解决办法 标签管理 为什么要使用标签 暂时还来不及看 git branchgit checkout切换并创建分支1git checkout -b &lt;new_branch&gt; &lt;start point&gt; git rebase待看： 这一次彻底搞懂 Git Rebase 相关应用： git 合并多个commit (Git)合并多个commit git merge git merge合并代码时各参数含义 –squashgit merge –squash介绍 建议：合并分支的时候使用（不会合并分支上的提交历史） 123# 判断是否使用--squash选项最根本的标准是，待合并分支上的历史是否有意义$ git merge --squash dev$ git commit -m "message here" –abort取消本次合并操作 1git merge --abort dev –no-ff 不使用fast-forward方式合并，保留分支的commit历史 fast-forward 方式：当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit 1git merge --no-ff dev Git：git-merge的–ff和–no-ff 多人协作基本操作 廖雪峰教程 从远程库clone时，默认情况下，只能看到本地的master分支。可以用git branch命令查看： 12$ git branch* master 要在dev分支上开发，就必须 创建远程origin的dev分支到本地 总结： 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 常见问题 为什么要先commit，然后pull，最后再push？而不是commit然后直接push？ git 忽略提交文件百度 常用的规则： /mtk/ 过滤整个文件夹 *.zip 过滤所有.zip文件 /mtk/do.c 过滤某个具体文件 删除并忽略已远程提交的文件 git 常用场景未整理 git stash详解 撤销已经push的commitGit撤销已经推送(push)至远端仓库的提交(commit)信息 查看提交信息，获取需要回退至的版本号 1$ git log 重置至指定版本的提交，达到撤销提交的目的 参数 soft 指的是：保留当前工作区，以便重新提交 还可以选择参数 hard，会撤销相应工作区的修改，一定要谨慎使用 1$ git reset --soft &lt;commit的版本号&gt; 确认是否成功撤销 1$git log 强制提交当前版本号 必须添加参数 force 进行强制提交，否则会提交失败，并报错 1$ git push origin master --force 最后将代码重新提交和推送 123$ git add .$ git commit -m "最新提交的内容"$ git push origin master 合并分支的commit只合并一个commit 找出要合并的commit ID : 12// 例如0128660c08e325d410cb845616af355c0c19c6fe 然后切换到B分支上 12$ git checkout B$ git cherry-pick 0128660c08e325d410cb845616af355c0c19c6fe 然后就将A分支的某个commit合并到了B分支了 合并连续的多个commit 比如在develop分支上有7c32be61到54dfef55的连续的10个commit，54dfef55是后面的提交。 现在要将这10个commit 合并到develop-hbb分支上 首先基于develop分支创建一个临时分支temp，并指明新分支的最后一个commit 1git checkout -b temp 54dfef55 将temp分支上的从7c32be61到最后一个commit，也就是54dfef55的commit合并到develop-hbb上 1git rebase --onto develop-hbb 7c32be61^ checkout 命令常用指令123# 省略commit：用暂存区的文件覆盖工作区的文件。# 加上commit：用指定提交中的文件覆盖暂存区和工作区中的文件。如例1$ git checkout 某次commit的hash值 1. clone 指定历史版本的源码在 git bash 中执行以下命令 12git clone http://xxx/xx.gitgit checkout 4c9acfd867e69297e84887f245dc1b953593dc61 2. 用暂存区的文件覆盖工作区中的文件 相当于撤销自上次执行git add filename以来（如果执行过）的本地修改。 12345# 撤销某个文件本地的修改（相对于暂存区）$ git checkout -- filename# 撤销所有本地的修改（相对于暂存区）【谨慎使用】$ git checkout -- . / git checkout . x reset 命令常用指令12345678910111213141516# 将之前用git add命令更新到暂存区的内容 撤出暂存区（工作区不会受到影响）$ git reset / git reset HEAD# 仅将文件filename 的改动撤出暂存区，暂存区中其他文件不改变。$ git reset -- filename / git reset HEAD filename# 工作区和暂存区不改变，但是引用向前回退一次。# 当对最新的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。$ git reset --soft HEAD^# 工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。$ git reset HEAD^ / git reset --mixed HEAD^# 彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。# 自上一次以来的提交全部丢失。【谨慎使用】$ git reset --hard HEAD^ 1. 撤销最新的提交以便重新提交 工作区和暂存区不改变，但是引用向前回退一次 1$ git reset --soft HEAD^ 树状图双击错误提示bug prop的值动态跟随参数改变 板块模块，收起功能报错bug]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eslint使用技巧总结（持续更新）]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%B7%A5%E5%85%B7%2Feslint%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰… 官方地址：https://cn.eslint.org/ 在vue中使用eslintvue cli 默认提供了standard和airbnb 两种 lint 规范，但是一个j检查校验的太松一个又太紧，而且每个团队的 lint 规范又是不同的 安装并配置完成 ESLint 后，我们继续回到 VSCode 进行扩展设置，依次点击 文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置 12345678910"files.autoSave":"off","eslint.validate": [ "javascript", "javascriptreact", "html", &#123; "language": "vue", "autoFix": true &#125; ], "eslint.options": &#123; "plugins": ["html"] &#125; 这样每次保存的时候就可以根据根目录下.eslintrc.js你配置的eslint规则来检查和做一些简单的fix。 这里提供了一份我平时的eslint规则地址，都简单写上了注释。每个人和团队都有自己的代码规范，统一就好了，去打造一份属于自己的eslint 规则上传到npm吧，如饿了么团队的 config，vue的 config。]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[elementUI使用技巧总结（持续更新）]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%89%8D%E7%AB%AF%2FVue%2F%E7%BB%84%E4%BB%B6%E5%BA%93%E5%92%8C%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2FelementUI%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰整理… 官方文档：https://element.eleme.cn/#/zh-CN/component/installation GitHub源码：https://github.com/ElemeFE/element 起步安装 1npm i element-ui -S 在项目中引用 12345678910import Vue from 'vue'import ElementUI from 'element-ui' // 引入组件库import 'element-ui/lib/theme-chalk/index.css' // 引入样式Vue.use(ElementUI)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 问题解决element相关的问题解决方式： 去看文档再去issue里找找，再去看看源码，大部分问题都能解决了 一个诀窍其实大部分诡异的问题都可以通过加一个 key 或者 Vue.nextTick来解决 Form 表单 官方教程：https://element.eleme.cn/#/zh-CN/component/installation 表单验证 参考： https://segmentfault.com/a/1190000015068613 https://www.jianshu.com/p/b371db8fe66a https://www.jianshu.com/p/1743865309f2]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>组件库和插件工具</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios官方文档整理]]></title>
    <url>%2F2019%2F04%2F29%2FHTTP%E7%BD%91%E7%BB%9C%2Faxios%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[官方文档没有什么目录结构，整理了下，方便学习和后续查看（版本为20190429） Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 官方文档：https://www.kancloud.cn/yunye/axios/234845 起步特点和作用 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; Example执行 GET 请求123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); axios API可以通过向 axios 传递相关配置来创建请求 axios(config) 123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios('/user/12345'); 请求方法的别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) NOTE在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例可以使用自定义配置新建一个 axios 实例 axios.create([config])12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 总配置全部123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 // axios的访问请求默认是不带cookie的，因此想要带cookie的请求，需要设置该参数为true withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 比较简单的配置 不用放在下面单项具体详细说的配置 12345678910111213141516171819202122232425262728293031323334353637383940// `url` 是用于请求的服务器 URLurl: '/user',// `method` 是创建请求时使用的方法method: 'get', // 默认是 get// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URLbaseURL: 'https://some-domain.com/api/',// `headers` 是即将被发送的自定义请求头headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;,// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)// 如果请求话费了超过 `timeout` 的时间，请求将被中断timeout: 1000,// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'responseType: 'json', // 默认的// `withCredentials` 表示跨域请求时是否需要使用凭证withCredentials: false, // 默认的// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称xsrfCookieName: 'XSRF-TOKEN', // default// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的// `maxContentLength` 定义允许的响应内容的最大尺寸maxContentLength: 2000,// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目// 如果设置为0，将不会 follow 任何重定向maxRedirects: 5, // 默认的// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：// `keepAlive` 默认没有启用httpAgent: new http.Agent(&#123; keepAlive: true &#125;),httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), 单项具体transformRequest12345678// `transformRequest` 允许在向服务器发送前，修改请求数据// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 StreamtransformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data;&#125;], transformResponse123456// `transformResponse` 在传递给 then/catch 前，允许修改响应数据transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data;&#125;], params12345// `params` 是即将与请求一起发送的 URL 参数// 必须是一个无格式对象(plain object)或 URLSearchParams 对象params: &#123; ID: 12345&#125;, paramsSerializer12345// `paramsSerializer` 是一个负责 `params` 序列化的函数// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;)&#125;, data123456789// `data` 是作为请求主体被发送的数据// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'// 在没有设置 `transformRequest` 时，必须是以下类型之一：// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams// - 浏览器专属：FormData, File, Blob// - Node 专属： Streamdata: &#123; firstName: 'Fred'&#125;, adapter12345// `adapter` 允许自定义处理请求，以使测试更轻松// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).adapter: function (config) &#123; /* ... */&#125;, auth123456// `auth` 表示应该使用 HTTP 基础验证，并提供凭据// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头auth: &#123; username: 'janedoe', password: 's00pers3cret'&#125;, onUploadProgress1234// `onUploadProgress` 允许为上传处理进度事件onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理&#125;, onDownloadProgress1234// `onDownloadProgress` 允许为下载处理进度事件onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理&#125;, validateStatus123456// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; // 否则，promise 将被 rejectevalidateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的&#125;, proxy1234567891011// 'proxy' 定义代理服务器的主机名称和端口// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125;&#125;, cancelToken1234// `cancelToken` 指定用于取消请求的 cancel token// （查看后面的 Cancellation 这节了解更多）cancelToken: new CancelToken(function (cancel) &#123;&#125;) 响应结构某个请求的响应包含以下信息 12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 添加请求拦截器12345678// 1.添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 添加响应拦截器12345678// 2.添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 移除拦截器如果你想在稍后移除拦截器，可以这样： 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 为自定义实例添加拦截器可以为自定义 axios 实例添加拦截器 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理12345678910111213axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message); &#125; console.log(error.config); &#125;); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 状态码在大于或等于500时才会 reject &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); Note : 可以使用同一个 cancel token 取消多个请求]]></content>
      <categories>
        <category>HTTP网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Vue写后台：学习和使用笔记]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%89%8D%E7%AB%AF%2FVue%2F02-%E8%BF%9B%E9%98%B6%2F%E7%94%A8Vue%E5%86%99%E5%90%8E%E5%8F%B0%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[… 在正式上手 vue-element-admin 后台框架前，原作者的教程学习： https://segmentfault.com/a/1190000009275424 看我😄 此文档总结了很多教程学习过程中：不熟甚至是还未看的知识点，所以请多次查阅，查漏补缺和整理 进度 学习进度：这节看完了了，但是从这里开始还没整理知识点 看到这里：https://segmentfault.com/a/1190000009762198#articleHeader8 待深究 异步组件和路由懒加载 vue异步组件(高级异步组件)使用场景及实践 两步验证 等待先看其他的知识点 导航-问题探究 登录权限篇登录详细代码 进入页面时先从 cookie 中查看是否存有 token 没有：进入登录页面 存在：将 token 返给后端获取用户信息 user_info 点击登录的操作 如果登录成功： 服务端会返回一个 token（该token的是一个能唯一标示用户身份的一个key） 然后将token存储在本地cookie之中（这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了） 123456789101112131415161718192021// click事件触发登录操作:this.$store.dispatch('LoginByUsername', this.loginForm).then(() =&gt; &#123; this.$router.push(&#123; path: '/' &#125;); // 登录成功之后重定向到首页&#125;).catch(err =&gt; &#123; this.$message.error(err); // 登录失败提示错误&#125;);// action:LoginByUsername(&#123; commit &#125;, userInfo) &#123; const username = userInfo.username.trim() return new Promise((resolve, reject) =&gt; &#123; loginByUsername(username, userInfo.password).then(response =&gt; &#123; const data = response.data Cookies.set('Token', response.data.token) // 登录成功后将token存储在cookie之中 commit('SET_TOKEN', data.token) // 登录成功后更新vuex中token字段的值 resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;); &#125;);&#125; 获取用户信息 在全局钩子 router.beforeEach 中拦截路由，判断是否已获得token如果存在token=&gt;获取用户的基本信息了否则重新跳转到登录页面，重复上述操作 123456//router.beforeEachif (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetInfo').then(res =&gt; &#123; // 拉取user_info const roles = res.data.role; next();//resolve 钩子 &#125;) 权限 本篇教程地址 该教程中权限的实现方式： 创建vue实例的时候将 vue-router 挂载，但这个时候 vue-router 挂载一些登录或者不用权限的公用的页面 当用户登录后，获取用户 role，将 role 和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表 调用 router.addRoutes ( store.getters.addRouters )添加用户可访问的路由（动态挂载路由） 使用 vuex 管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件 但其实很多公司的业务逻辑可能不是这样的，举一个例子来说，很多公司的需求是每个页面的权限是动态配置的，不像本项目中是写死预设的。但其实原理是相同的 比如，你可以这样实现： 在后台通过一个tree控件或者其它展示形式给每一个页面动态配置权限 然后将这份路由表存储到后端 当用户登录后根据role 后端返回一个相应的路由表 或者前端去请求之前存储的路由表 =&gt;动态生成可访问的路由表 最后通过 router.addRoutes 动态挂在到router上 实战篇 教程地址 富文本https://segmentfault.com/a/1190000009762198#articleHeader13 markdownhttps://segmentfault.com/a/1190000009762198 导出Excelhttps://segmentfault.com/a/1190000009762198#articleHeader16 EChartshttps://segmentfault.com/a/1190000009762198#articleHeader17 注意点：（待整理，暂时具体看链接教程） 按需引入 远程获取data，动态改变ECharts的配置 通过watch来触发setOptions方法 相同component 不同参数https://segmentfault.com/a/1190000009762198#articleHeader18 两个组件或页面一样，但最后调用不同的接口实现不同的方法时的实现方式 如：区分新建和编辑页面 vueAdmin 一个极简的后台模板基础 本篇教程地址：https://segmentfault.com/a/1190000010043013 控制路由懒加载https://segmentfault.com/a/1190000010043013#articleHeader1 原因： 在页面较多的时候，使用路由懒加载在开发模式下热更新速度很慢 解决办法： 封装了一个_import()的方法，只有在正式环境下才使用懒加载 （具体看教程） 导航本篇教程地址 侧边栏 侧边栏是根据 router.js 配置的路由并且根据权限动态生成的 （可以之后深究下原理） 面包屑 本项目中也封装了一个面包屑导航，它也是通过watch $route动态生成的。代码 vue-router路由信息对象拓展 自定义了一些属性 （也可以深究下原理） 图标本篇教程原地址 该项目中使用的是 iconfont 中的Symbol方式引入 本项目中已经封装好了一个svg component 方便大家直接使用 1&lt;icon-svg icon-class="填入你需要的iconfont名字就能使用了"&gt;&lt;/icon-svg&gt; faviconhttps://segmentfault.com/a/1190000010043013#articleHeader5 postcsshttps://segmentfault.com/a/1190000010043013#articleHeader6 babel-polyfill为什么要使用babel-polyfill？ 本项目相关使用教程 v4.0新版本 手摸手，带你用vue撸后台 系列五(v4.0新版本) redirect 刷新页面本教程原地址 在不刷新页面的情况下，更新页面。 删除动态添加的路由本教程原地址 mock方法优化本教程原地址 Attrs 和 Listeners 写二次封装组件或高阶组件的神器 本教程原地址 Computed 的 get 和 set本教程原地址 Object.freeze 优化当数据量特别大的时候的卡顿现象 本教程原地址 Sass 和 Js 之间变量共享本教程原地址 JS将变量传给sass： 使用内联样式（此处只列出了最优方法，其余方法原教程） 1&lt;div :style="&#123;'background-color':color&#125;" &gt;&lt;/div&gt; sass将变量传给JS 利用:export 实现 123456// var.scss$theme: blue;:export &#123; theme: $theme;&#125; 123// test.jsimport variables from '@/styles/var.scss'console.log(variables.theme) // blue 自动注册全局组件 适用场景：当自己封装了很多组件的时候（并且 在很多页面组件中都需要用到），每次使用都需要导入，太麻烦 本教程原地址 本教程原地址 本教程原地址]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>待整理</tag>
        <tag>待复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型相关知识点总结]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2FJavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[所有相关的笔记汇总一起，以后方便查看复习 JS 中的数据类型基本数据类型 5 种基本数据类型（Number, String, Boolean, Undefined, Null）基本数据类型指的是简单的数据段 1、Number 数值类型：整数和浮点数 2、String 字符串类型：用引号括起来，可以双引号，也可以单引号 3、Boolean 布尔类型：true和false 4、undefined 类型：确定一个已经声明但是还没有赋值的变量 5、null 类型：表明某个变量的值为空 复杂数据类型（引用数据类型） 3 种复杂（引用）数据类型（Object, Array, Function）引用数据类型指的是有多个值构成的对象 1、对象：Object 1var car = &#123;name：；length：；price：；&#125;； 2、数组：Array 1var a = [1,2,3,4]; 3、函数：Function 1function f()&#123;&#125; 基本数据类型和引用数据类型的区别概念 基本数据类型指的是简单的数据段 引用数据类型指的是有多个值构成的对象 与堆栈之间的联系JavaScript的数据类型分为两大种： 基本类型：Undefined、Null、Boolean、Number 和 String，这5中基本数据类型可以直接访问，他们是按照值进行分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可以分配。 引用类型：即存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。 具体区别https://www.cnblogs.com/cxying93/p/6106469.html ES6 新增的数据类型 ES6 新增的数据类型： 基本数据类型：Symbol 复杂数据类型：Set（类Array），Map（类Object） 总结6种基本数据类型（Number, String, Boolean, Undefined, Null, Symbol） 5种复杂数据类型（Object, Array, Function, Set, Map） 一共11种数据类型 JS 数据类型判断typeofMDN文档 检测基本数据类型 123456typeof 3 // "number"typeof "abc" // "string"typeof true // "boolean"typeof undefined // "undefined"typeof null // "object" 此处显然是一个错误// 还可以检测es6新引入的Symbol 检测复杂数据类型 12typeof &#123;&#125; // "object"typeof function()&#123;&#125; // "function" 除此之外 Object 下还有很多细分的类型，比如 Array、Date、RegExp、Error 等。如果用 typeof 去检测这些类型 12345678var array1 = []var array2 = new Array();var date = new Date();var error = new Error();console.log(typeof array1); // objectconsole.log(typeof array2); // objectconsole.log(typeof date); // objectconsole.log(typeof error); // object 总结： typeof 可以区分基本数据类型（null除外）； 可以区分复杂数据类型 Object 和 Function （Array不行） 不能区分 Object，即对象下的不同类型 Object.prototype.toStringMDN文档 Object.protototype.toString 被调用时，执行下面的操作步骤： 如果 this 的值为 undefined，则返回 “[object Undefined]” . 如果this的值为 null ,则返回 “[object Null]” . 让O成为调用 ToObject(this) 的结果. 让class成为O的内部属性 [[Class]] 的值. 最后返回由 &quot;[object &quot; 和 class 和 &quot;]&quot; 三个部分组成的字符串. 通过规范，了解调用 Object.prototype.toString 最终会返回一个由 &quot;[object &quot; 和 class 和 &quot;]&quot; 组成的字符串，而 class 是要判断的对象的内部属性。 为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。 12345678console.log(Object.prototype.toString.call(3)) // [object Number]console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]console.log(Object.prototype.toString.call(&#123;&#125;)) // [object Object]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date]复制代码 这个 class 值就是识别对象类型的关键因此可以用 Object.prototype.toString 方法识别出更多类型那到底能识别多少种类型呢？ 123456789101112131415161718192021222324252627282930313233343536var number = 1; // [object Number]var string = '123'; // [object String]var bool = true; // [object Boolean]var unde = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;&#125; // [object Object]var array = []; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkTypes() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)// 打印出// 1.基本数据类型[object Number][object String][object Boolean][object Undefined][object Null]// 2.复杂数据类型[object Object][object Function][object Array][object Date][object Error][object RegExp] 除了以上 11 种之外，还有3种： 1234567console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]function a() &#123; console.log(Object.prototype.toString.call(arguments)); &#125;a(); // [object Arguments] 这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。 利用这个方法写成的类库Axis.js： 原理解析 constructorMDN文档 返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。 如何判断一个变量是自定义对象类型？ javascript 的所有对象都有一个 constructor 属性，这个属性可以帮我们判断 object 数据类型 12345678910//alert(1.constructor); //报错 数字常量无 constructor 属性 var num = 1; console.log(num.constructor == Number); //true console.log("miqilin".constructor == String); //true var str = "miqilin"; console.log(str.constructor == String); //true var obj= null; console.log(obj.constructor); //报错，null 没有 constructor 属性 var none = undefined; console.log(obj.constructor); //报错，undefined 没有 constructor 属性 可以看出，数字型常量，null 和 undefined 都没有 constructor 属性。 对于原型链继承的情况，constuctor 无法判断 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj.constructor == Cat); //false ？？因为 Cat.prototype不在obj的原型链上 console.log(obj.constructor == Animal); //true 理解 instanceofMDN文档 instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置 instanceof 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。（可以用来判断） 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj instanceof Cat); //true 毫无疑问 console.log(obj instanceof Animal); //true 可以理解 instanceof 适用于所有原生类型： 1234[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true instanceof 不适用于原始类型：字符串，数字，布尔值： 1233 instanceof Number // falsetrue instanceof Boolean // false'abc' instanceof String // false 总结 typeof： 识别所有变量的类型，返回number，boolean，string，undefined，function，object（ Null 除外） 对于内置的对象实例，只能返回”Object”字符串 Object.prototype.toString： 获取每个对象的类型，可以识别基本数据类型及内置对象类型 不能识别自定义对象类型 instanceof： 判断对象的实例，返回布尔值 不可判别基本数据类型 可判别内置对象类型 可判别自定义对象类型（可以判断原型链改变的情况） constructor： 返回创建实例对象的 Object 构造函数的引用。 可以判别部分基本数据类型（ Undefined/Null 除外） 可识别内置对象类型 可识别自定义对象类型（无法判断原型链改变的情况） typeof和instanceof的区别 typeof 识别所有变量的类型，返回值有number，boolean，string，undefined，function，object（不能判断null） typeof 对于丰富的对象实例，只能返回”Object”字符串。 instanceof 用来判断对象，代码形式为 obj1 instanceof obj2（obj1是否是obj2的实例），其返回值为布尔值。obj2必须为对象，否则会报错！（所以不可以判别基本数据类型）。 instanceof 可以对不同的对象实例进行判断，判断方法是根据对象的原型链依次向下查询，如果obj2的原型属性存在obj1的原型链上，（obj1 instanceof obj2）值为true。 综合使用 typeof 判别基本数据类型（null除外）结合 instanceof 判别内置对象类型 Object.prototype.toString 结合类库 参考文章： https://juejin.im/post/5cc293e0e51d456e3a5f0864]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo相关的实用插件]]></title>
    <url>%2F2019%2F04%2F26%2FHexo%E5%8D%9A%E5%AE%A2%2Fhexo%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[集中整理一些hexo相关的插件 页面实时刷新插件hexo-browsersync 使用方法 首先在项目目录下安装 hexo-browsersync 插件 12$ cd hexo_project/$ npm install hexo-browsersync --save 然后运行 hexo server, 看到以下内容说明启动成功 123456789$ hexo s[BS] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.191.1:3001 --------------------------------------INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 最后运行 http://localhost:4000，另一边编辑博客这边运行的页面也会实时更新]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优秀的前端专栏或周刊]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%B7%9F%E7%9D%80%E5%A4%A7%E4%BD%AC%E5%AD%A6%E7%BC%96%E7%A8%8B%2F%E4%BC%98%E7%A7%80%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B8%93%E6%A0%8F%E6%88%96%E5%91%A8%E5%88%8A%2F</url>
    <content type="text"><![CDATA[🐰 日刊 前端 - InfoQ 前端日报 周刊 奇舞周刊 Tnfe/TNFE-Weekly]]></content>
      <categories>
        <category>跟大佬学编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用hexo写博客：相关标签和美化]]></title>
    <url>%2F2019%2F04%2F25%2FHexo%E5%8D%9A%E5%AE%A2%2F%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基于hexo + next6.0 主题原生支持 文章中添加居中模块 方式一： 优秀的人，不是不合群，而是他们合群的人里面没有你 查看代码1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 方式二 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 查看代码123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125; 引用站内文章hexo相关的实用插件 12345&#123;% post_link 绝对路径 链接显示的文字（建议直接用文章名，当然不用也可以） %&#125;// 比如上面的示例&#123;% post_link 【记录和总结】/2019-04 Cynthia-的四月记录 %&#125; 代码块红绿底色123456789101112131415/** * +为红色，-为绿色，设置为diff语言即可*/package l2f.gameserver.model;+public abstract class L2Char extends L2Object &#123;- public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log("Should not be called"); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; note标签样式1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; danger 利用html标签kbd标签实现效果： Ctrl 代码： 1&lt;kbd&gt;Ctrl&lt;/kbd&gt; 折叠效果实现效果： 查看代码 1我是代码块 代码： 1234&lt;details&gt;&lt;summary&gt;查看代码&lt;/summary&gt; - 代码块&lt;/details&gt; 利用id进行页面跳转⬆ 回到顶部 查看代码 12&lt;span id="jump"&gt;&lt;/span&gt;[⬆ 回到顶部](#jump) 参考文章 https://sxxkearth.github.io/2018/11/30/Next%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/ 插入图标 插入图片（调节位置和链接） 自定义样式（比如蓝色的引用条） 主题自带的note样式标签 主题自带的label标签样式 使用tabs标签样式（选项卡） 插入音乐和视频]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo结合next6相关的配置笔记]]></title>
    <url>%2F2019%2F04%2F25%2FHexo%E5%8D%9A%E5%AE%A2%2Fhexo%E7%BB%93%E5%90%88next6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[🐰 参考文章 hexo + next主题高级配置 待配置 修改字体大小样式 https://www.jianshu.com/p/344cf061598d 博文置顶 https://www.jianshu.com/p/344cf061598d 侧边栏添加访问量等信息 https://www.jianshu.com/p/344cf061598d 设置网站的图标Favicon https://www.jianshu.com/p/9f0e90cc32c2 网站底部加上访问量 https://www.jianshu.com/p/9f0e90cc32c2 添加文章热度 https://www.jianshu.com/p/9f0e90cc32c2 添加来必力云跟帖功能 https://www.jianshu.com/p/9f0e90cc32c2 添加jiathis分享 https://www.jianshu.com/p/9f0e90cc32c2 添加DaoVoice在线联系 https://www.jianshu.com/p/9f0e90cc32c2 在文章底部增加版权信息（详细可以在md中自定义） https://www.jianshu.com/p/9f0e90cc32c2 添加外链网易云音乐 https://www.jianshu.com/p/9f0e90cc32c2]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[⭐Cynthia 的四月记录⭐]]></title>
    <url>%2F2019%2F04%2F25%2F%E3%80%90%E6%AF%8F%E6%9C%88%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%2F2019-04%2F</url>
    <content type="text"><![CDATA[4月末计划开始的这个系列博客，希望能一直坚持记录下自己的学习轨迹… 学习技术文章阅读 vue-element做后台系列教程： 手摸手，带你用vue撸后台 系列二(登录权限篇) 手摸手，带你用vue撸后台 系列三(实战篇) 手摸手，带你用vue撸后台 系列四(vueAdmin 一个极简的后台基础模板) 手摸手，带你优雅的使用 icon 通读一遍Vuex和vue-router的官方文档 https://vuex.vuejs.org/zh/guide/ https://router.vuejs.org/zh/ JavaScript系列之类型判断 简单理解Vue中的nextTick axios官方文档 https://www.kancloud.cn/yunye/axios/234845 JS方法学习和复习some()测试是否至少有一个元素通过由提供的函数实现的测试 下面两个方法在此处的作用都是为了达到浅拷贝的效果 slice()12// 利用slice浅拷贝的特性，复制一个新数组（对新数组改变不会更改原数组的值）newArray = oldArray.slice(); //slice会clone返回一个新数组 Object.assign()123456789101112131415const oldObj = &#123; b: 4, c: 5 &#125;;// 复制一个对象给新对象const newObj = Object.assign(&#123;&#125;, oldObj);// 更改新对象的值newObj.b = 100;console.log(oldObj);console.log(newObj);// 输出&gt; Object &#123; b: 4, c: 5 &#125;&gt; Object &#123; b: 100, c: 5 &#125; CSS巩固flex-wrapflex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向 calc()函数calc() 函数用于动态计算长度值。 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； 任何长度值都可以使用 calc() 函数进行计算； calc() 函数支持 “+“, “-“, “*“, “/“ 运算； calc() 函数使用标准的数学运算优先级规则； HTML&lt;dl>123456&lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt;&lt;/dl&gt; 描述列表： Coffee Black hot drink Milk White cold drink 杂记博客这周开始搭建博客，然后陆陆续续开始优化，算是挺有成就感的吧~计划之后慢慢的把本地和博客园的文章搬过来，然后再优化一些小细节 末尾的碎碎念4.26这应该是个很短的4月记录了，因为四月底才开始实施要写记录博客这个事情不过打算下个月要好好记录啦🙈 4.28-4.29这周公司的事情不是很多，静下心来把vue的vuex和router文档看了一遍，并整理了下注意点。感觉收获很多。 今天又看了遍axios的文档]]></content>
      <categories>
        <category>每月记录和总结</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用第三方字体图标]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[🐰 font-awesome使用类的方式 npm 安装 font-awesome 1npm install font-awesome 在 main.js 中引入 1import '@/assets/css/font-awesome.css' // 引入font-awesome字体图标 在组件中通过类名的方式引用 1&lt;span class="fa fa-camera-retro fa-lg"&gt;&lt;/span&gt; 使用组件的方式 安装 vue-awesome 依赖包 1$ npm install vue-awesome 注意：安装之后打开node_modules文件夹，查看是否有vue-awesome文件夹 在 main.js 文件下 123456789// 如果考虑项目大小，只导入使用的图标，减少包大小import 'vue-awesome/icons/flag'// 否则，全部导入import 'vue-awesome/icons'// 注册组件import Icon from 'vue-awesome/components/Icon'Vue.component('icon', Icon) 在组件中使用 1&lt;icon name="beer"&gt;&lt;/icon&gt; iconfont https://www.jianshu.com/p/0cf10d836991 vue项目中使用阿里iconfont图标 手摸手，带你优雅的使用 icon 三种传统使用方式Unicode 优势 兼容性最好，支持ie6+ 支持按字体的方式去动态调整图标大小，颜色等等 劣势 不支持多色图标 在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难 unicode的书写不直观，语意不明确。光看&amp;#xe604;这个unicode你完全不知道它代表的是什么意思 因为以上劣势（尤其是第三点），放弃使用这个方式。具体使用看最前面的链接教程 font-class 与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+ 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么 缺点： 依旧无法支持多色图标 https://segmentfault.com/a/1190000012213278#articleHeader4 注意： 使用这种方式一定要注意命名空间 使用方法： 添加图标到iconfont的购物车，生成项目 拷贝项目下面生成的fontclass代码，下载并引入 注意拷贝css文件和字体文件到assets文件目录 在main.js中引入 iconfont.css 文件 1import './assets/iconfont/iconfont.css' // 引入iconfont图标 获取图标的类名，应用于页面（一定不能忘记命名空间） 1&lt;i class="iconfont icon-xxx"&gt;&lt;/i&gt; 引入iconfont在线地址的几个方法 在index.html中引入在线资源 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" style='height: 100%;'&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt; &lt;!-- 引入下面这个cdn资源 --&gt; &lt;link rel="icon" href="//at.alicdn.com/t/font_918300_q5yxfof3wjo.css"&gt; &lt;title&gt;vue-shop-front&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; 在mainjs中使用Vue.use()引入 1Vue.use('//at.alicdn.com/t/font_918300_q5yxfof3wjo.css') 在App.vue中import引入（前提是你得使用了预处理器） 1234567&lt;style lang="scss" scoped&gt;@import url("//at.alicdn.com/t/font_918300_q5yxfof3wjo.css");#wrap-box &#123; height: 100%; // height: 1000px;&#125;&lt;/style&gt; symbolhttps://segmentfault.com/a/1190000012213278#articleHeader5 优雅的使用方式目前暂时为了省事还是使用font-class吧 下面对svg封装组件的方式比较麻烦，有时间可以研究下： https://segmentfault.com/a/1190000012213278#articleHeader6 iconmoonvue项目中使用iconMoon图标]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-Cli3相关笔记（持续更新）]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%89%8D%E7%AB%AF%2F%E6%80%A7%E8%83%BD%E5%92%8C%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%2FVue-Cli3%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰 官方文档：https://cli.vuejs.org/zh/guide/ 配置文档：https://cli.vuejs.org/zh/config/ 脚手架搭建安装首先注意一下：Vue Cli要求Node.js版本8或更高，也可以在同一台计算机上管理多个版本的Node。 123npm install -g @vue/cli# oryarn global add @vue/cli 检查安装 1vue --version 创建项目手动创建官方教程 1vue create my-project 通过图形化界面创建1vue ui 项目配置配置不同的打包环境新建文件在目录里创建3个新的文件 .env 文件 123// 开发环境NODE_ENV=devVUE_APP_URL= "我是测试接口地址" .env.dev 文件 123// 开发环境NODE_ENV=devVUE_APP_URL= "我是测试接口地址" .env.prod 文件 123// 生产环境NODE_ENV=prodVUE_APP_URL = "我是生产接口地址" 在packge.json中配置打包环境12345"scripts": &#123; "dev": "vue-cli-service serve", "build": "vue-cli-service build --mode dev", // 打包测试 "build:test": "vue-cli-service build --mode prod" // 打包生产&#125;, npm run serve 默认会使用.env文件 npm run build:dev 默认会使用.env.dev文件 npm run build:prod 默认会使用.env.prod文件 本地预览打包后在本地预览,你需要启动一个node服务： 12npm install -g serve //全局安装服务serve -s dist // 启动服务预览 在main.js中获取当前的环境 123// 打印当前所处的环境console.log("打包的环境是：" + process.env.NODE_ENV)console.log("接口地址为：" + process.env.VUE_APP_URL) babel配置文件为了保证ES版本的兼容，我们还需要配置一下babel.config.js 文件的内容 12 浏览器css兼容处理文件配置.browserslistrc 文件 1234&gt; 1%last 2 versionsnot ie &lt;= 8复制代码 .postcssrc.js 文件 123456789101112module.exports = &#123; plugins: &#123; autoprefixer: &#123;&#125;, //'postcss-px2rem': &#123; // remUnit: 75, //&#125;, 'postcss-px2rem-exclude': &#123; remUnit: 75, exclude: /node_modules|assets|login|main/gi, &#125;, &#125;&#125;; eslint配置.eslintrc.js 的配置可以先前直接在图形化界面配置 1234567891011121314module.exports = &#123; root: true, env: &#123; node: true &#125;, extends: ["plugin:vue/essential", "@vue/prettier"], rules: &#123; "no-console": process.env.NODE_ENV === "production" ? "error" : "off", "no-debugger": process.env.NODE_ENV === "production" ? "error" : "off" &#125;, parserOptions: &#123; parser: "babel-eslint" &#125;&#125;; .browserslistrc文件 browserslist详解 browserslist使用手册 根目录中多了一个.browserslist文件，可以指定项目的目标浏览器的范围 用于转译的 JavaScript 特性和添加CSS 浏览器前缀，可以减少兼容代码提高代码质量 如果想少一个文件，你也可以在package.json中添加browserslist字段，参数是一个数组 参数 说明 &gt; 1% 全球超过1%人使用的浏览器 &gt; 5% in US 使用美国使用情况统计，接受两个字母的国家/地区代码 &gt; 5% in my stats 使用自定义使用数据 last 2 versions 所有浏览器兼容到最后两个版本根据CanIUse.com追踪的版本 Firefox ESR 火狐最新版本 Firefox &gt; 20 指定版本范围 not ie &lt;=8 方向排除部分版本 Firefox 12.1 指定浏览器版本 since 2013 2013年之后发布的所有版本 默认配置 12345678910111213// 默认配置&gt; 1%last 2 versionsnot ie &lt;= 8// &gt; 1%last 4 versions// &gt; 1%last 4 versionsie 10 package.json命令汇总12345678910111213141516171819202122// dev:vue-cli-service serve --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false)// build:vue-cli-service build --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小 现代模式 为了兼容那些不支持js新特性的浏览器我们需要Babel转译，但转译后的代码笨重冗长，这次3.x提供了一个现代模式 1vue-cli-service build --modern Vue CLI 会产生两个应用的版本： 一个现代版的包，面向支持 ES modules 的现代浏览器，另一个旧版的包，面向不支持的旧浏览器。 最酷的是这里没有特殊的部署要求。其生成的 HTML 文件会自动使用 Phillip Walton 精彩的博文中讨论到的技术： 现代版的包会通过 &lt;script type=&quot;module&quot;&gt; 在被支持的浏览器中加载；它们还会使用 &lt;link rel=&quot;modulepreload&quot;&gt; 进行预加载。 旧版的包会通过 &lt;script nomodule&gt; 加载，并会被支持 ES modules 的浏览器忽略。 一个针对 Safari 10 中 &lt;script nomodule&gt; 的修复会被自动注入。 对于一个 Hello World 应用来说，现代版的包已经小了 16%。在生产环境下，现代版的包通常都会表现出显著的解析速度和运算速度，从而改善应用的加载性能 config.js配置参考配置 基于vue-cli3.x下，配合vuex、vue-router、iView、axios、scss、amfe-flexible、vConsole等等等 vueCli3搭建的vue-vuex-router开发模版，PC、Mobile两个分支开箱即用，支持scss、vuex、axios、多语言、过滤器、仓库快速提交等 基本配置单项123456789// 基本路径// baseUrl: '/', // 3.3之前publicPath: '/', // 3.3之后 // 输出文件目录outputDir: 'dist', // eslint-loader 是否在保存的时候检查lintOnSave: true, 多项12345678910111213141516171819202122232425262728293031323334353637// webpack配置chainWebpack: () =&gt; &#123;&#125;,configureWebpack: () =&gt; &#123;&#125;, // vue-loader 配置项vueLoader: &#123;&#125;, // 生产环境是否生成 sourceMap 文件productionSourceMap: true, // css相关配置css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false&#125;, // webpack-dev-server 相关配置devServer: &#123; open: true, host: '0.0.0.0', port: 8080, https: false, hotOnly: false, proxy: null, // 设置代理 before: app =&gt; &#123;&#125;&#125;, // 第三方插件配置pluginOptions: &#123; // ...&#125; css配置基本12345678910css: &#123; // 启用 CSS modules modules: false, // 是否使用css分离插件 extract: true, // 开启 CSS source maps，一般不建议开启 sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125; &#125;, css.loaderOptions 配置文档：https://cli.vuejs.org/zh/config/#css-loaderoptions 123456789101112131415module.exports = &#123; css: &#123; loaderOptions: &#123; css: &#123; // 这里的选项会传递给 css-loader &#125;, sass: &#123; // 这里的选项会传递给 sass-loader &#125;, postcss: &#123; // 这里的选项会传递给 postcss-loader &#125; &#125; &#125;&#125; sass-loader 配置 示例1 1234sass: &#123; // 一次配置，全局使用，这个scss 因为每个文件都要引入 data: @import "./src/assets/style/bass.scss"; &#125; 示例2 1234sass: &#123; // 向全局sass样式传入共享的全局变量 data: @import "~assets/scss/flex.scss";$src: "$&#123;process.env.VUE_APP_SRC&#125;"; &#125; 示例3 1234567sass: &#123; //设置css中引用文件的路径，引入通用使用的scss文件（如包含的@mixin） data: ` $baseUrl: "/"; @import '@/assets/scss/_common.scss'; ` &#125; 示例4 123456sass: &#123; data: ` @import "@/style/mixin.scss"; @import "@/style/_var.scss"; ` &#125; 注意新版的sass可能要这样配置： https://segmentfault.com/a/1190000020392688?utm_source=tag-newest webpack配置主要分为以下两个模块 12chainWebpack: () =&gt; &#123;&#125;, // 链式的方式进行配置configureWebpack: () =&gt; &#123;&#125;, 配置别名 在 chainWebpack 中配置 12345678chainWebpack: (config) =&gt; &#123; config.resolve.alias .set('@$', resolve('src')) .set('assets', resolve('src/assets')) .set('components', resolve('src/components')) .set('layout', resolve('src/views')) .set('utils', resolve('src/utils'))&#125;, 自定义静态资源打包路径css输出配置更改该配置需要先安装MiniCssExtractPlugin插件到开发依赖中，如下： 1npm install --save-dev mini-css-extract-plugin 然后在vue.config.js文件中添加相关配置到chainWebpack即可，如下所示： 123456789101112module.exports = &#123; chainWebpack: config =&gt; &#123; // css output config let miniCssExtractPlugin = new MiniCssExtractPlugin( &#123; filename: '[name].[contenthash:8].css', chunkFilename: '[name].[contenthash:8].css' &#125; ) config.plugin('extract-css').use(miniCssExtractPlugin) &#125;,&#125; 链式与显示的对比实例1： 12345678910111213module.exports = &#123; configureWebpack: config =&gt; &#123; // js output config config.output.filename = '[name].[contenthash:8].js' config.output.chunkFilename = '[name].[contenthash:8].js' &#125;, chainWebpack: config =&gt; &#123; const filename = `static/js/[name]-$&#123;filenameHashing ? '[contenthash:8]' : ''&#125;-$&#123;Timestamp&#125;.js` // name+哈希值+时间戳控制缓存 config.output.filename(filename).chunkFilename(filename) &#125;&#125; 小Tip使用inspec功能查看config本身配置方面没有啥特别好说的，官方文档已经写得很详细了。 这次更新基本上就是基于 webpack-chain 把之前的 webpack 配置迁移了一遍，因为vue-cli帮你做了很多默认配置，所有可以省去一些代码。当然这种out-of-the-box的工具利弊也很明显，它能快速上手，大部分简单场景无需任何额外配置基本就能用了。 但对于复杂度高的或者自定义性强的项目来说，配置复杂度可能没有减少太多。它要求你不仅要对 webpack 或者相关工程化的东西很很熟悉，你还要对vue-cli做的一些默认配置和参数也有有一定了解，时不时要去看一下源码它到底干了啥，有的时候它的一些 plugin 出现了问题还不太好解决。 而且说实话 webpack-chain 的书写也是有些门槛的，大部分情况下我也很难保证自己的配置写对的，还好官方提供了inspec功能，能让配置简单了不少。 当你想知道自己的 vue-config.js 里的配置到底对不对的时候，你可以在命令行里执行vue inspect &gt; output.js,它会将你最终生成的config展现在output.js之中，不过它默认显示的是开发环境的配置。 如果你想查看其它环境的配置可以通过vue inspect --mode production &gt; output.js。在写构建配置的时候这个功能很有帮助，同时也能帮助你了解vue-cli在构建时到底帮你做了些什么。 取消路由懒加载这里还有一个黑科技，看过我之前文章的小伙伴应该还有印象，我一般在开发环境是不使用路由懒加载的，因为这样会导致热更新速度变慢，具体的可以看之前的 文章，在vue-cli@3中可以更简单的实现 你只要在.env.development环境变量配置文件中设置VUE_CLI_BABEL_TRANSPILE_MODULES:true就可以了。 它的实现逻辑和原理与之前还是一样的，还是基于 plugins babel-plugin-dynamic-import-node 来实现的。 之所以在vue-cli中只需要设置一个变量就可以了，是借用了vue-cli它的默认配置，它帮你代码都写好了。 通过阅读 源码 可知，vue-cli会通过VUE_CLI_BABEL_TRANSPILE_MODULES这个环境变量来区分是否使用babel-plugin-dynamic-import-node，所以我们只要开其它就可以。虽然它的初衷是为了单元测试的，但正好满足了我们的需求。 参考文章： https://juejin.im/post/5cdd47c16fb9a031fe3becfb#heading-3 12]]></content>
      <categories>
        <category>前端</category>
        <category>性能和构建部署</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vuex 笔记（持续更新）]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2FVuex%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通读官方文档和平时使用的总结和注意点 官方教程：https://vuex.vuejs.org/zh/guide/ API文档：https://vuex.vuejs.org/zh/api/ 核心概念 核心概念中的例子仅作理解，实际运用参考模块化使用 Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源； view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化。 store（仓库） 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。 Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 State 下面是一个最简单的store中获取state的示例 通过属性获取 安装 Vuex 之后 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： 123store.commit('increment')console.log(store.state.count) // -&gt; 1 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 1234567891011const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 组件中调用 由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在 计算属性 中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。 123456789// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： 123456789101112131415161718192021// 引入辅助函数 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // 计算属性 computed: &#123; localComputed () &#123; /* 自定义的其他计算属性 */ &#125;, ...mapState(&#123; // 1.箭头函数可使代码更简练 count: state =&gt; state.count, // 2.传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 3.为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) &#125;&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以直接给 mapState 传一个字符串数组 123computed: mapState([ // 现在一般这样获取，特殊情况按上面三种方法 'count']) Getter Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其 第一个参数： 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 通过属性访问Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getter 也可以接受其他 getter 作为 第二个参数： 1234567getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 在组件中使用： 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。 通过方法访问也可以通过让 getter 返回一个函数，来实现给 getter 传参。在对 store 里的数组进行查询时非常有用。 1234567getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125; 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 mapGettersmapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式： 1234mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount'&#125;) Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： 1store.commit('increment') 提交载荷（Payload）你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： 1234567// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10) 在大多数情况下，载荷应该是一个 对象 ，这样可以包含多个字段并且记录的 mutation 会更易读： 123456789// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit(&#123; type: 'increment', amount: 10&#125;) 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变： 12345mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; 使用常量替代 Mutation 事件类型使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 123456789101112131415// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 当然也可以直接这样： 1234567891011mutations: &#123; 'SET_FILENAME': (state, fileName) =&gt; &#123; state.fileName = fileName &#125;, 'SET_MENU_VISIBLE': (state, visible) =&gt; &#123; state.menuVisible = visible &#125;, 'SET_SETTING_VISIBLE': (state, visible) =&gt; &#123; state.settingVisible = visible &#125;,&#125; Mutation 必须是同步函数一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子： 1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交 Mutation 你可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation 或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; Action在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务： 12store.commit('increment')// 任何由 "increment" 导致的状态变更都应该在此刻完成。 为了处理异步操作，引入了action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 context 对象注册一个简单的 action： 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性 的 context 对象 因此你可以调用 context.commit 提交一个 mutation 或者通过 context.state 和 context.getters 来获取 state 和 getters。 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; 分发 ActionAction 通过 store.dispatch 方法触发： 1store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Actions 支持同样的 载荷方式和对象方式 进行分发： 12345678910// 1.以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 2.以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： 12345678910111213141516actions: &#123; checkout (&#123; commit, state &#125;, products) &#123; // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 在组件中分发 Action 在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action 或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： 123456789101112131415161718import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ // 1.将 `this.increment()` 映射为 `this.$store.dispatch('increment')` 'increment', // 2.`mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; // 3.将 `this.add()` 映射为 `this.$store.dispatch('increment')` add: 'increment' &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 现在你可以在组件中： 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另外一个 action 中也可以： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 最后，如果我们利用 async / await，我们可以如下组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成 模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。 123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState： 12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125; &#125;&#125; 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： 12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; 命名空间官方文档 总结Vuex 交互原理图： States：数据区，所有共享的状态（数据）可以放在这里 Mutations：改变State的状态（数据） Actions：通过异步的方式调用Mutations 调用方式： States： store.state.xxx Mutations： store.commit(&#39;xxx&#39;) Actions： store.dispatch(&#39;xxx&#39;) Getter： store.getters.xxx 易混淆mapState和mapGetter vuex的mapState和mapGetters 有哪些区别 基本用法 main.js 文件 12345678import Vue from 'vue'import store from './store'new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app') store.js 文件 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; // 数据区，所有共享的状态（数据）可以放在这里 state: &#123; test: 1 &#125;, // 改变State的状态（数据） mutations: &#123; 'SET_TEST': (state, newTest) =&gt; &#123; state.test = newTest &#125; &#125;, // 异步调用mutations里的方法 actions: &#123; setTest: (&#123; commit, state &#125;, newTest) =&gt; &#123; return commit('SET_TEST', newTest) // return 返回一个promise对象 &#125; &#125;&#125;) APP.vue 文件 12345678910&lt;script&gt; export default &#123; mounted() &#123; this.$store.dispatch('setTest',150) .then(() =&gt; &#123; console.log("修改后的数据：" + this.$store.state.test); &#125;) &#125;, &#125;&lt;/script&gt; 模块化用法（推荐）结合mixin.js文件使用 参考代码：https://github.com/Cynthia0329/ebook/tree/master/src/store 在store目录下 首先 store文件夹下的modules文件夹中 创建一个 模块文件 book.js 1234567891011121314const book = &#123; state: &#123; // 这里放自定义的需要公用的变量 fileName: '', &#125;, mutations: &#123; // 这里放 改变变量的方法 'SET_FILENAME': (state, fileName) =&gt; &#123; state.fileName = fileName &#125; &#125;&#125;export default book store文件夹下的 actions.js文件：这里异步调用mutations中的方法 123456const actions = &#123; setFileName: (&#123; commit &#125;, fileName) =&gt; &#123; return commit('SET_FILENAME', fileName) // return 返回一个promise对象 &#125;&#125;export default actions store文件夹下的 getter.js文件：得到 公用的变量 的回调函数 对象集合（后续可以直接引用） 1234const book = &#123; fileName: state =&gt; state.book.fileName&#125;export default book store文件夹下的 index.js文件：将上面三个文件联系起来，并导入相应的插件和包 1234567891011121314151617import Vue from 'vue'import Vuex from 'vuex'// 导入上面的三个文件import book from './modules/book.js'import getters from './getters.js'import actions from './actions.js'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; book // 模块文件导出的对象 &#125;, getters, //actions.js文件 actions //getter.js文件&#125;) 在utils目录下mixins 标签原理： 123456789(property) mixins: &#123; [x: string]: any; computed: &#123; [x: string]: () =&gt; any; &#125;; methods: &#123; [x: string]: (...args: any[]) =&gt; Promise&lt;any&gt;; &#125;;&#125;[] utils文件夹下的 mixin.js文件 12345678910111213141516import &#123; mapGetters, mapActions &#125; from 'vuex'export const ebookMixin = &#123; // 这里调用getter.js中的对象，mapGetters方法结合computed将对象中的回调函数执行成相应的数值 computed: &#123; ...mapGetters([ 'fileName', ]) &#125;, // 这里调用actions.js中的方法 methods: &#123; ...mapActions([ 'setFileName', ]) &#125;&#125; 在组件中调用123456789// 导入 mixin 中组件相应的对象import &#123; ebookMixin &#125; from '../../utils/mixin'export default &#123; // 将组件相应的对象在 vue中的mixins 进行注册 mixins: [ebookMixin], methods: &#123; // 在methods中直接通过 this.变量名 this.方法名 就可以了 &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue组件相关知识点和注意点（持续更新）]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2FVue%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[… 动态组件和异步组件官方文档 在动态组件上使用keep-alive官方文档 异步组件【待】难点（待） 未分类组件中this和$el的指向https://www.cnblogs.com/mengfangui/p/9722565.html this 指向组件的实例。 $el 指向当前组件的DOM元素。]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue中的DOM操作相关知识点和方法总结（持续更新）]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2FVue%E4%B8%AD%E7%9A%84DOM%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[… 未分类dom操作建议我们现在虽然用 vue 写代码了，核心思想转变为用数据驱动 view，不用像jQuery时代那样，频繁的操作 DOM 节点。但还是免不了有些场景还是要操作 DOM 的。我们在组件内选择节点的时候一定要切记避免使用 document.querySelector()等一系列的全局选择器。你应该使用this.$el或者this.refs.xxx.$el的方式来选择 DOM。这样就能将你的操作局限在当前的组件内，能避免很多问题。 nextTick官方API文档 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;) 使用示例组件代码： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class="app"&gt; &lt;div ref="msgDiv"&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;div&gt;Message got outside $nextTick: &#123;&#123; msg1 &#125;&#125;&lt;/div&gt; &lt;div&gt;Message got inside $nextTick: &#123;&#123; msg2 &#125;&#125;&lt;/div&gt; &lt;div&gt;Message got outside $nextTick: &#123;&#123; msg3 &#125;&#125;&lt;/div&gt; &lt;button @click="changeMsg"&gt; Change the Message &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: 'Hello Vue.', msg1: '点击前', msg2: '点击前', msg3: '点击前' &#125; &#125;, methods: &#123; changeMsg() &#123; this.msg = 'Hello world.' this.msg1 = this.$refs.msgDiv.innerHTML this.$nextTick(() =&gt; &#123; this.msg2 = this.$refs.msgDiv.innerHTML &#125;) this.msg3 = this.$refs.msgDiv.innerHTML &#125; &#125;&#125;&lt;/script&gt; 点击前后对比： 明显看出： msg1 和 msg3 显示的值还是 msg 的 值变换之前的值：’Hello Vue.’ msg 2显示的内容是 msg 变换之后的值：’Hello world.’ 根本原因是：因为Vue中DOM更新是异步的 应用场景以下场景需要放在 Vue.nextTick() 的回调函数中： 在Vue生命周期的 created() 钩子函数进行的DOM操作 在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候 具体原因在Vue的官方文档中详细解释： Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。 例如，当你设置vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 源码解析参考这篇文章：https://www.jianshu.com/p/a7550c0e164f 参考文章： https://www.jianshu.com/p/a7550c0e164f]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-Router使用总结（持续更新）]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%89%8D%E7%AB%AF%2FVue%2F01-%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2FVue-Router%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[把官方文档通看了一遍，整理下注意点；之后有新的路由相关的也更新在这里 官方教程：https://router.vuejs.org/zh/API文档：https://router.vuejs.org/zh/api/#router-link \&lt;roter-link>和\&lt;roter-view>&lt;roter-link>API文档 &lt;router-view>API文档 Router 构建选项API文档 routes12345678910111213141516declare type RouteConfig = &#123; path: string; // 路径 component?: Component; // 导入组件 name?: string; // 命名路由 components?: &#123; [name: string]: Component &#125;; // 命名视图组件（区别component） redirect?: string | Location | Function; // 重定向 props?: boolean | Object | Function; // ？主要用于命名视图中 alias?: string | Array&lt;string&gt;; // 路由别名 children?: Array&lt;RouteConfig&gt;; // 嵌套子路由 beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void; // 某个路由的生命钩子函数 meta?: any; // 路由元信息 // 2.6.0+ caseSensitive?: boolean; // 匹配规则是否大小写敏感？(默认值：false) pathToRegexpOptions?: Object; // 编译正则的选项&#125; name 我们定义路由时的 name 属性，如下面的例子 12345678910111213export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125;, &#123; path: '/other', component: other &#125; ]&#125;) 根据name渲染组件 通过name属性，为一个页面中不同的router-view渲染不同的组件如：将上面代码的Hello渲染在 name为Hello的router-view中，将text渲染在name为text的router-view中。不设置name的将为默认的渲染组件。 1234567&lt;template&gt; &lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view name="Hello"&gt;&lt;/router-view&gt; // 将渲染Hello组件 &lt;router-view name="text"&gt;&lt;/router-view&gt; // 将渲染text组件 &lt;/div&gt;&lt;/template&gt; 获取组件的name值 使用 $router.name 获取组件name值 123456 &lt;template&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; $route.name &#125;&#125;&lt;/p&gt; // 可以获取到渲染进来的组件的name值 &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 页面渲染时传递参数 1234567&lt;template&gt; &lt;div id="app"&gt; // 向name为hello的组件传参数id，值为12 &lt;router-link ：to="&#123; name:'hello', params:&#123;id: '12'&#125; &#125;"&gt;hello&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; redirect 和 alias官方文档 meta vue-router官方推荐 的方法：通过meta标签来标示改页面能访问的权限有哪些。 定义路由的时候可以配置 meta 字段： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, children: [ &#123; path: 'bar', component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; // 表示访问该页面需要验证 &#125; ] &#125; ]&#125;) 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。 因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。 下面例子展示在全局导航守卫中检查元字段： 123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; // 通过判断元字段requiresAuth的布尔值, 来判断访问该页面是否需要验证 if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // 该页面需要验证 if (!auth.loggedIn()) &#123; // 没有登录=&gt;跳转到登录页面 next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; // 登录=&gt;直接进入该页面 next() &#125; &#125; else &#123; // 该页面不需要验证，直接进入该页面 next() &#125;&#125;) 用法：登录验证 https://blog.csdn.net/cofecode/article/details/79181894&gt; https://www.jb51.net/article/143056.htm&gt; 用法：面包屑导航 https://blog.csdn.net/versionli/article/details/80866572&gt; 用法：根据meta信息展示不同的页面 这个有点儿类似于登录验证的扩展 http://www.cnblogs.com/goloving/p/9074410.html&gt; Router 实例方法 出现形式： router.方法名() this.$router.方法名() 导航守卫 详情： 官方文档 本文：全局路由钩子 123456789101112// 1.全局前置守卫router.beforeEach((to, from, next) =&gt; &#123; /* must call `next` */&#125;)// 2.全局解析守卫router.beforeResolve((to, from, next) =&gt; &#123; /* must call `next` */&#125;)// 3.全局后置钩子router.afterEach((to, from) =&gt; &#123;&#125;) 编程式导航 具体： 官方文档 本文：路由的跳转 12345678910// 1.导航到不同的 url，向 history 栈添加一个新的记录router.push(location, onComplete?, onAbort?)// 2.导航到不同 url，替换 history 栈中当前记录router.replace(location, onComplete?, onAbort?)// 3. 指定前进/回退的步数（通过正负来判断前进）router.go(n)// 4.回退一步router.back()// 5.前进一步router.forward() route 路由对象概念官方文档 一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。 路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象。 路由对象出现在多个地方: 在组件内，即 this.$route 当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。 在 $route 观察者回调内 router.match(location) 的返回值 导航守卫的参数： 123router.beforeEach((to, from, next) =&gt; &#123; // `to` 和 `from` 都是路由对象&#125;) scrollBehavior 方法的参数: 12345const router = new VueRouter(&#123; scrollBehavior (to, from, savedPosition) &#123; // `to` 和 `from` 都是路由对象 &#125;&#125;) 属性 路由对象属性：this.$route.属性名 $route.path 类型: string 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 $route.params 类型: Object 一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 $route.hash 类型: string 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 $route.fullPath 类型: string 完成解析后的 URL，包含查询参数和 hash 的完整路径。 $route.matched 类型: Array&lt;RouteRecord&gt; 一个数组，包含当前路由的所有嵌套路径片段的路由记录 。 路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。 1234567891011const router = new VueRouter(&#123; routes: [ // 下面的对象就是路由记录 &#123; path: '/foo', component: Foo, children: [ // 这也是个路由记录 &#123; path: 'bar', component: Bar &#125; ] &#125; ]&#125;) 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象 (副本)。 $route.name 当前路由的名称，如果有的话。(查看命名路由) $route.redirectedFrom 如果存在重定向，即为重定向来源的路由的名字。(参阅重定向和别名) 路由的生命钩子函数就是官方文档中的 导航守卫 在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。 定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。 ⭐总体来讲vue里面提供了三大类钩子： 全局钩子（一般定义在 main.js 文件中） 某个路由的钩子（一般定义在 router.js 文件中） 组件内钩子（一般定义的具体的 .vue 组件文件中，和 data , methods 平级） 类型1：全局路由钩子在 main.js 入口文件中： router.beforeEach() router.beforeResolve() router.afterEach() 123456789101112131415// main.js// 1.全局前置守卫：当一个导航触发时，全局前置守卫按照创建顺序调用。// 守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中router.beforeEach((to, from, next) =&gt; &#123; /* must call `next` */&#125;)// 2.全局解析守卫：在导航被确认之前，同时在所有组件内守卫和异步路由组件被 resolve 之后router.beforeResolve((to, from, next) =&gt; &#123; /* must call `next` */&#125;)// 3.全局后置钩子：导航被确认（跳转）之后router.afterEach((to, from) =&gt; &#123;&#125;) 类型2：某个路由的钩子 参数和方法同全局钩子一样 12345678910111213141516171819// router.jsconst router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; beforeResolve: (to, from, next) =&gt; &#123; // ... &#125; afterEach: (to, from) =&gt; &#123; // ... &#125; &#125; ]&#125;) 类型3：组件内的路由钩子详细见：官方文档 123456789101112131415161718// 某个vue组件中export default &#123; data() &#123;&#125;, methods: &#123;&#125;, // 1.在渲染该组件的对应路由被 confirm 前调用 beforeRouteUpdate(to, from, next) &#123; next() &#125;, // 2.在当前路由改变，但是该组件被复用时调用 beforeRouteEnter(to, from, next) &#123; next() &#125;, // 3.导航离开该组件的对应路由时调用 beforeRouteLeave(to, from, next) &#123; next() &#125;&#125; 钩子函数的参数每个守卫方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: &#39;home&#39; 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 确保要调用 next 方法，否则钩子就不会被 resolved。 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用（组件） beforeRouteEnter 守卫中传给 next 的回调函数。 路由的跳转声明式和编程式当你点击 &lt;router-link&gt; 时，这个方法会在路由实例内部调用所以说，点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(...) 声明式 编程式 &lt;router-link :to=&quot;...&quot;&gt; router.push(...) router-link 不带参数 12&lt;router-link :to="&#123;name:'home'&#125;"&gt;&lt;router-link :to="&#123;path:'/home'&#125;"&gt; ❗ 注意： name，path都行，建议用name注意：router-link中链接如果是’/‘开始就是从根路由开始，如果开始不带’/‘，则从当前路由开始 带参数（params） 1&lt;router-link :to="&#123;name:'home', params: &#123;id:1&#125;&#125;"&gt; 带参数（query） 1&lt;router-link :to="&#123;name:'home', query: &#123;id:1&#125;&#125;"&gt; this.$router.push() 不带参数 123this.$router.push('/home')this.$router.push(&#123;name:'home'&#125;)this.$router.push(&#123;path:'/home'&#125;) query传参 123this.$router.push(&#123; name:'home',query: &#123;id:'1'&#125; &#125;)this.$router.push(&#123; path:'/home',query: &#123;id:'1'&#125; &#125;)this.$router.push(&#123; path: `/home/$&#123;id&#125;` &#125;) params传参 1this.$router.push(&#123; name:'home',params: &#123;id:'1'&#125; &#125;) // 只能用 name this.$router.replace() 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录而是跟它的方法名一样 —— 替换掉当前的 history 记录。 this.$router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 123456789101112131415161718// 向前或者向后跳转n个页面，n为正数的时候是前进；负数的时候是后退；0的时候是刷新当前页面this.$router.go(n)// 1.在浏览器记录中前进一步，等同于 history.forward()this.$router.go(1)// 2.后退一步记录，等同于 history.back()this.$router.go(-1)// 3.刷新当前页面this.$router.go(0)// 4.前进 3 步记录this.$router.go(3)// 5.如果 history 记录不够用，那就默默地失败呗this.$router.go(-100)this.$router.go(100) forward和back12345// 后退this.$router.back()// 前进this.$router.forward() 区别 this.$router.push跳转到指定url路径，并向history栈中添加一个记录，点击后退会返回到上一个页面 this.$router.replace跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面) this.$router.go(n)向前或者向后跳转n个页面，n可为正整数或负整数 vue路由的传参方式 方式1-通过query字符串 方式2-通过params参数 query和params区别 query类似 get, 跳转之后页面 url后面会拼接参数,类似 ?id=1 , 非重要性的可以这样传, 密码之类还是用params刷新页面id还在 params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失 取参 query： html 取参 $route.query.idscript 取参 this.$route.query.id params： html 取参 $route.params.idscript 取参 this.$route.params.id 路由懒加载官方文档 示例： 12345678// vue-cli 2.0 的懒加载const Index = resolve =&gt; require(['./views/Index.vue'], resolve)// vue-cli 3.0 的懒加载const Index = () =&gt; import('./views/Index.vue')// 在路由中component: () =&gt; import('./views/Index.vue'), // vue路由懒加载 异步加载 易混淆概念this.$router 和 this.$route 的区别 this.$router Vue-Router 的实例 (全局路由对象)，用来进行路由操作，包含一系列路由的处理方法 1234this.$router.push('/') // 跳转到根目录，保留历史记录，可以返回this.$router.replace('/') // 跳转到根目录，替换掉当前历史记录，无法返回替换前的页面this.$router.back() // 返回上一个页面this.$router.go(1) // 1 为向前跳转，-1 为返回(相当于back) this.$route 表示当前正在用于跳转的路由器对象，包含当前路由的 name、path、query、params 等属性 待深入 路由组件传参 routes中的props属性 命名视图 有时候想同时 (同级) 展示多个视图，而不是嵌套展示例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。官方文档 参考文章： https://www.cnblogs.com/WQLong/p/8135553.html]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>文档总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sass使用总结（持续更新）]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2Fsass%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[🐰 sass总文档：sass官方文档整理 优秀文章未分类 自定义的Sass混合宏来处理浏览器所需的私有前缀 Sass和compass Sass &amp; Compass 初步使用 在Vue中使用Compass 慕课网课 sass目录结构组织 组织你的Sass文件 流行框架的 Sass 体系结构解析 基于Sass的BootStrap4的源码目录结构-学习笔记 常用指令@mixins 详细请看： sass官方文档整理 第9章的内容 直接使用公共样式不带变量 12345@mixin right &#123; display: flex; justify-content: flex-end; align-items: center;&#125; 需要自定义样式 带参数变量 12345678910// 文字超过xx行省略显示@mixin ellipsis2($line) &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: $line; white-space: normal; overflow: hidden; text-overflow: ellipsis; word-break: keep-all;&#125; 带参数变量并设定默认值 1234567@mixin button($background: green) &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: $background; &#125; 使用@content 该方法可以新加入新的样式进去（跟使用@include后添加样式一样的效果） 也可以写原本就有的样式，不同的值，覆盖原本的样式 这样编译出来的css代码不够优雅，谨慎使用 @include 详细请看： sass官方文档整理 9.2 在用 @mixin 声明了公共样式后，用 @include 引用公共样式 123456789101112131415// 声明@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; // 使用 padding: 4px; margin-top: 10px;&#125; @extend 详细请看：sass官方文档整理 7.3 sass 将一个选择器下的所有样式继承给另一个选择器 12345678.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 常用语法循环语法 这个-的命名方式可以借鉴 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译为 123456.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 变量 $ 详情：sass官方文档整理 6.2 变量定义 !default 详情：sass官方文档整理 6.9 可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值 如果变量已经被赋值，不会再被重新赋值 如果变量还没有被赋值，则会被赋予新的值 12345678$content: "First content";$content: "Second content?" !default;$new_content: "First time reference" !default;#main &#123; content: $content; // 已经被赋值 new-content: $new_content; //未被赋值&#125; 编译为 123#main &#123; content: "First content"; // 为最初的值，没有发生改变 new-content: "First time reference"; &#125; // 新赋的值 变量是 null 空值时将视为未被 !default 赋值 123456$content: null;$content: "Non-null content" !default;#main &#123; content: $content;&#125; 编译为 123#main &#123; content: "Non-null content"; &#125; 其他重点总结&amp; 的妙用&amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如 1234#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125; 编译为 1234#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 属性嵌套 可以了解，但是没有太大的必要… 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。 为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 符号代称 @mixin ：可以用 = 表示 @include ：可以用 + 表示 易混淆 sass中的占位符%，@extend，@mixin（@include）的编译区别和使用场景 Sass:@mixin和extend的选择 使用小demo变量相关设置渐变主题色1234567891011$--color-primary: #409EFF !default;$--color-white: #FFFFFF !default;$--color-primary-light-1: mix($--color-white, $--color-primary, 10%) !default; /* 53a8ff */$--color-primary-light-2: mix($--color-white, $--color-primary, 20%) !default; /* 66b1ff */$--color-primary-light-3: mix($--color-white, $--color-primary, 30%) !default; /* 79bbff */$--color-primary-light-4: mix($--color-white, $--color-primary, 40%) !default; /* 8cc5ff */$--color-primary-light-5: mix($--color-white, $--color-primary, 50%) !default; /* a0cfff */$--color-primary-light-6: mix($--color-white, $--color-primary, 60%) !default; /* b3d8ff */$--color-primary-light-7: mix($--color-white, $--color-primary, 70%) !default; /* c6e2ff */$--color-primary-light-8: mix($--color-white, $--color-primary, 80%) !default; /* d9ecff */$--color-primary-light-9: mix($--color-white, $--color-primary, 90%) !default; /* ecf5ff */]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端第三方插件（持续更新）]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F%E5%89%8D%E7%AB%AF%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主要放用过或常用的插件汇总 CSS normalize.css （格式化css） Vue插件路由相关 vue-navigation 实现前进刷新，后退不刷新。 前进、后退分别使用不同的过场动画。 组件相关vue-create-apivue插件：vue-create-api 一个能够让 Vue 组件通过 API 方式调用的插件 引入组价的传统方式：import组件=&gt;注册组件=&gt;dom上引入组价=&gt;通过ref调用组件上的方法 该插件以全新的方式，减少了组件之间的耦合度 首先安装这个插件 1$ npm i vue-create-api -S 编辑 create-api.js 文件 123456789101112131415161718import CreateAPI from 'vue-create-api'import Vue from 'vue'// 下面引入vue组件，这里以Toast为例import Toast from '../components/common/Toast'Vue.use(CreateAPI)Vue.createAPI(Toast, true)// 这里引入Vue.mixin是为了使调用组件的时候更加简便（可省略）Vue.mixin(&#123; methods: &#123; toast(settings) &#123; return this.$createToast(&#123; $props: settings &#125;) &#125; &#125;&#125;) 在 main.js 中引入该文件 1import './utils/create-api' 在页面引用组件（并调用该组件的方法） 123onclick(item) &#123; this.toast(&#123; text: 'hello'&#125;).show()&#125; 表单相关 vee-validate （表单验证） vue-multiselect （下拉框组件） 弹出框 vue-js-modal v-tooltip （提示框组件） 图片相关 v-img （图片全屏显示插件）]]></content>
      <categories>
        <category>工具</category>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sass官方文档整理]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2Fdoc%2Fsass%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[🐰 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 特色功能 (Features) 完全兼容 CSS3 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能 通过函数进行颜色值与属性值的运算 提供控制指令 (control directives)等高级功能 自定义输出格式 语法格式 (Syntax)Sass 有两种语法格式。 首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。 另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 “Sass”，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference。这种格式以 .sass 作为拓展名。 任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式： 12345# Convert Sass to SCSS$ sass-convert style.sass style.scss# Convert SCSS to Sass$ sass-convert style.scss style.sass 使用 Sass (Using Sass) 这个暂时可以不看，npm的方式没这么麻烦 Sass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先安装 Ruby）： 1gem install sass 在命令行中运行 Sass： 1sass input.scss output.css 监视单个 Sass 文件，每次修改并保存时自动编译： 1sass --watch input.scss:output.css 监视整个文件夹： 1sass --watch app/sass:public/stylesheets 更多命令的用法请通过 sass --help 获取帮助。 在 Ruby 中使用 Sass 也非常容易，Sass gem 安装完毕后运行 require &quot;sass&quot; 然后按照下面的方法使用 Sass::Engine： 12engine = Sass::Engine.new(&quot;#main &#123;background-color: #0000ff&#125;&quot;, :syntax =&gt; :scss)engine.render #=&gt; &quot;#main &#123; background-color: #0000ff; &#125;\n&quot; Rack/Rails/Merb Plugin在 Rails 3 之前的版本中使用 Sass，需要在 environment.rb 文件中添加： 1config.gem &quot;sass&quot; Rails 3 则需要在 Gemfile 中添加： 1gem &quot;sass&quot; 在 Merb 中使用 Sass，需要在 config/dependencies.rb 中添加： 1dependency &quot;merb-haml&quot; 在 Rack 中使用 Sass，需要在 config.ru 中添加： 12require &apos;sass/plugin/rack&apos;use Sass::Plugin::Rack 样式文件与 views 不同，不包含任何动态内容，因此 CSS 只需要在 Sass 文件被修改后再编译生成。默认情况下 .sass 与 .scss 文件放置在 public/stylesheets/sass 中（可通过 :template_location 修改路径），编译生成的 CSS 文件放置在 public/stylesheets 中。例如 public/stylesheets/sass/main.scss 编译生成 public/stylesheets/main.css。 缓存 (Caching)Sass 自动缓存编译后的模板与 partials，这样做能够显著提升重新编译的速度，尤其在处理由 @import 导入多个子文件的大型项目时。 单独使用 Sass，缓存内容保存在 .sass-cache 文件夹中。在 Rails 和 Merb 项目中缓存文件保存在 tmp/sass-cache 文件夹中（可通过 :cache_location 修改路径）。禁用缓存可将 :cache 设为 false。 配置选项 (Options)暂未翻译 判断语法格式 (Syntax Selection)Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。 编码格式 (Encodings)在 Ruby 1.9 及以上环境中运行 Sass 时，Sass 对文件的编码格式比较敏感，首先会根据 CSS spec 判断样式文件的编码格式，如果失败则检测 Ruby string encoding。也就是说，Sass 首先检查 Unicode byte order mark，然后是 @charset 声明，最后是 Ruby string encoding，假如都没有检测到，默认使用 UTF-8 编码。 与 CSS 相同，使用 @charset 可以声明特定的编码格式。在样式文件的起始位置（前面没有任何空白与注释）插入 @charset &quot;encoding-name&quot;， Sass 将会按照给出的编码格式编译文件。注意所使用的编码格式必须可转换为 Unicode 字符集。 Sass 以 UTF-8 编码输出 CSS 文件，当且仅当编译后的文件中包含非 ASCII 字符时，才会在输出文件中添加 @charset 声明，而在压缩模式下 (compressed mode) 使用 UTF-8 byte order mark 代替 @charset 声明语句。 CSS 功能拓展嵌套规则Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 123456789#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125; 编译为 123456#main p &#123; color: #00ff00; width: 97%; &#125; #main p .redbox &#123; background-color: #ff0000; color: #000000; &#125; 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理： 但该功能也容易导致不必要的多层嵌套，谨慎使用！ 12345678910#main &#123; width: 97%; p, div &#123; font-size: 2em; a &#123; font-weight: bold; &#125; &#125; pre &#123; font-size: 3em; &#125;&#125; 编译为 12345678#main &#123; width: 97%; &#125; #main p, #main div &#123; font-size: 2em; &#125; #main p a, #main div a &#123; font-weight: bold; &#125; #main pre &#123; font-size: 3em; &#125; 父选择器 &amp;在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器 例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp;代表嵌套规则外层的父选择器。 123456a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; 编译为 1234567a &#123; font-weight: bold; text-decoration: none; &#125; a:hover &#123; text-decoration: underline; &#125; body.firefox a &#123; font-weight: normal; &#125; 编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递： 1234567#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125; 编译为 123456#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; &amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如 1234#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125; 编译为 1234#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 属性嵌套有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 占位符选择器 %fooSass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。 与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 7.3.6 @extend-Only Selectors。 当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。 几种不同的注释方式Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如： 12345678910/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won't appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125; 编译为 123456789/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;a &#123; color: green; &#125; 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 插值语句 (interpolation) 也可写进多行注释中输出变量值： 12$version: "1.2.3";/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. */ 编译为 1/* This CSS is generated by My Snazzy Framework version 1.2.3. */ SassScript在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。 通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。 Interactive Shell Interactive Shell 可以在命令行中测试 SassScript 的功能。 在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果： 123456789$ sass -i&gt;&gt; "Hello, Sassy World!""Hello, Sassy World!"&gt;&gt; 1px + 1px + 1px3px&gt;&gt; #777 + #777#eeeeee&gt;&gt; #777 + #888white 变量 $ (Variables: $) SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样： 1$width: 5em; 直接使用即调用变量： 123#main &#123; width: $width;&#125; 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。 将局部变量转换为全局变量可以添加 !global 声明： 12345678#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; 编译为 1234567#main &#123; width: 5em;&#125;#sidebar &#123; width: 5em;&#125; 数据类型SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。 6.3.1. 字符串SassScript 支持 CSS 的两种字符串类型： 有引号字符串 (quoted strings)，如 &quot;Lucida Grande&quot; &#39;http://sass-lang.com&#39;； 无引号字符串 (unquoted strings)，如 sans-serif bold 在编译 CSS 文件时不会改变其类型。 只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名： 123456@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: "Hi, Firefox users!"; &#125;&#125;@include firefox-message(".header"); 编译为 12body.firefox .header:before &#123; content: "Hi, Firefox users!"; &#125; 6.3.2. 数组 (Lists)数组 (lists) 指 ： Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。 数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能： nth 函数可以直接访问数组中的某一项； join 函数可以将多个数组连接在一起； append 函数可以在数组中添加新值； @each 指令能够遍历数组中的每一项。 什么东西…. 数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。 如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。 变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。 6.3.3. Maps1scss $map: (key1: value1, key2: value2, key3: value3); 简要说明： Maps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键值对被都好分割 。 Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式 arbitrary SassScript expressions） 和Lists一样Maps主要为sassscript函数服务，如 map-get函数用于查找键值，map-merge函数用于map和新加的键值融合， @each命令可添加样式到一个map中的每个键值对。 Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。(网友Soledad提供) 6.3.4. 颜色 (Colors) Any CSS color expression returns a SassScript Color value. 任何CSS颜色表达式都返回一个SassScript颜色值。 This includes a large number of named colors which are indistinguishable from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. 用户在使用命名颜色时遇到的一个常见问题是，由于Sass喜欢与在其他输出模式中输入的输出格式相同，所以在压缩时，内插到选择器中的颜色将成为无效语法。 To avoid this, always quote named colors if they are meant to be used in the construction of a selector. 为了避免这种情况，如果要在选择器的构造中使用命名颜色，请始终引用它们。 运算所有数据类型均支持相等运算 1== 或 1!= 此外，每种数据类型也有其各自支持的运算方式。 6.4.1. 数字运算SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。 123p &#123;. width: 1in + 8pt;&#125; 编译为 12p &#123; width: 1.111in; &#125; 关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。 6.4.1.1. 除法运算 // 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。 以下三种情况 / 将被视为除法运算符号： 如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 12345678p &#123; font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division&#125; 编译为 12345p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; &#125; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为 12p &#123; font: 12px/30px; &#125; 6.4.2. 颜色值运算颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值： 123p &#123; color: #010203 + #040506;&#125; 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为 12p &#123; color: #050709; &#125; 使用 color functions 比计算颜色值更方便一些。 数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如 123p &#123; color: #010203 * 2;&#125; 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为 12p &#123; color: #020406; &#125; 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 123p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125; 编译为 12p &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。 12345$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25);&#125; 编译为 123p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。 12345$translucent-red: rgba(255, 0, 0, 0.5);$green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=&apos;#&#123;ie-hex-str($green)&#125;&apos;, endColorstr=&apos;#&#123;ie-hex-str($translucent-red)&#125;&apos;);&#125; 编译为 123div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 6.4.3. 字符串运算+ 可用于连接字符串 123p &#123; cursor: e + -resize;&#125; 编译为 12p &#123; cursor: e-resize; &#125; 注意左侧，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。 1234p:before &#123; content: "Foo " + Bar; font-family: sans- + "serif";&#125; 编译为 123p:before &#123; content: "Foo Bar"; font-family: sans-serif; &#125; 运算表达式与其他值连用时，用空格做连接符： 123p &#123; margin: 3px + 4px auto;&#125; 编译为 12p &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值： 123p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125; 编译为 12p:before &#123; content: "I ate 15 pies!"; &#125; 空的值被视作插入了空字符串： 1234$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125; 编译为 12p:before &#123; content: "I ate pies!"; &#125; 6.4.4. 布尔运算SassScript 支持布尔型的 and or 以及 not 运算。 6.4.5. 数组运算数组不支持任何运算方式，只能使用 list functions 控制。 圆括号圆括号可以用来影响运算的顺序： 123p &#123; width: 1em + (2em * 3);&#125; 编译为 12p &#123; width: 7em; &#125; 函数 (Functions)SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用： 123p &#123; color: hsl(0, 100%, 50%);&#125; 编译为 12p &#123; color: #ff0000; &#125; 6.6.1. 关键词参数Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成： 123p &#123; color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);&#125; 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。 通过 Sass::Script::Functions 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。 插值语句 #{}通过 #{} 插值语句可以在 选择器 或 属性名 中使用变量： 12345$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; 编译为 12p.foo &#123; border-color: blue; &#125; #{} 插值语句也可以在属性值中插入 SassScript 大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为 12p &#123; font: 12px/30px; &#125; &amp; in SassScript如果没有父选择器，&amp;的值将为null。这意味着你可以在mixin中使用它来检测父选择器是否存在: 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 变量定义 !default可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。 12345678$content: "First content";$content: "Second content?" !default;$new_content: "First time reference" !default;#main &#123; content: $content; new-content: $new_content;&#125; 编译为 123#main &#123; content: "First content"; new-content: "First time reference"; &#125; 变量是 null 空值时将视为未被 !default 赋值。 123456$content: null;$content: "Non-null content" !default;#main &#123; content: $content;&#125; 编译为 12#main &#123; content: "Non-null content"; &#125; @-Rules 与指令Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。 @importSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。 Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。 通常，@import 寻找 Sass 文件并将其导入 但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件： 文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。 1@import "foo.scss"; 或 1@import "foo"; 都会导入文件 foo.scss，但是 1234@import "foo.css";@import "foo" screen;@import "http://foo.com/bar";@import url(foo); 编译为 1234@import "foo.css";@import "foo" screen;@import "http://foo.com/bar";@import url(foo); Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件： 1@import "rounded-corners", "text-shadow"; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： 12$family: unquote("Droid+Sans");@import url("http://fonts.googleapis.com/css?family=\#&#123;$family&#125;"); 编译为 1@import url("http://fonts.googleapis.com/css?family=Droid+Sans"); 7.1.1. 分音如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。 例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。 1@import "colors"; 上面的例子，导入的其实是 _colors.scss 文件 注意：不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 7.1.2. 嵌套 @import大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import 其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。 假设 example.scss 文件包含以下样式： 123.example &#123; color: red;&#125; 然后导入到 #main 样式内 123#main &#123; @import "example";&#125; 将会被编译为 123#main .example &#123; color: red;&#125; 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。 @mediaSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。 如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。 这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。 123456.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125; 编译为 12345.sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and 1234567@media screen &#123; .sidebar &#123; @media (orientation: landscape) &#123; width: 500px; &#125; &#125;&#125; 编译为 123@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值： 123456789$media: screen;$feature: -webkit-min-device-pixel-ratio;$value: 1.5;@media #&#123;$media&#125; and ($feature: $value) &#123; .sidebar &#123; width: 500px; &#125;&#125; 编译为 123@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; .sidebar &#123; width: 500px; &#125; &#125; @extend在设计网页的时候常常遇到这种情况： 一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。 通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。 假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写： 123&lt;div class="error seriousError"&gt; Oh no! You've been hacked!&lt;/div&gt; 样式如下 1234567.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125; 麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变： 比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。 使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。 12345678.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 上面代码的意思是：将 .error 下的所有样式继承给 .seriousError border-width: 3px; 是单独给 .seriousError 设定特殊样式 这样，dom元素中使用 .seriousError 的地方可以不再使用 .error。 其他使用到 .error 的样式也会同样继承给 .seriousError 例如，另一个样式 .error.intrusion 使用了 hacked.png 做背景，&lt;div class=&quot;seriousError intrusion&quot;&gt; 也同样会使用 hacked.png 背景。 123.error.intrusion &#123; background-image: url("/image/hacked.png");&#125; 7.3.1. 原理@extend 的作用是：将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子： 1234567891011.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url("/image/hacked.png");&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 编译为 123456789.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.error.intrusion, .seriousError.intrusion &#123; background-image: url("/image/hacked.png"); &#125;.seriousError &#123; border-width: 3px; &#125; 当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。 7.3.2. 延伸复杂的选择器 (Extending Complex Selectors) Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=&quot;http://&quot;] 等，例如： 123.hoverlink &#123; @extend a:hover;&#125; 同 class 元素一样，a:hover 的样式将继承给 .hoverlink。 123456.hoverlink &#123; @extend a:hover;&#125;a:hover &#123; text-decoration: underline;&#125; 编译为 12a:hover, .hoverlink &#123; text-decoration: underline; &#125; 与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如： 123456.hoverlink &#123; @extend a:hover;&#125;.comment a.user:hover &#123; font-weight: bold;&#125; 编译为 12.comment a.user:hover, .comment .user.hoverlink &#123; font-weight: bold; &#125; 7.3.3. 多重延伸 (Multiple Extends) 同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器： 12345678910111213.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; @extend .error; @extend .attention; border-width: 3px;&#125; 编译为 12345678910.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为 .attention 在 .error 之后定义。 多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; `@extend.attention` 有相同的效果。 7.3.4. 继续延伸 (Chaining Extends) 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如： 12345678910111213141516.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为： 12345678910111213.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 7.3.5. 选择器列 (Selector Sequences) 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素 但是，却可以将其他元素延伸给选择器列： 12345678910#fake-links .link &#123; @extend a;&#125;a &#123; color: blue; &amp;:hover &#123; text-decoration: underline; &#125;&#125; 编译为 1234a, #fake-links .link &#123; color: blue; &#125; a:hover, #fake-links .link:hover &#123; text-decoration: underline; &#125; 7.3.5.1. 合并选择器列 (Merging Selector Sequences) 有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125; 技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。 当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125; 编译为 1234#admin .tabbar a,#admin .tabbar #demo .overview .fakelink,#demo .overview #admin .tabbar .fakelink &#123; font-weight: bold; &#125; 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#admin .overview .fakelink &#123; @extend a;&#125; 编译为 1234#admin .tabbar a,#admin .tabbar .overview .fakelink,#admin .overview .tabbar .fakelink &#123; font-weight: bold; &#125; 7.3.6. @extend-Only 选择器 %有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。 如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors) 看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 % 可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。 123456// This ruleset won't be rendered on its own.#context a%extreme &#123; color: blue; font-weight: bold; font-size: 2em;&#125; % 占位符选择器需要通过延伸指令 @extend 使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。 123.notice &#123; @extend %extreme;&#125; 编译为 1234#context a.notice &#123; color: blue; font-weight: bold; font-size: 2em; &#125; 7.3.7. !optional 声明 (The !optional Flag)如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice时也会报错，因为 h1 与 a 冲突，会生成新的选择器。 如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如： 123a.important &#123; @extend .notice !optional;&#125; 7.3.8. 在指令中使用@extend在指令中使用 @extend 时（比如在 @media 中）有一些限制： Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。 下面的例子是可行的： 12345678910@media print &#123; .error &#123; border: 1px #f00; background-color: #fdd; &#125; .seriousError &#123; @extend .error; border-width: 3px; &#125;&#125; 但不可以这样： 123456789101112.error &#123; border: 1px #f00; background-color: #fdd;&#125;@media print &#123; .seriousError &#123; // INVALID EXTEND: .error is used outside of the "@media print" directive @extend .error; border-width: 3px; &#125;&#125; 希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。 @at-rootThe @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector: 1234.parent &#123; ... @at-root .child &#123; ... &#125;&#125; Which would produce: 12.parent &#123; ... &#125;.child &#123; ... &#125; Or it can be used with a block containing multiple selectors: 12345678.parent &#123; ... @at-root &#123; .child1 &#123; ... &#125; .child2 &#123; ... &#125; &#125; .step-child &#123; ... &#125;&#125; Which would output the following: 1234.parent &#123; ... &#125;.child1 &#123; ... &#125;.child2 &#123; ... &#125;.parent .step-child &#123; ... &#125; 7.4.1. @at-root (without: …) and @at-root (with: …)By default, @at-root just excludes selectors. However, it’s also possible to use @at-root to move outside of nested directives such as @media as well. For example: 12345678@media print &#123; .page &#123; width: 8in; @at-root (without: media) &#123; color: red; &#125; &#125;&#125; produces: 12345678@media print &#123; .page &#123; width: 8in; &#125;&#125;.page &#123; color: red;&#125; You can use @at-root (without: …) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries. There are two special values you can pass to @at-root. “rule” refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules. If you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules. @debugThe @debug directive prints the value of a SassScript expression to the standard error output stream. It’s useful for debugging Sass files that have complicated SassScript going on. For example: 1@debug 10em + 12em; 编译为 1Line 1 DEBUG: 22em @warnThe @warn directive prints the value of a SassScript expression to the standard error output stream. It’s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug: You can turn warnings off with the –quiet command-line option or the :quiet Sass option. A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning. Usage Example: 1234567891011@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @warn &quot;Assuming #&#123;$x&#125; to be in pixels&quot;; $x: 1px * $x; &#125; @if unitless($y) &#123; @warn &quot;Assuming #&#123;$y&#125; to be in pixels&quot;; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125; @warnThe @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It’s useful for validating arguments to mixins and functions. For example: 123456789@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @error &quot;$x may not be unitless, was #&#123;$x&#125;.&quot;; &#125; @if unitless($y) &#123; @error &quot;$y may not be unitless, was #&#123;$y&#125;.&quot;; &#125; position: relative; left: $x; top: $y;&#125; There is currently no way to catch errors. 控制指令 (Control Directives)SassScript 提供了一些基础的控制指令 比如在满足一定条件时引用样式，或者设定范围重复输出格式。 控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。 if()The built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero). @if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码： 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 编译为 12p &#123; border: 1px solid; &#125; @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。 如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如： 123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 编译为 12p &#123; color: green; &#125; @for@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。 这个指令包含两种格式： for $var from &lt;start&gt; through &lt;end&gt; @for $var from &lt;start&gt; to &lt;end&gt; 区别在于 through 与 to 的含义： 当使用 through 时，条件范围包含 &lt;start&gt; 与 &lt;end&gt; 的值 而使用 to时条件范围只包含 &lt;start&gt; 的值不包含 &lt;end&gt; 的值 另外： $var 可以是任何变量，比如 $i； &lt;start&gt; 和 &lt;end&gt; 必须是整数值。 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译为 123456.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; @each@each 指令的格式是 $var in &lt;list&gt;, $var 可以是任何变量名，比如 $length 或者 $name，而 &lt;list&gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如： 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 编译为 12345678.puma-icon &#123; background-image: url('/images/puma.png'); &#125;.sea-slug-icon &#123; background-image: url('/images/sea-slug.png'); &#125;.egret-icon &#123; background-image: url('/images/egret.png'); &#125;.salamander-icon &#123; background-image: url('/images/salamander.png'); &#125; 8.4.1 Multiple AssignmentThe @each directive can also use multiple variables, as in @each $var1, $var2, … in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example: 123456789@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125; is compiled to: 123456789101112.puma-icon &#123; background-image: url('/images/puma.png'); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url('/images/sea-slug.png'); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url('/images/egret.png'); border: 2px solid white; cursor: move; &#125; Since maps are treated as lists of pairs, multiple assignment works with them as well. For example: 由于映射被视为成对的列表，因此多个赋值也可以使用它们。例如: 12345@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; is compiled to: 123456h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; @while@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 12345678.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 混合指令 @mixin混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 定义混合指令 @mixin混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： 12345678@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器： 1234567891011@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 引用混合样式 @include使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）： 12345.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 编译为 1234567.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。 1234567@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 编译为 123a &#123; color: blue; background-color: red; &#125; 混合样式中也可以包含其他混合样式，比如 123456@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。 参数 ($arg: value)参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号： 12345678@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 1in); &#125; 编译为 1234p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值： 123456789@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125; 编译为 123456789p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 9.3.1. 关键词参数混合指令也可以使用关键词参数，上面的例子也可以写成： 12p &#123; @include sexy-border($color: blue); &#125;h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125; 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。 9.3.2. 参数变量有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 ‘shadow’ 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理： 12345678@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 编译为 12345.shadowed &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用： 123456789@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;.primary &#123; @include colors($values...);&#125; 编译为 12345.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff;&#125; You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example: 12345678@mixin wrapped-stylish-mixin($args...) &#123; font-weight: bold; @include stylish-mixin($args...);&#125;.stylish &#123; // The $width argument will get passed on to "stylish-mixin" as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px);&#125; 上面注释内的意思是：$width 参数将会传递给 stylish-mixin 作为关键词。 向混合样式中导入内容 @content在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 更直观的例子 12345678910@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; 编译为 123* html #logo &#123; background-image: url(/logo.gif);&#125; 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成： 1234567=apply-to-ie6-only * html @content+apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。 9.4.1. Variable Scope and Content Blocks The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value: 123456789$color: white;@mixin colors($color: blue) &#123; background-color: $color; @content; border-color: $color;&#125;.colors &#123; @include colors &#123; color: $color; &#125;&#125; 编译为 12345.colors &#123; background-color: blue; color: white; border-color: blue;&#125; Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example: 1234567#sidebar &#123; $sidebar-width: 300px; width: $sidebar-width; @include smartphone &#123; width: $sidebar-width / 3; &#125;&#125; 函数指令 (Function Directives)Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用： 12345678$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;#sidebar &#123; width: grid-width(5); &#125; 编译为 12#sidebar &#123; width: 240px; &#125; 与 mixin 相同，也可以传递若干个全局变量给函数作为参数。 一个函数可以含有多条语句，需要调用 @return 输出结果。 自定义的函数也可以使用关键词参数，上面的例子还可以这样写： 1#sidebar &#123; width: grid-width($n: 5); &#125; 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。 自定义函数与 mixin 相同，都支持 variable arguments 输出格式 (Output Style)Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。 Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 --style 选项。 :nestedNested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。 12345678910#main &#123; color: #fff; background-color: #000; &#125; #main p &#123; width: 10em; &#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline; &#125; :expandedExpanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。 12345678910111213#main &#123; color: #fff; background-color: #000;&#125;#main p &#123; width: 10em;&#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline;&#125; :compactCompact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。 1234#main &#123; color: #fff; background-color: #000; &#125;#main p &#123; width: 10em; &#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline; &#125; :compressedCompressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。 1#main&#123;color:#fff;background-color:#000&#125;#main p&#123;width:10em&#125;.huge&#123;font-size:10em;font-weight:bold;text-decoration:underline&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>🐰未分类🐰</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端居中布局的最佳方案]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%89%8D%E7%AB%AF%2FHTML%E5%92%8CCSS%2F%E5%B8%83%E5%B1%80%2F%E5%89%8D%E7%AB%AF%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[🐰 pc端最佳方案垂直居中父盒子有高度时 无法兼容IE8 123456div&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, 50%);&#125; 兼容IE6 12345678div&#123; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto;&#125; 父盒子无高度时 用于登录类页面在页面居中（有时候可能body的高度为0时，只能用下面的方式） 123456.box&#123; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 移动端最佳方案（flex）垂直居中 利用flex布局 12345678div&#123; display: flex; align-items: center; justify-content: center; width: 18em; height: 10em; margin: auto;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML和CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🍉工具安利.md]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%B7%A5%E5%85%B7%2F%F0%9F%8D%89%E5%B7%A5%E5%85%B7%E5%AE%89%E5%88%A9%2F</url>
    <content type="text"><![CDATA[🐰… 未 WhatFont 特性: 在网络上找到最棒的字体 排版对网页设计而言是一个巨大的挑战，而且并不是一件很容易的事。要找到合适的字体是很累人的，但是使用例如WhatFont 的扩展插件，可以减轻你在搜索时的痛苦。 你只需添加WhatFont到你的谷歌浏览器，每当你看到网页上某一种字体时，点击它并悬停，就会给你所有的包括字体样式、大小等方案，甚至在可服务时给出下载地址（例如TypeKit或Webfonts）。十大必备的前端开发工具 在codepen上使用 Github 上的源码 如果想要引用 github 上的第三方库，有一个小技巧。首先找到源码的发行包（*.min.js）。以 stats.js 为例：https://github.com/mrdoob/stats.js/blob/master/build/stats.min.js 然后使用 rawgit 转换成 https://cdn.rawgit.com/mrdoob/stats.js/28632bd8/build/stats.min.js即可在 CodePen 中正常引用。如果直接使用原地址，会报以下错误： codepen相关： 玩转 CodePen 谷歌插件【待安装】Tab Snooze 用来隐藏稍后用到的标签页的 推荐理由： Tab Snooze通过直接让他们消失的办法来解决标签打开过多的问题，等你晚上或者第二天要的时候再出现。你可以在设置里调整这些标签页出现的时间，也能在列表里访问那些被你延迟出现的页面。作为一个在Twitter和Reddit上被“必看”轻松勾走注意力的人，这是保持我的任务顺利进行的必要条件。 Noisli 用白噪音提高专注度的 推荐理由： 由于工作风格的关系，你可能喜欢放点背景噪音来保持专注。Noisli 就能提供一系列环境声音，如雨，森林，风扇的嗡嗡声，甚至还有咖啡店的喧闹。你得先注册个账号才能用这个插件，不过也就一秒钟的事儿。注册完之后，你就能自己搭配喜欢的声音组合。另外他还有个定时器来帮你遵守日程安排，或者当番茄钟来马上完成任务。 Noisli 并不是同类产品中的首创，但一定是其中自定义程度最高的。他省去了如 Coffivity 这种需要新开一个标签页的麻烦。 时间管理RescueTime RescueTime跟踪您在浏览器的当前活动选项卡或窗口中花费的时间。 这可以让你清楚地了解你整天在做什么。 详情：http://chromecj.com/accessibility/2018-05/1432.html 推荐理由： 如果你经常觉得一天下来没有做太多的工作，想知道时间都去哪了，那么不用好好感受年轻，答案就在你的浏览记录里。 一张时间拖延浪费表可以给你好好打打鸡血，效率更高。它也可以告诉你什么时候可以完成更多的工作，优化你在办公桌上花费的时间。RescueTime的做法很简单。它暗搓搓地关注你在Chrome中的活动情况，生成图表来显示你在哪些网站上花了大量时间。你可以按天或者按月分析，看看哪天你最忙。 当然，不是非得成为统计学家才能明白报表结果，你一天都干嘛去了自己心里没点B数吗？ RescueTime的彩色图表简单易懂，看一眼就能帮你了解自己的浏览习惯。 免费版本包含的功能足够用来监控你的生产力;每年72美元的高级版额外提供网站拦截、工作时长通知等附加功能，还有更深入的报告。 如果你想找点更斯巴达的监控手段，一定要试试TimeStats。 Momentum 美化新建标签页并可以进行TODO list提醒设置 详情介绍：https://www.cnblogs.com/chromecj/p/6885036.html 滴答清单 国内的app软件的浏览器扩展，可以进TODO list管理，并且可以和移动端同步使用，做计划很方便！ Time keeper | Task timer 对任务时间进行计时记录和管理 程序员相关Page Ruler 测量网页尺子 Octotree 将GitHub的项目结构像IDE一样的目录结构展示出来 详情：https://www.cnblogs.com/12yang-ting/p/7485264.html LiveReload LiveReload 会监控你指定的目录中文件，如果有文件被更改，它就自动触发浏览器刷新页面，这样我们不用每次修改文件后，都要去按下 F5 刷新页面。 JSON-handle 安装了这款json-handle插件后，程序员就可以对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。 whatruns 网站分析工具,是一个chrome扩展, 你可以将它安装到chrome浏览器中, 看到感兴趣的网站, 则点击扩展图标, 一键分析(分析时间在5-10秒左右) 详情：https://zhaoolee.gitbooks.io/chrome/content/011whatruns300b-yi-jian-fen-xi-wang-zhan-ji-zhu-zhan.html 已安装未分类The Great Suspender 用来干掉不用的标签页的 推荐理由： 开了大量标签页之后Chrome就会占用许多内存资源。还好有个办法，在不用改变你浏览习惯得前提下就能释放内存。这款插件会将你在一个小时内没用过得标签页挂起，不让他们占用宝贵的内存；当你需要的时候只用点下刷新就好 OneTab 用来统一堆积如山的标签页的 推荐理由： 尽管OneTab旨在减少Chrome的内存使用量，但实际上它能帮助你有效地管理浏览情况。它的主要功能是将窗口中的所有打开的选项卡合并到一个表里，关闭每个选项卡并释放珍贵的RAM。然后你就可以一个接一个地或一次性恢复这些页面。如果你正巧看到许多有趣的页面，你可以把他们组合成一起分享出去，如果你愿意，还可以将其导出为纯文本地址。 这还不是全部：OneTab允许单击右键菜单栏给标签页群命名，也能单独加页面，这就能很方便地随你组织管理材料。如果你像我一样开着太多标签，你肯定会想尝试一下OneTab。 Extension Manager 对谷歌浏览器已安装的扩展进行管理 详情：https://www.jianshu.com/p/c1417deeb5a8 9、Nimbus：截图的插件推荐理由：截图很多， 但是nimbus可能是其中功能最丰富的一个。截图保存前可以用箭头和文本进行注释。 参考： http://www.cnplugins.com/zhuanti/tishengxiaolv.html]]></content>
      <categories>
        <category>工具</category>
        <category>🐰未分类🐰</category>
      </categories>
  </entry>
</search>
